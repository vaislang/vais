// HTTP runtime support for Vais
// Provides TCP socket operations, string utilities, and HTTP parsing
// for the std/http.vais standard library module.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <errno.h>

// ============================================
// Memory Operations
// Note: __store_byte, __store_i64, __load_i64, __load_ptr are generated
// inline by the Vais codegen as LLVM IR helpers, so they are NOT defined here
// to avoid duplicate symbol errors. Only functions NOT generated by codegen
// are provided here.
// ============================================

// __malloc and __free are wrappers around libc malloc/free with i64 interface.
// These may already be linked via libc, but we provide explicit wrappers
// in case the Vais code uses the __malloc/__free names specifically.
long __malloc(long size) {
    return (long)malloc((size_t)size);
}

long __free(long ptr) {
    if (ptr != 0) {
        free((void*)ptr);
    }
    return 0;
}

long __memcpy(long dst, long src, long len) {
    if (dst != 0 && src != 0 && len > 0) {
        memcpy((void*)dst, (void*)src, (size_t)len);
    }
    return dst;
}

long __store_ptr(long ptr, long value) {
    if (ptr != 0) {
        *(long*)ptr = value;
    }
    return 0;
}

// ============================================
// String Operations
// ============================================

long __strlen(const char* s) {
    if (s == NULL) return 0;
    return (long)strlen(s);
}

// Copy string to buffer, returns number of bytes written
long __str_copy_to(long dst, const char* src) {
    if (dst == 0 || src == NULL) return 0;
    size_t len = strlen(src);
    memcpy((void*)dst, src, len);
    return (long)len;
}

// Compare two strings for equality, returns 1 if equal, 0 otherwise
long __str_eq(const char* a, const char* b) {
    if (a == NULL && b == NULL) return 1;
    if (a == NULL || b == NULL) return 0;
    return strcmp(a, b) == 0 ? 1 : 0;
}

// Case-insensitive string comparison, returns 1 if equal, 0 otherwise
long __str_eq_ignore_case(const char* a, const char* b) {
    if (a == NULL && b == NULL) return 1;
    if (a == NULL || b == NULL) return 0;
    return strcasecmp(a, b) == 0 ? 1 : 0;
}

// Convert i64 to string at destination, returns number of bytes written
long __i64_to_str(long dst, long value) {
    if (dst == 0) return 0;
    int written = sprintf((char*)dst, "%ld", value);
    return (long)written;
}

// ============================================
// TCP Socket Operations (POSIX)
// ============================================

// Connect to a remote host. host is a pointer to a C string.
// Returns file descriptor on success, -1 on failure.
long __tcp_connect(long host, long port) {
    const char* hostname = (const char*)host;
    if (hostname == NULL) return -1;

    struct addrinfo hints, *result;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    char port_str[16];
    snprintf(port_str, sizeof(port_str), "%ld", port);

    int ret = getaddrinfo(hostname, port_str, &hints, &result);
    if (ret != 0) return -1;

    int fd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if (fd < 0) {
        freeaddrinfo(result);
        return -1;
    }

    if (connect(fd, result->ai_addr, result->ai_addrlen) < 0) {
        close(fd);
        freeaddrinfo(result);
        return -1;
    }

    freeaddrinfo(result);
    return (long)fd;
}

// Create a listening TCP socket on the given port.
// Returns file descriptor on success, -1 on failure.
long __tcp_listen(long port) {
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) return -1;

    int opt = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons((uint16_t)port);

    if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        close(fd);
        return -1;
    }

    if (listen(fd, 128) < 0) {
        close(fd);
        return -1;
    }

    return (long)fd;
}

// Accept an incoming connection on a listening socket.
// Returns new file descriptor on success, -1 on failure.
long __tcp_accept(long listener_fd) {
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);

    int fd = accept((int)listener_fd, (struct sockaddr*)&client_addr, &client_len);
    if (fd < 0) return -1;
    return (long)fd;
}

// Send data on a connected socket.
// Returns number of bytes sent, or -1 on error.
long __tcp_send(long fd, long data, long len) {
    if (data == 0 || len <= 0) return -1;
    ssize_t sent = send((int)fd, (const void*)data, (size_t)len, 0);
    return (long)sent;
}

// Receive data from a connected socket.
// Returns number of bytes received, 0 on disconnect, -1 on error.
long __tcp_recv(long fd, long buffer, long len) {
    if (buffer == 0 || len <= 0) return -1;
    ssize_t received = recv((int)fd, (void*)buffer, (size_t)len, 0);
    return (long)received;
}

// Close a socket file descriptor.
long __tcp_close(long fd) {
    if (fd >= 0) {
        close((int)fd);
    }
    return 0;
}

// ============================================
// HTTP Parsing
// ============================================

// Find the end of HTTP headers (\r\n\r\n) in buffer.
// Returns offset of body start, or -1 if not found.
long __find_header_end(long buffer, long len) {
    const char* buf = (const char*)buffer;
    if (buf == NULL || len < 4) return -1;

    for (long i = 0; i <= len - 4; i++) {
        if (buf[i] == '\r' && buf[i+1] == '\n' &&
            buf[i+2] == '\r' && buf[i+3] == '\n') {
            return i + 4;
        }
    }
    return -1;
}

// Vais Request struct layout (must match std/http.vais):
// offset 0:  method (i64)
// offset 8:  path (ptr/str)
// offset 16: version (ptr/str)
// offset 24: headers.items (i64 ptr)
// offset 32: headers.count (i64)
// offset 40: headers.capacity (i64)
// offset 48: body (i64 ptr)
// offset 56: body_len (i64)

// Helper: parse method string to integer
static long parse_method(const char* method, size_t len) {
    if (len == 3 && strncmp(method, "GET", 3) == 0) return 1;
    if (len == 4 && strncmp(method, "POST", 4) == 0) return 2;
    if (len == 3 && strncmp(method, "PUT", 3) == 0) return 3;
    if (len == 6 && strncmp(method, "DELETE", 6) == 0) return 4;
    if (len == 5 && strncmp(method, "PATCH", 5) == 0) return 5;
    if (len == 4 && strncmp(method, "HEAD", 4) == 0) return 6;
    if (len == 7 && strncmp(method, "OPTIONS", 7) == 0) return 7;
    return 1; // default to GET
}

// Helper: duplicate a substring as a new C string
static char* strndup_helper(const char* s, size_t n) {
    char* result = (char*)malloc(n + 1);
    if (result) {
        memcpy(result, s, n);
        result[n] = '\0';
    }
    return result;
}

// Parse an HTTP request from raw bytes.
// Returns a Request struct by value (8 fields * 8 bytes = 64 bytes).
// Note: Vais compiler handles struct return via sret pointer.
typedef struct {
    long method;
    const char* path;
    const char* version;
    long header_items;
    long header_count;
    long header_capacity;
    long body;
    long body_len;
} VaisRequest;

typedef struct {
    long status;
    const char* status_text;
    const char* version;
    long header_items;
    long header_count;
    long header_capacity;
    long body;
    long body_len;
} VaisResponse;

void __parse_request(VaisRequest* out, long buffer, long len) {
    const char* buf = (const char*)buffer;
    if (buf == NULL || len <= 0 || out == NULL) {
        if (out) memset(out, 0, sizeof(VaisRequest));
        return;
    }

    // Initialize output
    memset(out, 0, sizeof(VaisRequest));

    const char* p = buf;
    const char* end = buf + len;

    // Parse method
    const char* method_start = p;
    while (p < end && *p != ' ') p++;
    out->method = parse_method(method_start, (size_t)(p - method_start));

    // Skip space
    if (p < end) p++;

    // Parse path
    const char* path_start = p;
    while (p < end && *p != ' ') p++;
    out->path = strndup_helper(path_start, (size_t)(p - path_start));

    // Skip space
    if (p < end) p++;

    // Parse version
    const char* ver_start = p;
    while (p < end && *p != '\r' && *p != '\n') p++;
    out->version = strndup_helper(ver_start, (size_t)(p - ver_start));

    // Skip \r\n
    if (p < end && *p == '\r') p++;
    if (p < end && *p == '\n') p++;

    // Parse headers into allocated array
    long capacity = 16;
    long* items = (long*)malloc((size_t)(capacity * 16));
    long count = 0;

    while (p < end) {
        // Check for end of headers
        if (*p == '\r' || *p == '\n') {
            if (p < end && *p == '\r') p++;
            if (p < end && *p == '\n') p++;
            break;
        }

        // Parse header name
        const char* name_start = p;
        while (p < end && *p != ':') p++;
        char* name = strndup_helper(name_start, (size_t)(p - name_start));

        // Skip ": "
        if (p < end) p++; // skip ':'
        while (p < end && *p == ' ') p++;

        // Parse header value
        const char* val_start = p;
        while (p < end && *p != '\r' && *p != '\n') p++;
        char* value = strndup_helper(val_start, (size_t)(p - val_start));

        // Skip \r\n
        if (p < end && *p == '\r') p++;
        if (p < end && *p == '\n') p++;

        // Grow if needed
        if (count >= capacity) {
            capacity *= 2;
            items = (long*)realloc(items, (size_t)(capacity * 16));
        }

        // Store header (16 bytes: name ptr + value ptr)
        long offset = count * 2; // 2 longs per header
        items[offset] = (long)name;
        items[offset + 1] = (long)value;
        count++;
    }

    out->header_items = (long)items;
    out->header_count = count;
    out->header_capacity = capacity;

    // Body is everything after headers
    if (p < end) {
        out->body = (long)p;
        out->body_len = (long)(end - p);
    }
}

void __parse_response(VaisResponse* out, long buffer, long len) {
    const char* buf = (const char*)buffer;
    if (buf == NULL || len <= 0 || out == NULL) {
        if (out) memset(out, 0, sizeof(VaisResponse));
        return;
    }

    memset(out, 0, sizeof(VaisResponse));

    const char* p = buf;
    const char* end = buf + len;

    // Parse version (e.g., "HTTP/1.1")
    const char* ver_start = p;
    while (p < end && *p != ' ') p++;
    out->version = strndup_helper(ver_start, (size_t)(p - ver_start));

    // Skip space
    if (p < end) p++;

    // Parse status code
    long status = 0;
    while (p < end && *p >= '0' && *p <= '9') {
        status = status * 10 + (*p - '0');
        p++;
    }
    out->status = status;

    // Skip space
    if (p < end) p++;

    // Parse status text
    const char* text_start = p;
    while (p < end && *p != '\r' && *p != '\n') p++;
    out->status_text = strndup_helper(text_start, (size_t)(p - text_start));

    // Skip \r\n
    if (p < end && *p == '\r') p++;
    if (p < end && *p == '\n') p++;

    // Parse headers
    long capacity = 16;
    long* items = (long*)malloc((size_t)(capacity * 16));
    long count = 0;

    while (p < end) {
        if (*p == '\r' || *p == '\n') {
            if (p < end && *p == '\r') p++;
            if (p < end && *p == '\n') p++;
            break;
        }

        const char* name_start = p;
        while (p < end && *p != ':') p++;
        char* name = strndup_helper(name_start, (size_t)(p - name_start));

        if (p < end) p++;
        while (p < end && *p == ' ') p++;

        const char* val_start = p;
        while (p < end && *p != '\r' && *p != '\n') p++;
        char* value = strndup_helper(val_start, (size_t)(p - val_start));

        if (p < end && *p == '\r') p++;
        if (p < end && *p == '\n') p++;

        if (count >= capacity) {
            capacity *= 2;
            items = (long*)realloc(items, (size_t)(capacity * 16));
        }

        long offset = count * 2;
        items[offset] = (long)name;
        items[offset + 1] = (long)value;
        count++;
    }

    out->header_items = (long)items;
    out->header_count = count;
    out->header_capacity = capacity;

    if (p < end) {
        out->body = (long)p;
        out->body_len = (long)(end - p);
    }
}

// ============================================
// URL Parsing
// ============================================

// Parse host from URL (e.g., "http://example.com:8080/path" -> "example.com")
const char* __parse_url_host(const char* url) {
    if (url == NULL) return "";

    const char* p = url;
    // Skip protocol
    if (strncmp(p, "http://", 7) == 0) p += 7;
    else if (strncmp(p, "https://", 8) == 0) p += 8;

    const char* host_start = p;
    while (*p && *p != ':' && *p != '/' && *p != '?') p++;

    return strndup_helper(host_start, (size_t)(p - host_start));
}

// Parse port from URL. Returns 0 if no port specified.
long __parse_url_port(const char* url) {
    if (url == NULL) return 0;

    const char* p = url;
    if (strncmp(p, "http://", 7) == 0) p += 7;
    else if (strncmp(p, "https://", 8) == 0) p += 8;

    // Skip host
    while (*p && *p != ':' && *p != '/' && *p != '?') p++;

    if (*p != ':') return 0;
    p++; // skip ':'

    long port = 0;
    while (*p >= '0' && *p <= '9') {
        port = port * 10 + (*p - '0');
        p++;
    }
    return port;
}

// Parse path from URL (e.g., "http://example.com/api/v1" -> "/api/v1")
const char* __parse_url_path(const char* url) {
    if (url == NULL) return "/";

    const char* p = url;
    if (strncmp(p, "http://", 7) == 0) p += 7;
    else if (strncmp(p, "https://", 8) == 0) p += 8;

    // Skip host and optional port
    while (*p && *p != '/') p++;

    if (*p == '\0') return "/";

    // Find end of path (before query string)
    const char* path_start = p;
    const char* path_end = p;
    while (*path_end && *path_end != '?' && *path_end != '#') path_end++;

    return strndup_helper(path_start, (size_t)(path_end - path_start));
}

// ============================================
// Handler Calling
// ============================================

// Call a Vais function pointer handler with a Request reference.
// handler is a function pointer: (VaisRequest*) -> VaisResponse
// Returns Response by value via sret.
typedef void (*vais_handler_fn)(VaisResponse* out, const VaisRequest* req);

void __call_handler(VaisResponse* out, long handler, const VaisRequest* request) {
    if (handler == 0 || out == NULL) {
        if (out) {
            memset(out, 0, sizeof(VaisResponse));
            out->status = 500;
            out->status_text = "Internal Server Error";
            out->version = "HTTP/1.1";
        }
        return;
    }

    vais_handler_fn fn = (vais_handler_fn)handler;
    fn(out, request);
}
