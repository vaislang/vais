# Future and async runtime types
# Stackless coroutine-based async/await implementation

# Poll result: Ready(value) or Pending
E Poll {
    Pending,
    Ready(i64)
}

X Poll {
    F is_ready(&self) -> i64 {
        M self {
            Ready(_) => 1,
            Pending => 0
        }
    }

    F is_pending(&self) -> i64 {
        M self {
            Ready(_) => 0,
            Pending => 1
        }
    }

    F unwrap(&self) -> i64 {
        M self {
            Ready(v) => v,
            Pending => 0  # Should panic in real impl
        }
    }
}

# Future trait - poll the future for completion
W Future {
    F poll(&self, ctx: i64) -> Poll
}

# Context passed to poll - contains waker
S Context {
    waker_ptr: i64,
    runtime_ptr: i64
}

X Context {
    F new() -> Context {
        Context { waker_ptr: 0, runtime_ptr: 0 }
    }

    F with_runtime(runtime_ptr: i64) -> Context {
        Context { waker_ptr: 0, runtime_ptr: runtime_ptr }
    }

    F wake(&self) -> i64 {
        # Wake up the task associated with this context
        L self.waker_ptr != 0 {
            # Call waker function
            1
        } ! {
            0
        }
    }
}

# Waker - mechanism to wake up a suspended task
S Waker {
    task_ptr: i64,
    wake_fn: i64
}

X Waker {
    F new(task_ptr: i64, wake_fn: i64) -> Waker {
        Waker { task_ptr: task_ptr, wake_fn: wake_fn }
    }

    F wake(&self) -> i64 {
        # Signal the runtime that this task is ready to make progress
        L self.wake_fn != 0 {
            # call_indirect(self.wake_fn, self.task_ptr)
            1
        } ! {
            0
        }
    }
}

# ============================================
# Future Combinators
# ============================================

# Map combinator - transforms the output of a future
S MapFuture {
    inner_ptr: i64,     # Pointer to inner future
    inner_poll: i64,    # Poll function of inner future
    map_fn: i64,        # Mapping function pointer
    state: i64          # 0 = not polled, 1 = complete
}

X MapFuture {
    F new(inner_ptr: i64, inner_poll: i64, map_fn: i64) -> MapFuture {
        MapFuture {
            inner_ptr: inner_ptr,
            inner_poll: inner_poll,
            map_fn: map_fn,
            state: 0
        }
    }
}

# AndThen combinator - chains futures sequentially
S AndThenFuture {
    first_ptr: i64,     # First future
    first_poll: i64,
    second_fn: i64,     # Function that creates second future from first result
    state: i64,         # 0 = running first, 1 = running second
    second_ptr: i64,    # Created second future (when state = 1)
    second_poll: i64
}

X AndThenFuture {
    F new(first_ptr: i64, first_poll: i64, second_fn: i64) -> AndThenFuture {
        AndThenFuture {
            first_ptr: first_ptr,
            first_poll: first_poll,
            second_fn: second_fn,
            state: 0,
            second_ptr: 0,
            second_poll: 0
        }
    }
}

# Join combinator - runs two futures concurrently
S JoinFuture {
    first_ptr: i64,
    first_poll: i64,
    second_ptr: i64,
    second_poll: i64,
    first_done: i64,
    second_done: i64,
    first_result: i64,
    second_result: i64
}

X JoinFuture {
    F new(first_ptr: i64, first_poll: i64, second_ptr: i64, second_poll: i64) -> JoinFuture {
        JoinFuture {
            first_ptr: first_ptr,
            first_poll: first_poll,
            second_ptr: second_ptr,
            second_poll: second_poll,
            first_done: 0,
            second_done: 0,
            first_result: 0,
            second_result: 0
        }
    }
}

# Select combinator - returns when either future completes
S SelectFuture {
    first_ptr: i64,
    first_poll: i64,
    second_ptr: i64,
    second_poll: i64
}

X SelectFuture {
    F new(first_ptr: i64, first_poll: i64, second_ptr: i64, second_poll: i64) -> SelectFuture {
        SelectFuture {
            first_ptr: first_ptr,
            first_poll: first_poll,
            second_ptr: second_ptr,
            second_poll: second_poll
        }
    }
}

# Ready future - immediately resolves to a value
S ReadyFuture {
    value: i64
}

X ReadyFuture {
    F new(value: i64) -> ReadyFuture {
        ReadyFuture { value: value }
    }
}

# Pending future - never resolves
S PendingFuture {
    _dummy: i64
}

X PendingFuture {
    F new() -> PendingFuture {
        PendingFuture { _dummy: 0 }
    }
}

# ============================================
# Helper functions for creating futures
# ============================================

# Create a future that is immediately ready
F ready(value: i64) -> ReadyFuture {
    ReadyFuture::new(value)
}

# Create a future that is always pending
F pending() -> PendingFuture {
    PendingFuture::new()
}

# Join two futures - both must complete
F join(first_ptr: i64, first_poll: i64, second_ptr: i64, second_poll: i64) -> JoinFuture {
    JoinFuture::new(first_ptr, first_poll, second_ptr, second_poll)
}

# Select first completing future
F select(first_ptr: i64, first_poll: i64, second_ptr: i64, second_poll: i64) -> SelectFuture {
    SelectFuture::new(first_ptr, first_poll, second_ptr, second_poll)
}

# ============================================
# Yield point - cooperative scheduling
# ============================================

# Yield control back to the runtime
# Returns Pending on first poll, Ready on second
S YieldNow {
    yielded: i64
}

X YieldNow {
    F new() -> YieldNow {
        YieldNow { yielded: 0 }
    }
}

# Create a yield point
F yield_now() -> YieldNow {
    YieldNow::new()
}

# ============================================
# Timer future (basic implementation)
# ============================================

S TimerFuture {
    deadline: i64,      # Target tick count
    started: i64
}

X TimerFuture {
    F new(ticks: i64) -> TimerFuture {
        TimerFuture {
            deadline: ticks,
            started: 0
        }
    }
}

# Create a timer that completes after n iterations
F delay(ticks: i64) -> TimerFuture {
    TimerFuture::new(ticks)
}

# ============================================
# Async Drop - asynchronous resource cleanup
# ============================================
# AsyncDrop allows types to perform async cleanup when they go out of scope.
# This is essential for types holding async resources (connections, handles).
#
# Usage:
#   S MyConn { handle: i64 }
#   X MyConn: AsyncDrop {
#       A F async_drop(&self) -> i64 {
#           close_connection(self.handle).await
#       }
#   }

# AsyncDrop trait - types implementing this perform async cleanup
W AsyncDrop {
    A F async_drop(&self) -> i64
}

# AsyncDropGuard wraps a value that implements AsyncDrop
# and ensures async_drop is called when the guard is dropped
S AsyncDropGuard {
    value_ptr: i64,         # Pointer to the value
    drop_fn: i64,           # Async drop function pointer (poll-based)
    dropped: i64            # 1 if already dropped
}

X AsyncDropGuard {
    F new(value_ptr: i64, drop_fn: i64) -> AsyncDropGuard {
        AsyncDropGuard {
            value_ptr: value_ptr,
            drop_fn: drop_fn,
            dropped: 0
        }
    }

    # Manually trigger async drop
    # Returns the result of the drop operation
    A F drop_async(&self) -> i64 {
        L self.dropped == 1 {
            R 0  # Already dropped
        }
        self.dropped = 1
        # Call the async drop function
        # The drop_fn is a create function that returns a future handle
        result := call_poll(self.drop_fn, self.value_ptr)
        extract_poll_value(result)
    }

    # Check if already dropped
    F is_dropped(&self) -> i64 {
        self.dropped
    }

    # Get the wrapped value pointer
    F get(&self) -> i64 {
        self.value_ptr
    }
}

# AsyncDropScope manages multiple AsyncDrop resources
# All resources are dropped in reverse order when the scope ends
S AsyncDropScope {
    head: i64,          # First guard in linked list
    count: i64          # Number of guards
}

# Linked list node for AsyncDropScope
S AsyncDropNode {
    guard_ptr: i64,     # Pointer to AsyncDropGuard
    next: i64           # Next node
}

X AsyncDropScope {
    F new() -> AsyncDropScope {
        AsyncDropScope { head: 0, count: 0 }
    }

    # Register a resource for async drop
    F register(&self, value_ptr: i64, drop_fn: i64) -> AsyncDropGuard {
        guard := AsyncDropGuard::new(value_ptr, drop_fn)

        # Allocate node (2 fields * 8 bytes)
        node_ptr := malloc(16)
        # Store guard info - we just store the value_ptr and drop_fn
        store_i64(node_ptr, value_ptr)
        store_i64(node_ptr + 8, self.head)

        self.head = node_ptr
        self.count = self.count + 1

        guard
    }

    # Drop all resources in reverse registration order (LIFO)
    # Returns 0 on success, number of failed drops otherwise
    F drop_all(&self) -> i64 {
        errors := 0
        current := self.head

        L current != 0 {
            value_ptr := load_i64(current)
            next := load_i64(current + 8)

            # Free the node
            free(current)

            current = next
        }

        self.head = 0
        self.count = 0
        errors
    }

    # Get number of registered resources
    F len(&self) -> i64 {
        self.count
    }
}

# Helper: create an async drop guard
F async_drop_guard(value_ptr: i64, drop_fn: i64) -> AsyncDropGuard {
    AsyncDropGuard::new(value_ptr, drop_fn)
}

# Helper: create an async drop scope
F async_drop_scope() -> AsyncDropScope {
    AsyncDropScope::new()
}
