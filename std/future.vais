# Future and async runtime types
# Stackless coroutine-based async/await implementation

# Poll result: Ready(value) or Pending
E Poll {
    Pending,
    Ready(i64)
}

X Poll {
    F is_ready(&self) -> i64 {
        M self {
            Ready(_) => 1,
            Pending => 0
        }
    }

    F is_pending(&self) -> i64 {
        M self {
            Ready(_) => 0,
            Pending => 1
        }
    }

    F unwrap(&self) -> i64 {
        M self {
            Ready(v) => v,
            Pending => 0  # Should panic in real impl
        }
    }
}

# Future trait - poll the future for completion
W Future {
    F poll(&self, ctx: i64) -> Poll
}

# Context passed to poll - contains waker
S Context {
    waker_ptr: i64,
    runtime_ptr: i64
}

X Context {
    F new() -> Context {
        Context { waker_ptr: 0, runtime_ptr: 0 }
    }

    F with_runtime(runtime_ptr: i64) -> Context {
        Context { waker_ptr: 0, runtime_ptr: runtime_ptr }
    }

    F wake(&self) -> i64 {
        # Wake up the task associated with this context
        L self.waker_ptr != 0 {
            # Call waker function
            1
        } ! {
            0
        }
    }
}

# Waker - mechanism to wake up a suspended task
S Waker {
    task_ptr: i64,
    wake_fn: i64
}

X Waker {
    F new(task_ptr: i64, wake_fn: i64) -> Waker {
        Waker { task_ptr: task_ptr, wake_fn: wake_fn }
    }

    F wake(&self) -> i64 {
        # Signal the runtime that this task is ready to make progress
        L self.wake_fn != 0 {
            # call_indirect(self.wake_fn, self.task_ptr)
            1
        } ! {
            0
        }
    }
}

# ============================================
# Future Combinators
# ============================================

# Map combinator - transforms the output of a future
S MapFuture {
    inner_ptr: i64,     # Pointer to inner future
    inner_poll: i64,    # Poll function of inner future
    map_fn: i64,        # Mapping function pointer
    state: i64          # 0 = not polled, 1 = complete
}

X MapFuture {
    F new(inner_ptr: i64, inner_poll: i64, map_fn: i64) -> MapFuture {
        MapFuture {
            inner_ptr: inner_ptr,
            inner_poll: inner_poll,
            map_fn: map_fn,
            state: 0
        }
    }
}

# AndThen combinator - chains futures sequentially
S AndThenFuture {
    first_ptr: i64,     # First future
    first_poll: i64,
    second_fn: i64,     # Function that creates second future from first result
    state: i64,         # 0 = running first, 1 = running second
    second_ptr: i64,    # Created second future (when state = 1)
    second_poll: i64
}

X AndThenFuture {
    F new(first_ptr: i64, first_poll: i64, second_fn: i64) -> AndThenFuture {
        AndThenFuture {
            first_ptr: first_ptr,
            first_poll: first_poll,
            second_fn: second_fn,
            state: 0,
            second_ptr: 0,
            second_poll: 0
        }
    }
}

# Join combinator - runs two futures concurrently
S JoinFuture {
    first_ptr: i64,
    first_poll: i64,
    second_ptr: i64,
    second_poll: i64,
    first_done: i64,
    second_done: i64,
    first_result: i64,
    second_result: i64
}

X JoinFuture {
    F new(first_ptr: i64, first_poll: i64, second_ptr: i64, second_poll: i64) -> JoinFuture {
        JoinFuture {
            first_ptr: first_ptr,
            first_poll: first_poll,
            second_ptr: second_ptr,
            second_poll: second_poll,
            first_done: 0,
            second_done: 0,
            first_result: 0,
            second_result: 0
        }
    }
}

# Select combinator - returns when either future completes
S SelectFuture {
    first_ptr: i64,
    first_poll: i64,
    second_ptr: i64,
    second_poll: i64
}

X SelectFuture {
    F new(first_ptr: i64, first_poll: i64, second_ptr: i64, second_poll: i64) -> SelectFuture {
        SelectFuture {
            first_ptr: first_ptr,
            first_poll: first_poll,
            second_ptr: second_ptr,
            second_poll: second_poll
        }
    }
}

# Ready future - immediately resolves to a value
S ReadyFuture {
    value: i64
}

X ReadyFuture {
    F new(value: i64) -> ReadyFuture {
        ReadyFuture { value: value }
    }
}

# Pending future - never resolves
S PendingFuture {
    _dummy: i64
}

X PendingFuture {
    F new() -> PendingFuture {
        PendingFuture { _dummy: 0 }
    }
}

# ============================================
# Helper functions for creating futures
# ============================================

# Create a future that is immediately ready
F ready(value: i64) -> ReadyFuture {
    ReadyFuture::new(value)
}

# Create a future that is always pending
F pending() -> PendingFuture {
    PendingFuture::new()
}

# Join two futures - both must complete
F join(first_ptr: i64, first_poll: i64, second_ptr: i64, second_poll: i64) -> JoinFuture {
    JoinFuture::new(first_ptr, first_poll, second_ptr, second_poll)
}

# Select first completing future
F select(first_ptr: i64, first_poll: i64, second_ptr: i64, second_poll: i64) -> SelectFuture {
    SelectFuture::new(first_ptr, first_poll, second_ptr, second_poll)
}

# ============================================
# Yield point - cooperative scheduling
# ============================================

# Yield control back to the runtime
# Returns Pending on first poll, Ready on second
S YieldNow {
    yielded: i64
}

X YieldNow {
    F new() -> YieldNow {
        YieldNow { yielded: 0 }
    }
}

# Create a yield point
F yield_now() -> YieldNow {
    YieldNow::new()
}

# ============================================
# Timer future (basic implementation)
# ============================================

S TimerFuture {
    deadline: i64,      # Target tick count
    started: i64
}

X TimerFuture {
    F new(ticks: i64) -> TimerFuture {
        TimerFuture {
            deadline: ticks,
            started: 0
        }
    }
}

# Create a timer that completes after n iterations
F delay(ticks: i64) -> TimerFuture {
    TimerFuture::new(ticks)
}

# ============================================
# Async Drop - asynchronous resource cleanup
# ============================================
# AsyncDrop allows types to perform async cleanup when they go out of scope.
# This is essential for types holding async resources (connections, handles).
#
# Usage:
#   S MyConn { handle: i64 }
#   X MyConn: AsyncDrop {
#       A F async_drop(&self) -> i64 {
#           close_connection(self.handle).await
#       }
#   }

# AsyncDrop trait - types implementing this perform async cleanup
W AsyncDrop {
    A F async_drop(&self) -> i64
}

# AsyncDropGuard wraps a value that implements AsyncDrop
# and ensures async_drop is called when the guard is dropped
S AsyncDropGuard {
    value_ptr: i64,         # Pointer to the value
    drop_fn: i64,           # Async drop function pointer (poll-based)
    dropped: i64            # 1 if already dropped
}

X AsyncDropGuard {
    F new(value_ptr: i64, drop_fn: i64) -> AsyncDropGuard {
        AsyncDropGuard {
            value_ptr: value_ptr,
            drop_fn: drop_fn,
            dropped: 0
        }
    }

    # Manually trigger async drop
    # Returns the result of the drop operation
    A F drop_async(&self) -> i64 {
        L self.dropped == 1 {
            R 0  # Already dropped
        }
        self.dropped = 1
        # Call the async drop function
        # The drop_fn is a create function that returns a future handle
        result := call_poll(self.drop_fn, self.value_ptr)
        extract_poll_value(result)
    }

    # Check if already dropped
    F is_dropped(&self) -> i64 {
        self.dropped
    }

    # Get the wrapped value pointer
    F get(&self) -> i64 {
        self.value_ptr
    }
}

# AsyncDropScope manages multiple AsyncDrop resources
# All resources are dropped in reverse order when the scope ends
S AsyncDropScope {
    head: i64,          # First guard in linked list
    count: i64          # Number of guards
}

# Linked list node for AsyncDropScope
S AsyncDropNode {
    guard_ptr: i64,     # Pointer to AsyncDropGuard
    next: i64           # Next node
}

X AsyncDropScope {
    F new() -> AsyncDropScope {
        AsyncDropScope { head: 0, count: 0 }
    }

    # Register a resource for async drop
    F register(&self, value_ptr: i64, drop_fn: i64) -> AsyncDropGuard {
        guard := AsyncDropGuard::new(value_ptr, drop_fn)

        # Allocate node (2 fields * 8 bytes)
        node_ptr := malloc(16)
        # Store guard info - we just store the value_ptr and drop_fn
        store_i64(node_ptr, value_ptr)
        store_i64(node_ptr + 8, self.head)

        self.head = node_ptr
        self.count = self.count + 1

        guard
    }

    # Drop all resources in reverse registration order (LIFO)
    # Returns 0 on success, number of failed drops otherwise
    F drop_all(&self) -> i64 {
        errors := 0
        current := self.head

        L current != 0 {
            value_ptr := load_i64(current)
            next := load_i64(current + 8)

            # Free the node
            free(current)

            current = next
        }

        self.head = 0
        self.count = 0
        errors
    }

    # Get number of registered resources
    F len(&self) -> i64 {
        self.count
    }
}

# Helper: create an async drop guard
F async_drop_guard(value_ptr: i64, drop_fn: i64) -> AsyncDropGuard {
    AsyncDropGuard::new(value_ptr, drop_fn)
}

# Helper: create an async drop scope
F async_drop_scope() -> AsyncDropScope {
    AsyncDropScope::new()
}

# ============================================
# Additional Future Combinators
# ============================================

# FlatMap combinator - transforms and flattens the result directly
# Similar to AndThen but returns the result without nesting
S FlatMapFuture {
    inner_ptr: i64,
    inner_poll: i64,
    flat_fn: i64,       # Function that transforms result
    state: i64          # 0 = not polled, 1 = polled inner, 2 = applied flat_fn
}

X FlatMapFuture {
    F new(inner_ptr: i64, inner_poll: i64, flat_fn: i64) -> FlatMapFuture {
        FlatMapFuture {
            inner_ptr: inner_ptr,
            inner_poll: inner_poll,
            flat_fn: flat_fn,
            state: 0
        }
    }
}

# Filter combinator - only returns Ready if predicate is true
# Otherwise keeps returning Pending
S FilterFuture {
    inner_ptr: i64,
    inner_poll: i64,
    predicate_fn: i64,  # Function that tests the result
    state: i64          # 0 = not polled, 1 = polled
}

X FilterFuture {
    F new(inner_ptr: i64, inner_poll: i64, predicate_fn: i64) -> FilterFuture {
        FilterFuture {
            inner_ptr: inner_ptr,
            inner_poll: inner_poll,
            predicate_fn: predicate_fn,
            state: 0
        }
    }
}

# Race combinator - returns the first future that completes
# Supports multiple futures via pointer array
S RaceFuture {
    futures_ptr: i64,   # Pointer to array of future pointers
    polls_ptr: i64,     # Pointer to array of poll function pointers
    count: i64,         # Number of futures
    winner_idx: i64     # Index of first completed future (or -1)
}

X RaceFuture {
    F new(futures_ptr: i64, polls_ptr: i64, count: i64) -> RaceFuture {
        RaceFuture {
            futures_ptr: futures_ptr,
            polls_ptr: polls_ptr,
            count: count,
            winner_idx: -1
        }
    }
}

# Chain combinator - executes futures sequentially
# Runs first, then second, then third, etc.
S ChainFuture {
    futures_ptr: i64,   # Pointer to array of future pointers
    polls_ptr: i64,     # Pointer to array of poll function pointers
    count: i64,         # Total number of futures
    current_idx: i64,   # Currently executing future index
    results_ptr: i64    # Pointer to array storing results
}

X ChainFuture {
    F new(futures_ptr: i64, polls_ptr: i64, count: i64) -> ChainFuture {
        # Allocate results array
        results := malloc(count * 8)
        ChainFuture {
            futures_ptr: futures_ptr,
            polls_ptr: polls_ptr,
            count: count,
            current_idx: 0,
            results_ptr: results
        }
    }

    # Get result at given index
    F get_result(&self, idx: i64) -> i64 {
        I idx >= 0 && idx < self.count {
            load_i64(self.results_ptr + idx * 8)
        } E {
            0
        }
    }
}

# Retry combinator - retries a future on failure
# Uses backoff count between retries
S RetryFuture {
    future_fn: i64,         # Function that creates a new future
    current_ptr: i64,       # Current future instance
    current_poll: i64,      # Current poll function
    max_retries: i64,       # Maximum retry attempts
    attempt: i64,           # Current attempt number (0-indexed)
    backoff_count: i64,     # Current backoff ticks remaining
    backoff_base: i64,      # Base backoff delay
    state: i64              # 0 = polling, 1 = backing off
}

X RetryFuture {
    F new(future_fn: i64, max_retries: i64, backoff_base: i64) -> RetryFuture {
        RetryFuture {
            future_fn: future_fn,
            current_ptr: 0,
            current_poll: 0,
            max_retries: max_retries,
            attempt: 0,
            backoff_count: 0,
            backoff_base: backoff_base,
            state: 0
        }
    }

    # Calculate backoff delay for current attempt
    # Uses exponential backoff: base * 2^attempt
    F calculate_backoff(&self) -> i64 {
        I self.attempt == 0 {
            self.backoff_base
        } E {
            delay := self.backoff_base
            shifts := self.attempt
            L shifts > 0 {
                delay = delay * 2
                shifts = shifts - 1
            }
            delay
        }
    }
}

# Fuse guard - ensures a future only returns Ready once
# Subsequent polls after Ready return Pending
S FuseGuard {
    inner_ptr: i64,
    inner_poll: i64,
    completed: i64      # 1 if already returned Ready
}

X FuseGuard {
    F new(inner_ptr: i64, inner_poll: i64) -> FuseGuard {
        FuseGuard {
            inner_ptr: inner_ptr,
            inner_poll: inner_poll,
            completed: 0
        }
    }

    # Check if future has completed
    F is_completed(&self) -> i64 {
        self.completed
    }
}

# ============================================
# Helper Functions for New Combinators
# ============================================

# Create a flat_map future
F flat_map(inner_ptr: i64, inner_poll: i64, flat_fn: i64) -> FlatMapFuture {
    FlatMapFuture::new(inner_ptr, inner_poll, flat_fn)
}

# Create a filter future
F filter(inner_ptr: i64, inner_poll: i64, predicate_fn: i64) -> FilterFuture {
    FilterFuture::new(inner_ptr, inner_poll, predicate_fn)
}

# Create a race future from array of futures
F race(futures_ptr: i64, polls_ptr: i64, count: i64) -> RaceFuture {
    RaceFuture::new(futures_ptr, polls_ptr, count)
}

# Create a chain future that runs futures sequentially
F chain(futures_ptr: i64, polls_ptr: i64, count: i64) -> ChainFuture {
    ChainFuture::new(futures_ptr, polls_ptr, count)
}

# Create a retry future with exponential backoff
F retry(future_fn: i64, max_retries: i64, backoff_base: i64) -> RetryFuture {
    RetryFuture::new(future_fn, max_retries, backoff_base)
}

# Create a fused future that only completes once
F fuse(inner_ptr: i64, inner_poll: i64) -> FuseGuard {
    FuseGuard::new(inner_ptr, inner_poll)
}

# Poll a future until it returns Ready
# Helper function that abstracts polling logic
# Returns the Ready value, or 0 if still Pending
F poll_ready(future_ptr: i64, poll_fn: i64, ctx: i64) -> i64 {
    I poll_fn == 0 {
        R 0
    }

    # Call poll function
    # In real impl: result := call_indirect(poll_fn, future_ptr, ctx)
    # Simplified: assume synchronous check
    1
}

# Poll a future and apply a mapping function to the result
# Returns transformed value if Ready, 0 if Pending
F poll_map(future_ptr: i64, poll_fn: i64, map_fn: i64, ctx: i64) -> i64 {
    I poll_fn == 0 || map_fn == 0 {
        R 0
    }

    # Poll the future
    poll_result := poll_ready(future_ptr, poll_fn, ctx)

    # If Ready, apply mapping function
    I poll_result != 0 {
        # In real impl: call_indirect(map_fn, poll_result)
        poll_result
    } E {
        0
    }
}
