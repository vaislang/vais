# File I/O - basic file operations
# Uses C standard library functions via extern
# Updated to use Option<T> for error handling

# Seek origin constants
C SEEK_SET: i64 = 0  # Beginning of file
C SEEK_CUR: i64 = 1  # Current position
C SEEK_END: i64 = 2  # End of file

# File handle wrapper
S File {
    handle: i64,    # FILE* pointer (0 if closed/invalid)
    mode: i64       # 0=closed, 1=read, 2=write, 3=append
}

# File open modes (constants)
# MODE_READ = 1
# MODE_WRITE = 2
# MODE_APPEND = 3

X File {
    # Open file for reading
    # Returns File with handle=0 if failed
    F open_read(path: i64) -> File {
        # Validate path is not null
        I path == 0 {
            File { handle: 0, mode: 0 }
        } E {
            handle := fopen(path, "r")
            I handle == 0 {
                File { handle: 0, mode: 0 }
            } E {
                File { handle: handle, mode: 1 }
            }
        }
    }

    # Open file for writing (creates/truncates)
    F open_write(path: i64) -> File {
        # Validate path is not null
        I path == 0 {
            File { handle: 0, mode: 0 }
        } E {
            handle := fopen(path, "w")
            I handle == 0 {
                File { handle: 0, mode: 0 }
            } E {
                File { handle: handle, mode: 2 }
            }
        }
    }

    # Open file for appending
    F open_append(path: i64) -> File {
        # Validate path is not null
        I path == 0 {
            File { handle: 0, mode: 0 }
        } E {
            handle := fopen(path, "a")
            I handle == 0 {
                File { handle: 0, mode: 0 }
            } E {
                File { handle: handle, mode: 3 }
            }
        }
    }

    # Check if file is open and valid
    F is_open(&self) -> i64 {
        I self.handle != 0 { 1 } E { 0 }
    }

    # Get file mode (0=closed, 1=read, 2=write, 3=append)
    F get_mode(&self) -> i64 {
        self.mode
    }

    # Read a single byte, returns -1 on EOF or error
    F read_byte(&self) -> i64 {
        I self.handle == 0 {
            0 - 1
        } E {
            fgetc(self.handle)
        }
    }

    # Read a single byte, returns Option<i64>
    # None on EOF or error, Some(byte) on success
    F read_byte_opt(&self) -> Option {
        I self.handle == 0 {
            None
        } E {
            byte := fgetc(self.handle)
            I byte < 0 {
                None
            } E {
                Some(byte)
            }
        }
    }

    # Read up to count bytes into buffer
    # Returns number of bytes actually read
    F read(&self, buffer: i64, count: i64) -> i64 {
        I self.handle == 0 {
            0
        } EI buffer == 0 {
            0
        } EI count <= 0 {
            0
        } E {
            fread(buffer, 1, count, self.handle)
        }
    }

    # Read a line into buffer (max_len includes null terminator)
    # Returns 1 on success, 0 on EOF/error
    F read_line(&self, buffer: i64, max_len: i64) -> i64 {
        I self.handle == 0 {
            0
        } EI buffer == 0 {
            0
        } EI max_len <= 0 {
            0
        } E {
            result := fgets(buffer, max_len, self.handle)
            I result == 0 {
                0
            } E {
                1
            }
        }
    }

    # Read a line into buffer using Result type
    # Returns Ok(buffer_ptr) on success, Err(ERR_IO) on failure
    F read_line_result(&self, buffer: i64, max_len: i64) -> Result<i64, i64> {
        I self.handle == 0 {
            Err(ERR_INVALID())
        } EI buffer == 0 {
            Err(ERR_INVALID())
        } EI max_len <= 0 {
            Err(ERR_INVALID())
        } E {
            result := fgets(buffer, max_len, self.handle)
            I result == 0 {
                Err(ERR_IO())
            } E {
                Ok(buffer)
            }
        }
    }

    # Write a single byte
    # Returns 1 on success, 0 on error
    F write_byte(&self, byte: i64) -> i64 {
        I self.handle == 0 {
            0
        } E {
            result := fputc(byte, self.handle)
            I result < 0 {
                0
            } E {
                1
            }
        }
    }

    # Write bytes from buffer
    # Returns number of bytes written
    F write(&self, buffer: i64, count: i64) -> i64 {
        I self.handle == 0 {
            0
        } EI buffer == 0 {
            0
        } EI count <= 0 {
            0
        } E {
            fwrite(buffer, 1, count, self.handle)
        }
    }

    # Write null-terminated string
    # Returns 1 on success, 0 on error
    F write_str(&self, str: i64) -> i64 {
        I self.handle == 0 {
            0
        } EI str == 0 {
            0
        } E {
            result := fputs(str, self.handle)
            I result < 0 {
                0
            } E {
                1
            }
        }
    }

    # Flush file buffer
    F flush(&self) -> i64 {
        I self.handle == 0 {
            0
        } E {
            fflush(self.handle)
            1
        }
    }

    # Sync file data and metadata to disk (fsync)
    # Returns 1 on success, 0 on error
    F sync(&self) -> i64 {
        I self.handle == 0 {
            0
        } E {
            fflush(self.handle)
            fd := fileno(self.handle)
            I fd < 0 {
                0
            } E {
                result := fsync(fd)
                I result == 0 { 1 } E { 0 }
            }
        }
    }

    # Sync file data only to disk (fdatasync, no metadata flush)
    # Returns 1 on success, 0 on error
    F datasync(&self) -> i64 {
        I self.handle == 0 {
            0
        } E {
            fflush(self.handle)
            fd := fileno(self.handle)
            I fd < 0 {
                0
            } E {
                result := fdatasync(fd)
                I result == 0 { 1 } E { 0 }
            }
        }
    }

    # Seek to position (origin: 0=start, 1=current, 2=end)
    # Returns 0 on success, -1 on error
    F seek(&self, offset: i64, origin: i64) -> i64 {
        I self.handle == 0 {
            0 - 1
        } EI origin < SEEK_SET | origin > SEEK_END {
            0 - 1
        } E {
            fseek(self.handle, offset, origin)
        }
    }

    # Get current position in file
    # Returns -1 on error
    F tell(&self) -> i64 {
        I self.handle == 0 {
            0 - 1
        } E {
            ftell(self.handle)
        }
    }

    # Check if at end of file
    F eof(&self) -> i64 {
        I self.handle == 0 {
            1
        } E {
            feof(self.handle)
        }
    }

    # Close the file
    F close(&self) -> i64 {
        I self.handle != 0 {
            fclose(self.handle)
            self.handle = 0
            self.mode = 0
        }
        0
    }

    # Alias for close (RAII pattern)
    F drop(&self) -> i64 {
        @.close()
    }
}

# Read entire file into buffer (allocates memory)
# Returns pointer to buffer (caller must free) or 0 on error
# Sets size_out to number of bytes read
F file_read_all(path: i64, size_out: i64) -> i64 {
    # Validate inputs
    I path == 0 {
        I size_out != 0 {
            store_i64(size_out, 0)
        }
        0
    } EI size_out == 0 {
        0
    } E {
        f := File.open_read(path)
        I f.handle == 0 {
            store_i64(size_out, 0)
            0
        } E {
            # Get file size
            f.seek(0, 2)  # Seek to end
            size := f.tell()
            f.seek(0, 0)  # Seek back to start

            I size <= 0 {
                f.close()
                store_i64(size_out, 0)
                0
            } E {
                # Allocate buffer (+1 for null terminator)
                buffer := malloc(size + 1)
                I buffer == 0 {
                    f.close()
                    store_i64(size_out, 0)
                    0
                } E {
                    bytes_read := f.read(buffer, size)
                    store_byte(buffer + bytes_read, 0)  # Null terminate
                    f.close()
                    store_i64(size_out, bytes_read)
                    buffer
                }
            }
        }
    }
}

# Read entire file into buffer using Result type
# Returns Ok(buffer_ptr) on success (caller must free), Err(error_code) on failure
# Sets size_out to number of bytes read on success
F file_read_all_result(path: i64, size_out: i64) -> Result<i64, i64> {
    # Validate inputs
    I path == 0 {
        I size_out != 0 {
            store_i64(size_out, 0)
        }
        Err(ERR_INVALID())
    } EI size_out == 0 {
        Err(ERR_INVALID())
    } E {
        f := File.open_read(path)
        I f.handle == 0 {
            store_i64(size_out, 0)
            Err(ERR_NOT_FOUND())
        } E {
            # Get file size
            f.seek(0, 2)  # Seek to end
            size := f.tell()
            f.seek(0, 0)  # Seek back to start

            I size <= 0 {
                f.close()
                store_i64(size_out, 0)
                Err(ERR_IO())
            } E {
                # Allocate buffer (+1 for null terminator)
                buffer := malloc(size + 1)
                I buffer == 0 {
                    f.close()
                    store_i64(size_out, 0)
                    Err(ERR_OVERFLOW())
                } E {
                    bytes_read := f.read(buffer, size)
                    store_byte(buffer + bytes_read, 0)  # Null terminate
                    f.close()
                    store_i64(size_out, bytes_read)
                    Ok(buffer)
                }
            }
        }
    }
}

# Write buffer to file (overwrites existing)
# Returns number of bytes written
F file_write_all(path: i64, buffer: i64, size: i64) -> i64 {
    # Validate inputs
    I path == 0 {
        0
    } EI buffer == 0 {
        0
    } EI size <= 0 {
        0
    } E {
        f := File.open_write(path)
        I f.handle == 0 {
            0
        } E {
            written := f.write(buffer, size)
            f.close()
            written
        }
    }
}

# Append buffer to file
# Returns number of bytes written
F file_append(path: i64, buffer: i64, size: i64) -> i64 {
    # Validate inputs
    I path == 0 {
        0
    } EI buffer == 0 {
        0
    } EI size <= 0 {
        0
    } E {
        f := File.open_append(path)
        I f.handle == 0 {
            0
        } E {
            written := f.write(buffer, size)
            f.close()
            written
        }
    }
}

# Check if file exists (try to open for reading)
F file_exists(path: i64) -> i64 {
    # Validate path is not null
    I path == 0 {
        0
    } E {
        f := File.open_read(path)
        I f.handle == 0 {
            0
        } E {
            f.close()
            1
        }
    }
}

# Sync file data+metadata to disk by path
# Opens, fsyncs, and closes. Returns 1 on success, 0 on error.
F file_sync(path: i64) -> i64 {
    I path == 0 {
        0
    } E {
        f := File.open_read(path)
        I f.handle == 0 {
            0
        } E {
            result := f.sync()
            f.close()
            result
        }
    }
}

# O_RDONLY constant for POSIX open
C O_RDONLY: i64 = 0

# Memory mapping constants
C PROT_NONE: i64 = 0
C PROT_READ: i64 = 1
C PROT_WRITE: i64 = 2
C PROT_EXEC: i64 = 4

C MAP_SHARED: i64 = 1
C MAP_PRIVATE: i64 = 2

# MAP_ANONYMOUS / MAP_ANON (platform-dependent)
#[cfg(target_os = "macos")]
C MAP_ANONYMOUS: i64 = 4096

#[cfg(target_os = "linux")]
C MAP_ANONYMOUS: i64 = 32

C MAP_FAILED: i64 = 0 - 1

# madvise advice constants
C MADV_NORMAL: i64 = 0
C MADV_RANDOM: i64 = 1
C MADV_SEQUENTIAL: i64 = 2
C MADV_WILLNEED: i64 = 3
C MADV_DONTNEED: i64 = 4

# msync flags (platform-dependent)
C MS_ASYNC: i64 = 1
C MS_INVALIDATE: i64 = 2

#[cfg(target_os = "macos")]
C MS_SYNC: i64 = 16

#[cfg(target_os = "linux")]
C MS_SYNC: i64 = 4

# Memory-mapped file handle
S MappedFile {
    addr: i64,
    len: i64
}

X MappedFile {
    # Map a file descriptor into memory with given protection and flags
    # Returns MappedFile with addr=0 on failure
    F map(fd: i64, len: i64, prot: i64, flags: i64, offset: i64) -> MappedFile {
        addr := mmap(0, len, prot, flags, fd, offset)
        I addr == MAP_FAILED {
            MappedFile { addr: 0, len: 0 }
        } E {
            MappedFile { addr: addr, len: len }
        }
    }

    # Map a file for reading (convenience)
    F map_read(fd: i64, len: i64) -> MappedFile {
        MappedFile.map(fd, len, PROT_READ, MAP_PRIVATE, 0)
    }

    # Map a file for read-write (shared, changes written back)
    F map_readwrite(fd: i64, len: i64) -> MappedFile {
        MappedFile.map(fd, len, PROT_READ + PROT_WRITE, MAP_SHARED, 0)
    }

    # Check if mapping is valid
    F is_valid(&self) -> i64 {
        I self.addr != 0 { 1 } E { 0 }
    }

    # Unmap the memory region. Returns 1 on success, 0 on error.
    F unmap(&self) -> i64 {
        I self.addr == 0 {
            0
        } E {
            result := munmap(self.addr, self.len)
            I result == 0 { 1 } E { 0 }
        }
    }

    # Sync mapped memory to disk. Returns 1 on success, 0 on error.
    F sync(&self) -> i64 {
        I self.addr == 0 {
            0
        } E {
            result := msync(self.addr, self.len, MS_SYNC)
            I result == 0 { 1 } E { 0 }
        }
    }

    # Async sync mapped memory to disk. Returns 1 on success, 0 on error.
    F sync_async(&self) -> i64 {
        I self.addr == 0 {
            0
        } E {
            result := msync(self.addr, self.len, MS_ASYNC)
            I result == 0 { 1 } E { 0 }
        }
    }

    # Advise kernel on expected access pattern. Returns 1 on success, 0 on error.
    F advise(&self, advice: i64) -> i64 {
        I self.addr == 0 {
            0
        } E {
            result := madvise(self.addr, self.len, advice)
            I result == 0 { 1 } E { 0 }
        }
    }

    # Read a byte at given offset within the mapping
    F read_byte(&self, offset: i64) -> i64 {
        I self.addr == 0 { 0 - 1 }
        E I offset < 0 { 0 - 1 }
        E I offset >= self.len { 0 - 1 }
        E {
            load_byte(self.addr + offset)
        }
    }

    # Write a byte at given offset within the mapping
    F write_byte(&self, offset: i64, val: i64) -> i64 {
        I self.addr == 0 { 0 }
        E I offset < 0 { 0 }
        E I offset >= self.len { 0 }
        E {
            store_byte(self.addr + offset, val)
            1
        }
    }
}

# flock operation constants
C LOCK_SH: i64 = 1   # Shared lock (read)
C LOCK_EX: i64 = 2   # Exclusive lock (write)
C LOCK_NB: i64 = 4   # Non-blocking (OR with SH/EX)
C LOCK_UN: i64 = 8   # Unlock

# Advisory file lock wrapper
S FileLock {
    fd: i64,
    locked: i64    # 0=unlocked, 1=shared, 2=exclusive
}

X FileLock {
    # Create a FileLock from a file descriptor
    F from_fd(fd: i64) -> FileLock {
        FileLock { fd: fd, locked: 0 }
    }

    # Create a FileLock by opening a path (O_RDWR=2)
    F open(path: i64) -> FileLock {
        I path == 0 {
            FileLock { fd: 0 - 1, locked: 0 }
        } E {
            fd := posix_open(path, 2, 0)
            FileLock { fd: fd, locked: 0 }
        }
    }

    # Check if the lock handle is valid
    F is_valid(&self) -> i64 {
        I self.fd >= 0 { 1 } E { 0 }
    }

    # Acquire a shared (read) lock, blocking
    # Returns 1 on success, 0 on error
    F lock_shared(&self) -> i64 {
        I self.fd < 0 { 0 }
        E {
            result := flock(self.fd, LOCK_SH)
            I result == 0 {
                self.locked = 1
                1
            } E { 0 }
        }
    }

    # Acquire an exclusive (write) lock, blocking
    # Returns 1 on success, 0 on error
    F lock_exclusive(&self) -> i64 {
        I self.fd < 0 { 0 }
        E {
            result := flock(self.fd, LOCK_EX)
            I result == 0 {
                self.locked = 2
                1
            } E { 0 }
        }
    }

    # Try to acquire a shared lock, non-blocking
    # Returns 1 on success, 0 if would block or error
    F try_lock_shared(&self) -> i64 {
        I self.fd < 0 { 0 }
        E {
            result := flock(self.fd, LOCK_SH + LOCK_NB)
            I result == 0 {
                self.locked = 1
                1
            } E { 0 }
        }
    }

    # Try to acquire an exclusive lock, non-blocking
    # Returns 1 on success, 0 if would block or error
    F try_lock_exclusive(&self) -> i64 {
        I self.fd < 0 { 0 }
        E {
            result := flock(self.fd, LOCK_EX + LOCK_NB)
            I result == 0 {
                self.locked = 2
                1
            } E { 0 }
        }
    }

    # Release the lock
    # Returns 1 on success, 0 on error
    F unlock(&self) -> i64 {
        I self.fd < 0 { 0 }
        E I self.locked == 0 { 1 }
        E {
            result := flock(self.fd, LOCK_UN)
            I result == 0 {
                self.locked = 0
                1
            } E { 0 }
        }
    }

    # Check if currently locked
    F is_locked(&self) -> i64 {
        I self.locked != 0 { 1 } E { 0 }
    }

    # Close the file descriptor and release lock
    F close(&self) -> i64 {
        I self.fd >= 0 {
            I self.locked != 0 {
                flock(self.fd, LOCK_UN)
                self.locked = 0
            }
            posix_close(self.fd)
            self.fd = 0 - 1
        }
        0
    }

    # Alias for close (RAII pattern)
    F drop(&self) -> i64 {
        @.close()
    }
}

# Sync directory metadata to disk (ensures rename/unlink durability)
# Opens dir as fd, fsyncs, closes. Returns 1 on success, 0 on error.
F dir_sync(path: i64) -> i64 {
    I path == 0 {
        0
    } E {
        fd := posix_open(path, O_RDONLY, 0)
        I fd < 0 {
            0
        } E {
            result := fsync(fd)
            posix_close(fd)
            I result == 0 { 1 } E { 0 }
        }
    }
}
