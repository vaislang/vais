# Vec - dynamic array (growable)
# Stores elements of type T with type-safe memory layout
# Uses sizeof(T) for element stride and load_typed/store_typed for memory access

U std/option

S Vec<T> {
    data: i64,      # Pointer to element array
    len: i64,       # Current number of elements
    cap: i64,       # Allocated capacity
    elem_size: i64  # Size of each element in bytes (sizeof(T))
}

X Vec<T> {
    # Create a new empty Vec with given capacity
    F with_capacity(capacity: i64) -> Vec<T> {
        es := type_size()  # Returns sizeof(T) â€” resolved at monomorphization
        # For backward compatibility: if sizeof returns 0 (e.g., Unit), default to 8
        elem_sz := I es <= 0 { 8 } E I es > 8 { 8 } E { es }
        data := malloc(capacity * elem_sz)
        Vec { data: data, len: 0, cap: capacity, elem_size: elem_sz }
    }

    # Get the number of elements
    F len(&self) -> i64 {
        self.len
    }

    # Get the capacity
    F capacity(&self) -> i64 {
        self.cap
    }

    # Check if empty
    F is_empty(&self) -> i64 {
        I self.len == 0 { 1 } E { 0 }
    }

    # Get element at index
    F get(&self, index: i64) -> T {
        I index < 0 {
            0
        } E I index >= self.len {
            0
        } E {
            ptr := self.data + index * self.elem_size
            load_typed(ptr)
        }
    }

    # Get element at index using Option type
    # Returns Some(value) if index is valid, None otherwise
    F get_opt(&self, index: i64) -> Option<T> {
        I index < 0 {
            None
        } E I index >= self.len {
            None
        } E {
            ptr := self.data + index * self.elem_size
            Some(load_typed(ptr))
        }
    }

    # Set element at index
    F set(&self, index: i64, value: T) -> i64 {
        I index >= 0 && index < self.len {
            ptr := self.data + index * self.elem_size
            store_typed(ptr, value)
            1
        } E {
            0
        }
    }

    # Push element to end
    F push(&self, value: T) -> i64 {
        I self.len >= self.cap {
            @.grow()
        }
        ptr := self.data + self.len * self.elem_size
        store_typed(ptr, value)
        self.len = self.len + 1
        self.len
    }

    # Pop element from end
    F pop(&self) -> T {
        I self.len > 0 {
            self.len = self.len - 1
            ptr := self.data + self.len * self.elem_size
            load_typed(ptr)
        } E {
            0
        }
    }

    # Pop element from end using Option type
    # Returns Some(value) if vec is not empty, None otherwise
    F pop_opt(&self) -> Option<T> {
        I self.len > 0 {
            self.len = self.len - 1
            ptr := self.data + self.len * self.elem_size
            Some(load_typed(ptr))
        } E {
            None
        }
    }

    # Grow capacity (double it)
    F grow(&self) -> i64 {
        doubled := self.cap * 2
        new_cap := I doubled < 8 { 8 } E { doubled }
        new_data := malloc(new_cap * self.elem_size)
        memcpy(new_data, self.data, self.len * self.elem_size)
        free(self.data)
        self.data = new_data
        self.cap = new_cap
        new_cap
    }

    # Clear all elements
    F clear(&self) -> i64 {
        self.len = 0
        0
    }

    # Free memory
    F drop(&self) -> i64 {
        free(self.data)
        self.data = 0
        self.len = 0
        self.cap = 0
        0
    }

    # ===== Higher-Order Functions =====

    # Apply f to each element and return a new Vec with the results
    F map(&self, f: fn(T) -> T) -> Vec<T> {
        result := Vec.with_capacity(self.len)
        i := mut 0
        L {
            I i >= self.len { B }
            elem := load_typed(self.data + i * self.elem_size)
            result.push(f(elem))
            i = i + 1
        }
        result
    }

    # Return a new Vec containing only elements where pred returns non-zero
    F filter(&self, pred: fn(T) -> i64) -> Vec<T> {
        result := Vec.with_capacity(self.len)
        i := mut 0
        L {
            I i >= self.len { B }
            elem := load_typed(self.data + i * self.elem_size)
            I pred(elem) != 0 {
                result.push(elem)
            }
            i = i + 1
        }
        result
    }

    # Reduce elements to a single value starting from init
    F fold(&self, init: T, f: fn(T, T) -> T) -> T {
        acc := mut init
        i := mut 0
        L {
            I i >= self.len { B }
            elem := load_typed(self.data + i * self.elem_size)
            acc = f(acc, elem)
            i = i + 1
        }
        acc
    }

    # Apply f to each element for side effects
    F for_each(&self, f: fn(T) -> i64) -> i64 {
        i := mut 0
        L {
            I i >= self.len { B }
            elem := load_typed(self.data + i * self.elem_size)
            f(elem)
            i = i + 1
        }
        0
    }

    # Check if any element satisfies pred
    F any(&self, pred: fn(T) -> i64) -> i64 {
        i := mut 0
        L {
            I i >= self.len { B }
            elem := load_typed(self.data + i * self.elem_size)
            I pred(elem) != 0 { R 1 }
            i = i + 1
        }
        0
    }

    # Check if all elements satisfy pred
    F all(&self, pred: fn(T) -> i64) -> i64 {
        i := mut 0
        L {
            I i >= self.len { B }
            elem := load_typed(self.data + i * self.elem_size)
            I pred(elem) == 0 { R 0 }
            i = i + 1
        }
        1
    }

    # Find first element satisfying pred, return it or -1 if not found
    F find(&self, pred: fn(T) -> i64) -> T {
        i := mut 0
        L {
            I i >= self.len { B }
            elem := load_typed(self.data + i * self.elem_size)
            I pred(elem) != 0 { R elem }
            i = i + 1
        }
        0 - 1
    }
}

# Create new Vec<i64> with initial capacity of 8 (backward compatibility)
F vec_new() -> Vec<i64> {
    Vec.with_capacity(8)
}
