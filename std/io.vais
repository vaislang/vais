# IO library - input/output operations
# Provides functions for reading from stdin
# Updated to use Option<T> and Result<T, E> for error handling
#
# SAFETY: This module uses builtin functions (malloc, free, load_byte, store_byte, puts_ptr, strlen, memcpy)
# that are provided by the compiler. String type requires importing std/string.vais separately.
#
# All input functions validate their buffer parameters and enforce size limits
# to prevent buffer overflow and memory corruption. Callers must ensure:
# - Buffers passed to read_line/prompt_line are pre-allocated with at least max_len bytes
# - max_len values are positive and within reasonable bounds (1..=1048576)

U std/option
# U std/string  # Temporarily disabled due to String type issues

# Buffer size for input operations
C INPUT_BUFFER_SIZE: i64 = 1024

# Extern C functions for input

# Extern C functions for input
# Note: We use _ptr suffix variants that accept i64 (raw pointers)
# to avoid type conflicts with builtin str-typed versions

# Get stdin handle
X F get_stdin() -> i64

# fgets with pointer params (maps to C fgets)
X F fgets_ptr(buffer: i64, size: i64, stream: i64) -> i64

# atol with pointer param (maps to C atol)
X F atol_ptr(s: i64) -> i64

# atof with pointer param (maps to C atof)
X F atof_ptr(s: i64) -> f64

# Read a line from stdin into a buffer
# Returns pointer to buffer on success, 0 on EOF/error
# buffer: destination buffer (must be pre-allocated)
# max_len: maximum length including null terminator (must be 1..=1048576)
# SAFETY: Caller must ensure buffer has at least max_len bytes allocated
F read_line(buffer: i64, max_len: i64) -> i64 {
    # Validate max_len range to prevent buffer overflow
    I max_len <= 0 {
        0
    }
    I max_len > 1048576 {
        max_len = 1048576
    }
    stdin := get_stdin()
    result := fgets_ptr(buffer, max_len, stdin)
    I result == 0 {
        0
    } E {
        # Remove trailing newline if present
        i := 0
        L i < max_len {
            c := load_byte(buffer + i)
            I c == 0 {
                B buffer
            }
            I c == 10 {  # newline character '\n'
                store_byte(buffer + i, 0)
                B buffer
            }
            i = i + 1
        }
        buffer
    }
}

# Read a line from stdin using Option type
# TEMPORARILY DISABLED due to loop variable issues
# Returns Some(buffer_ptr) on success, None on EOF/error
# SAFETY: Caller must ensure buffer has at least max_len bytes allocated
# F read_line_opt(buffer: i64, max_len: i64) -> Option<i64> {
#     # Validate max_len range
#     I max_len <= 0 {
#         None
#     }
#     I max_len > 1048576 {
#         max_len = 1048576
#     }
#     stdin := get_stdin()
#     result := fgets_ptr(buffer, max_len, stdin)
#     I result == 0 {
#         None
#     } E {
#         # Remove trailing newline if present
#         i := 0
#         L i < max_len {
#             c := load_byte(buffer + i)
#             I c == 0 {
#                 B Some(buffer)
#             }
#             I c == 10 {  # newline character '\n'
#                 store_byte(buffer + i, 0)
#                 B Some(buffer)
#             }
#             i = i + 1
#         }
#         Some(buffer)
#     }
# }

# Read a line from stdin and return as String
# TEMPORARILY DISABLED due to String type issues
# max_len: maximum length to read (default 1024, max 1048576)
# SAFETY: Allocates a temporary buffer of max_len bytes internally
# F read_line_string(max_len: i64) -> String {
#     I max_len <= 0 {
#         max_len = INPUT_BUFFER_SIZE
#     }
#     I max_len > 1048576 {
#         max_len = 1048576
#     }
#
#     # Allocate temporary buffer
#     buffer := malloc(max_len)
#     result := read_line(buffer, max_len)
#
#     I result == 0 {
#         free(buffer)
#         String.with_capacity(0)
#     } E {
#         # Convert to String
#         len := strlen(buffer)
#         s := String.with_capacity(len + 1)
#         memcpy(s.data, buffer, len)
#         s.len = len
#         store_byte(s.data + len, 0)
#         free(buffer)
#         s
#     }
# }

# Read an i64 integer from stdin
# Returns the integer value, or 0 if invalid input
F read_i64() -> i64 {
    buffer := malloc(64)
    result := read_line(buffer, 64)

    I result == 0 {
        free(buffer)
        0
    } E {
        value := atol_ptr(buffer)
        free(buffer)
        value
    }
}

# Read an i64 integer using Result type
# TEMPORARILY DISABLED - Result/Ok/Err types not fully supported in codegen
# F read_i64_result() -> Result {
#     buffer := malloc(64)
#     result := read_line(buffer, 64)
#     I result == 0 {
#         free(buffer)
#         Err(ERR_IO())
#     } E {
#         value := atol_ptr(buffer)
#         free(buffer)
#         Ok(value)
#     }
# }

# Read a f64 floating-point number from stdin
# Returns the float value, or 0.0 if invalid input
F read_f64() -> f64 {
    buffer := malloc(64)
    result := read_line(buffer, 64)

    I result == 0 {
        free(buffer)
        0.0
    } E {
        value := atof_ptr(buffer)
        free(buffer)
        value
    }
}

# Read a word (space-delimited) from stdin
# TEMPORARILY DISABLED - string literal type issue
# Returns pointer to allocated string (caller must free)
# Returns 0 on EOF/error
# F read_word() -> i64 {
#     buffer := malloc(INPUT_BUFFER_SIZE)
#     stdin := get_stdin()
#
#     # Use scanf to read one word
#     count := scanf("%s", buffer)
#
#     I count == 1 {
#         # Success - return the buffer
#         buffer
#     } E {
#         # Failed
#         free(buffer)
#         0
#     }
# }

# Read a word using Option type
# TEMPORARILY DISABLED
# Returns Some(buffer_ptr) on success (caller must free), None on EOF/error
# F read_word_opt() -> Option<i64> {
#     buffer := malloc(INPUT_BUFFER_SIZE)
#     stdin := get_stdin()
#
#     # Use scanf to read one word
#     format := "%s"
#     count := scanf(format, buffer)
#
#     I count == 1 {
#         # Success - return the buffer
#         Some(buffer)
#     } E {
#         # Failed
#         free(buffer)
#         None
#     }
# }

# Read a single character from stdin
# Returns the character as i64, or -1 on EOF
X F getchar() -> i64

# Read a character from stdin (wrapper)
F read_char() -> i64 {
    getchar()
}

# Print a prompt and read a line
# prompt: null-terminated string to display
# buffer: destination buffer
# max_len: maximum length
# Returns pointer to buffer on success, 0 on error
F prompt_line(prompt: i64, buffer: i64, max_len: i64) -> i64 {
    puts_ptr(prompt)
    read_line(buffer, max_len)
}

# Print a prompt and read an i64
# prompt: null-terminated string to display
# Returns the integer value
F prompt_i64(prompt: i64) -> i64 {
    puts_ptr(prompt)
    read_i64()
}

# Print a prompt and read a f64
# prompt: null-terminated string to display
# Returns the float value
F prompt_f64(prompt: i64) -> f64 {
    puts_ptr(prompt)
    read_f64()
}
