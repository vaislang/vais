# IO library - input/output operations
# Provides functions for reading from stdin
#
# Note: This module uses builtin functions (malloc, free, load_byte, store_byte, puts_ptr, strlen, memcpy)
# that are provided by the compiler. String type requires importing std/string.vais separately.

# Buffer size for input operations
C INPUT_BUFFER_SIZE: i64 = 1024

# Extern C functions for input

# Read formatted input (scanf)
# format: format string, ...: variable arguments
X F scanf(format: i64, ...) -> i64

# Read string from stdin (fgets)
# buffer: destination buffer
# size: maximum characters to read
# stream: FILE* (use stdin)
X F fgets(buffer: i64, size: i64, stream: i64) -> i64

# Get stdin handle
X F get_stdin() -> i64

# String to integer conversion
X F atoi(str: i64) -> i64

# String to long integer conversion
X F atol(str: i64) -> i64

# String to double conversion
X F atof(str: i64) -> f64

# Read a line from stdin into a buffer
# Returns pointer to buffer on success, 0 on EOF/error
# buffer: destination buffer (must be pre-allocated)
# max_len: maximum length including null terminator
F read_line(buffer: i64, max_len: i64) -> i64 {
    stdin := get_stdin()
    result := fgets(buffer, max_len, stdin)
    I result == 0 {
        0
    } E {
        # Remove trailing newline if present
        i := 0
        L i < max_len {
            c := load_byte(buffer + i)
            I c == 0 {
                B buffer
            }
            I c == 10 {  # newline character '\n'
                store_byte(buffer + i, 0)
                B buffer
            }
            i = i + 1
        }
        buffer
    }
}

# Read a line from stdin and return as String
# max_len: maximum length to read (default 1024)
F read_line_string(max_len: i64) -> String {
    I max_len <= 0 {
        max_len = INPUT_BUFFER_SIZE
    }

    # Allocate temporary buffer
    buffer := malloc(max_len)
    result := read_line(buffer, max_len)

    I result == 0 {
        free(buffer)
        String.with_capacity(0)
    } E {
        # Convert to String
        len := strlen(buffer)
        s := String.with_capacity(len + 1)
        memcpy(s.data, buffer, len)
        s.len = len
        store_byte(s.data + len, 0)
        free(buffer)
        s
    }
}

# Read an i64 integer from stdin
# Returns the integer value, or 0 if invalid input
F read_i64() -> i64 {
    buffer := malloc(64)
    result := read_line(buffer, 64)

    I result == 0 {
        free(buffer)
        0
    } E {
        value := atol(buffer)
        free(buffer)
        value
    }
}

# Read a f64 floating-point number from stdin
# Returns the float value, or 0.0 if invalid input
F read_f64() -> f64 {
    buffer := malloc(64)
    result := read_line(buffer, 64)

    I result == 0 {
        free(buffer)
        0.0
    } E {
        value := atof(buffer)
        free(buffer)
        value
    }
}

# Read a word (space-delimited) from stdin
# Returns pointer to allocated string (caller must free)
# Returns 0 on EOF/error
F read_word() -> i64 {
    buffer := malloc(INPUT_BUFFER_SIZE)
    stdin := get_stdin()

    # Use scanf to read one word
    format := "%s"
    count := scanf(format, buffer)

    I count == 1 {
        # Success - return the buffer
        buffer
    } E {
        # Failed
        free(buffer)
        0
    }
}

# Read a single character from stdin
# Returns the character as i64, or -1 on EOF
X F getchar() -> i64

# Read a character from stdin (wrapper)
F read_char() -> i64 {
    getchar()
}

# Print a prompt and read a line
# prompt: null-terminated string to display
# buffer: destination buffer
# max_len: maximum length
# Returns pointer to buffer on success, 0 on error
F prompt_line(prompt: i64, buffer: i64, max_len: i64) -> i64 {
    puts_ptr(prompt)
    read_line(buffer, max_len)
}

# Print a prompt and read an i64
# prompt: null-terminated string to display
# Returns the integer value
F prompt_i64(prompt: i64) -> i64 {
    puts_ptr(prompt)
    read_i64()
}

# Print a prompt and read a f64
# prompt: null-terminated string to display
# Returns the float value
F prompt_f64(prompt: i64) -> f64 {
    puts_ptr(prompt)
    read_f64()
}
