# Arena Allocator - Fast batch memory allocation
# Allocates memory in chunks, frees all at once
# Useful for temporary allocations with same lifetime

# Arena - region-based memory allocator
S Arena {
    chunks: i64,        # Pointer to list of chunk pointers
    chunk_count: i64,   # Number of chunks
    chunk_size: i64,    # Size of each chunk
    current: i64,       # Current chunk pointer
    offset: i64         # Current offset in chunk
}

# Default chunk size (64KB)
F ARENA_DEFAULT_CHUNK_SIZE() -> i64 { 65536 }

X Arena {
    # Create new arena with default chunk size
    F new() -> Arena {
        Arena.with_chunk_size(ARENA_DEFAULT_CHUNK_SIZE())
    }

    # Create arena with custom chunk size
    F with_chunk_size(size: i64) -> Arena {
        # Allocate initial chunk list (capacity for 16 chunks)
        chunks := malloc(128)  # 16 * 8 bytes for pointers

        # Allocate first chunk
        first_chunk := malloc(size)
        store_i64(chunks, first_chunk)

        Arena {
            chunks: chunks,
            chunk_count: 1,
            chunk_size: size,
            current: first_chunk,
            offset: 0
        }
    }

    # Allocate memory from arena (8-byte aligned)
    F alloc(&self, size: i64) -> i64 {
        # Align size to 8 bytes
        aligned_size := (size + 7) / 8 * 8

        # Check if current chunk has enough space
        remaining := self.chunk_size - self.offset
        I remaining < aligned_size {
            # Need new chunk
            @.grow()
        }

        # Allocate from current position
        ptr := self.current + self.offset
        self.offset = self.offset + aligned_size
        ptr
    }

    # Allocate and zero-initialize
    F alloc_zeroed(&self, size: i64) -> i64 {
        ptr := @.alloc(size)
        # Zero out the memory
        i := 0
        L {
            I i >= size { B 0 }
            store_byte(ptr + i, 0)
            i = i + 1
        }
        ptr
    }

    # Allocate space for n items of given size
    F alloc_array(&self, count: i64, item_size: i64) -> i64 {
        @.alloc(count * item_size)
    }

    # Add a new chunk
    F grow(&self) -> i64 {
        # Allocate new chunk
        new_chunk := malloc(self.chunk_size)

        # Store in chunks list
        chunk_ptr := self.chunks + self.chunk_count * 8
        store_i64(chunk_ptr, new_chunk)

        self.chunk_count = self.chunk_count + 1
        self.current = new_chunk
        self.offset = 0

        self.chunk_count
    }

    # Reset arena (keep chunks but reset offset)
    F reset(&self) -> i64 {
        self.current = load_i64(self.chunks)
        self.offset = 0
        0
    }

    # Get total allocated size
    F total_allocated(&self) -> i64 {
        # Full chunks + current offset
        full_chunks := self.chunk_count - 1
        full_chunks * self.chunk_size + self.offset
    }

    # Get total capacity
    F total_capacity(&self) -> i64 {
        self.chunk_count * self.chunk_size
    }

    # Free all memory
    F drop(&self) -> i64 {
        # Free all chunks
        i := 0
        L {
            I i >= self.chunk_count { B 0 }
            chunk_ptr := self.chunks + i * 8
            chunk := load_i64(chunk_ptr)
            free(chunk)
            i = i + 1
        }
        # Free chunk list
        free(self.chunks)

        self.chunks = 0
        self.chunk_count = 0
        self.current = 0
        self.offset = 0
        0
    }
}

# Convenience functions
F arena_new() -> Arena {
    Arena.new()
}

F arena_alloc(arena: Arena, size: i64) -> i64 {
    arena.alloc(size)
}

F arena_reset(arena: Arena) -> i64 {
    arena.reset()
}

F arena_drop(arena: Arena) -> i64 {
    arena.drop()
}
