# Iterator - iterator pattern for sequential access
# Based on Rust's Iterator trait pattern
#
# Note: This module defines iterator patterns for VAIS.
# Due to current compiler limitations:
# - Static methods (Type.method()) are not yet supported
# - Use helper functions instead (e.g., range() instead of Range.new())
# - Struct returns from functions have limited support

# Iterator trait - defines the interface for iterating
# next() returns -1 when exhausted, otherwise returns the value
# This simplification avoids enum overhead in hot paths
W Iterator {
    F next(&self) -> i64
}

# ===== Range Iterator =====
# Iterates from start to end (exclusive)

S Range {
    current: i64,
    end: i64,
    step: i64
}

X Range {
    # Check if range has more elements
    F has_next(&self) -> i64 {
        I self.step > 0 {
            I self.current < self.end { 1 } E { 0 }
        } E {
            I self.current > self.end { 1 } E { 0 }
        }
    }
}

# Implement Iterator for Range
X Range: Iterator {
    F next(&self) -> i64 {
        I self.current < self.end {
            value := self.current
            self.current = self.current + self.step
            value
        } E {
            0 - 1  # Return -1 to signal end
        }
    }
}

# ===== VecIter - iterates over Vec elements =====

S VecIter {
    data: i64,      # Pointer to Vec's data array
    len: i64,       # Length of Vec
    index: i64      # Current position
}

X VecIter {
    # Check if has more elements
    F has_next(&self) -> i64 {
        I self.index < self.len { 1 } E { 0 }
    }

    # Peek at current element without advancing
    F peek(&self) -> i64 {
        I self.index < self.len {
            load_i64(self.data + self.index * 8)
        } E {
            0 - 1
        }
    }
}

# Implement Iterator for VecIter
X VecIter: Iterator {
    F next(&self) -> i64 {
        I self.index < self.len {
            value := load_i64(self.data + self.index * 8)
            self.index = self.index + 1
            value
        } E {
            0 - 1
        }
    }
}

# ===== SliceIter - iterates over memory slice =====

S SliceIter {
    ptr: i64,       # Current pointer
    end: i64,       # End pointer (exclusive)
    elem_size: i64  # Size of each element (8 for i64)
}

X SliceIter {
    F has_next(&self) -> i64 {
        I self.ptr < self.end { 1 } E { 0 }
    }
}

X SliceIter: Iterator {
    F next(&self) -> i64 {
        I self.ptr < self.end {
            value := load_i64(self.ptr)
            self.ptr = self.ptr + self.elem_size
            value
        } E {
            0 - 1
        }
    }
}

# ===== Iterator Adapter Functions =====
# Free-function-based adapters that work with arrays stored as (ptr, len) pairs.
# All use the convention: -1 = exhausted sentinel.

# ===== Consuming Functions (Array-based) =====
# These operate on arrays stored as ptr + len pairs.

# Sum all elements in an array
F iter_sum(data: i64, len: i64) -> i64 {
    acc := mut 0
    i := mut 0
    L {
        I i >= len { B }
        acc = acc + load_i64(data + i * 8)
        i = i + 1
    }
    acc
}

# Product of all elements in an array
F iter_product(data: i64, len: i64) -> i64 {
    acc := mut 1
    i := mut 0
    L {
        I i >= len { B }
        acc = acc * load_i64(data + i * 8)
        i = i + 1
    }
    acc
}

# Count elements in an array
F iter_count(data: i64, len: i64) -> i64 {
    len
}

# Find min element in an array (returns 0 if empty)
F iter_min(data: i64, len: i64) -> i64 {
    I len == 0 { R 0 }
    min_val := mut load_i64(data)
    i := mut 1
    L {
        I i >= len { B }
        v := load_i64(data + i * 8)
        I v < min_val { min_val = v }
        i = i + 1
    }
    min_val
}

# Find max element in an array (returns 0 if empty)
F iter_max(data: i64, len: i64) -> i64 {
    I len == 0 { R 0 }
    max_val := mut load_i64(data)
    i := mut 1
    L {
        I i >= len { B }
        v := load_i64(data + i * 8)
        I v > max_val { max_val = v }
        i = i + 1
    }
    max_val
}

# Check if any element equals value
F iter_contains(data: i64, len: i64, value: i64) -> i64 {
    i := mut 0
    L {
        I i >= len { B }
        I load_i64(data + i * 8) == value { R 1 }
        i = i + 1
    }
    0
}

# ===== Adapter Functions =====
# These create new arrays (allocate via malloc) and return (ptr, len) via out params.

# Map: apply f to each element, return new array pointer (caller sets len = input len)
F iter_map(data: i64, len: i64, f: fn(i64) -> i64) -> i64 {
    out := malloc(len * 8)
    i := mut 0
    L {
        I i >= len { B }
        store_i64(out + i * 8, f(load_i64(data + i * 8)))
        i = i + 1
    }
    out
}

# Filter: return new array pointer; actual count stored at out_count_ptr
F iter_filter(data: i64, len: i64, pred: fn(i64) -> i64, out_count_ptr: i64) -> i64 {
    out := malloc(len * 8)
    j := mut 0
    i := mut 0
    L {
        I i >= len { B }
        v := load_i64(data + i * 8)
        I pred(v) != 0 {
            store_i64(out + j * 8, v)
            j = j + 1
        }
        i = i + 1
    }
    store_i64(out_count_ptr, j)
    out
}

# Take: return new array with first n elements (or fewer if len < n)
F iter_take(data: i64, len: i64, n: i64) -> i64 {
    count := I n < len { n } E { len }
    out := malloc(count * 8)
    i := mut 0
    L {
        I i >= count { B }
        store_i64(out + i * 8, load_i64(data + i * 8))
        i = i + 1
    }
    out
}

# Skip: return new array skipping first n elements
F iter_skip(data: i64, len: i64, n: i64) -> i64 {
    start := I n < len { n } E { len }
    new_len := len - start
    out := malloc(new_len * 8)
    i := mut 0
    L {
        I i >= new_len { B }
        store_i64(out + i * 8, load_i64(data + (start + i) * 8))
        i = i + 1
    }
    out
}

# Chain: concatenate two arrays, return new array pointer
# Total length = len1 + len2
F iter_chain(data1: i64, len1: i64, data2: i64, len2: i64) -> i64 {
    total := len1 + len2
    out := malloc(total * 8)
    i := mut 0
    L {
        I i >= len1 { B }
        store_i64(out + i * 8, load_i64(data1 + i * 8))
        i = i + 1
    }
    j := mut 0
    L {
        I j >= len2 { B }
        store_i64(out + (len1 + j) * 8, load_i64(data2 + j * 8))
        j = j + 1
    }
    out
}

# Zip: pair elements from two arrays as (a, b) stored as consecutive i64 pairs
# Returns pointer to 2*min(len1,len2) elements [a0,b0,a1,b1,...]
F iter_zip(data1: i64, len1: i64, data2: i64, len2: i64) -> i64 {
    min_len := I len1 < len2 { len1 } E { len2 }
    out := malloc(min_len * 16)
    i := mut 0
    L {
        I i >= min_len { B }
        store_i64(out + i * 16, load_i64(data1 + i * 8))
        store_i64(out + i * 16 + 8, load_i64(data2 + i * 8))
        i = i + 1
    }
    out
}

# Enumerate: pair each element with its index as (index, value)
# Returns pointer to 2*len elements [0,v0,1,v1,...]
F iter_enumerate(data: i64, len: i64) -> i64 {
    out := malloc(len * 16)
    i := mut 0
    L {
        I i >= len { B }
        store_i64(out + i * 16, i)
        store_i64(out + i * 16 + 8, load_i64(data + i * 8))
        i = i + 1
    }
    out
}

# Fold: reduce array to single value
F iter_fold(data: i64, len: i64, init: i64, f: fn(i64, i64) -> i64) -> i64 {
    acc := mut init
    i := mut 0
    L {
        I i >= len { B }
        acc = f(acc, load_i64(data + i * 8))
        i = i + 1
    }
    acc
}

# Any: check if any element satisfies predicate
F iter_any(data: i64, len: i64, pred: fn(i64) -> i64) -> i64 {
    i := mut 0
    L {
        I i >= len { B }
        I pred(load_i64(data + i * 8)) != 0 { R 1 }
        i = i + 1
    }
    0
}

# All: check if all elements satisfy predicate
F iter_all(data: i64, len: i64, pred: fn(i64) -> i64) -> i64 {
    i := mut 0
    L {
        I i >= len { B }
        I pred(load_i64(data + i * 8)) == 0 { R 0 }
        i = i + 1
    }
    1
}

# Find: return first element satisfying predicate (or -1 if not found)
F iter_find(data: i64, len: i64, pred: fn(i64) -> i64) -> i64 {
    i := mut 0
    L {
        I i >= len { B }
        v := load_i64(data + i * 8)
        I pred(v) != 0 { R v }
        i = i + 1
    }
    0 - 1
}

# Position: return index of first element satisfying predicate (or -1)
F iter_position(data: i64, len: i64, pred: fn(i64) -> i64) -> i64 {
    i := mut 0
    L {
        I i >= len { B }
        I pred(load_i64(data + i * 8)) != 0 { R i }
        i = i + 1
    }
    0 - 1
}

# ===== Usage Examples =====
#
# Range-based for loop:
#   L i:0..10 { print(i) }
#
# Manual iterator loop with Range struct:
#   r := Range { current: 0, end: 10, step: 1 }
#   L {
#       v := r.next()
#       I v < 0 { B }
#       # process v
#   }
#
# Adapter chaining (array-based):
#   data := iter_map(arr, len, |x: i64| x * 2)
#   sum := iter_sum(data, len)
#
# Zip two arrays:
#   paired := iter_zip(a_ptr, a_len, b_ptr, b_len)
#   # paired[i*2] = a[i], paired[i*2+1] = b[i]
