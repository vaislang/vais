# ByteBuffer - Growable byte buffer for binary serialization/deserialization
# Essential for database page management, WAL records, and network protocols

S ByteBuffer {
    data: i64,      # Pointer to heap-allocated buffer
    len: i64,       # Current write position / bytes written
    cap: i64,       # Allocated capacity
    pos: i64        # Current read position
}

X ByteBuffer {
    # Create with given capacity
    F with_capacity(capacity: i64) -> ByteBuffer {
        cap := I capacity < 16 { 16 } E { capacity }
        data := malloc(cap)
        ByteBuffer { data: data, len: 0, cap: cap, pos: 0 }
    }

    # Getters
    F len(&self) -> i64 = self.len
    F capacity(&self) -> i64 = self.cap
    F position(&self) -> i64 = self.pos
    F data_ptr(&self) -> i64 = self.data
    F remaining(&self) -> i64 { self.len - self.pos }

    # Seek to position
    F seek(&self, pos: i64) -> i64 {
        self.pos = pos
        pos
    }

    # Reset for re-reading
    F rewind(&self) -> i64 {
        self.pos = 0
        0
    }

    # Ensure capacity
    F ensure_capacity(&self, needed: i64) -> i64 {
        I needed <= self.cap { R self.cap }
        new_cap := self.cap
        L {
            I new_cap >= needed { B 0 }
            new_cap = new_cap * 2
        }
        new_data := malloc(new_cap)
        memcpy(new_data, self.data, self.len)
        free(self.data)
        self.data = new_data
        self.cap = new_cap
        new_cap
    }

    # Write a single byte
    F write_u8(&self, value: i64) -> i64 {
        @.ensure_capacity(self.len + 1)
        store_byte(self.data + self.len, value & 255)
        self.len = self.len + 1
        1
    }

    # Read a single byte
    F read_u8(&self) -> i64 {
        I self.pos >= self.len { R 0 - 1 }
        val := load_byte(self.data + self.pos)
        self.pos = self.pos + 1
        val
    }

    # Write i32 in little-endian (4 bytes)
    F write_i32_le(&self, value: i64) -> i64 {
        @.ensure_capacity(self.len + 4)
        store_byte(self.data + self.len, value & 255)
        store_byte(self.data + self.len + 1, (value >> 8) & 255)
        store_byte(self.data + self.len + 2, (value >> 16) & 255)
        store_byte(self.data + self.len + 3, (value >> 24) & 255)
        self.len = self.len + 4
        4
    }

    # Read i32 little-endian
    F read_i32_le(&self) -> i64 {
        I self.pos + 4 > self.len { R 0 - 1 }
        b0 := load_byte(self.data + self.pos)
        b1 := load_byte(self.data + self.pos + 1)
        b2 := load_byte(self.data + self.pos + 2)
        b3 := load_byte(self.data + self.pos + 3)
        self.pos = self.pos + 4
        b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    }

    # Write i64 in little-endian (8 bytes)
    F write_i64_le(&self, value: i64) -> i64 {
        @.ensure_capacity(self.len + 8)
        store_byte(self.data + self.len, value & 255)
        store_byte(self.data + self.len + 1, (value >> 8) & 255)
        store_byte(self.data + self.len + 2, (value >> 16) & 255)
        store_byte(self.data + self.len + 3, (value >> 24) & 255)
        store_byte(self.data + self.len + 4, (value >> 32) & 255)
        store_byte(self.data + self.len + 5, (value >> 40) & 255)
        store_byte(self.data + self.len + 6, (value >> 48) & 255)
        store_byte(self.data + self.len + 7, (value >> 56) & 255)
        self.len = self.len + 8
        8
    }

    # Read i64 little-endian
    F read_i64_le(&self) -> i64 {
        I self.pos + 8 > self.len { R 0 - 1 }
        b0 := load_byte(self.data + self.pos)
        b1 := load_byte(self.data + self.pos + 1)
        b2 := load_byte(self.data + self.pos + 2)
        b3 := load_byte(self.data + self.pos + 3)
        b4 := load_byte(self.data + self.pos + 4)
        b5 := load_byte(self.data + self.pos + 5)
        b6 := load_byte(self.data + self.pos + 6)
        b7 := load_byte(self.data + self.pos + 7)
        self.pos = self.pos + 8
        b0 | (b1 << 8) | (b2 << 16) | (b3 << 24) | (b4 << 32) | (b5 << 40) | (b6 << 48) | (b7 << 56)
    }

    # Write raw bytes from pointer
    F write_bytes(&self, src: i64, count: i64) -> i64 {
        @.ensure_capacity(self.len + count)
        memcpy(self.data + self.len, src, count)
        self.len = self.len + count
        count
    }

    # Read raw bytes into destination pointer
    F read_bytes(&self, dst: i64, count: i64) -> i64 {
        I self.pos + count > self.len { R 0 - 1 }
        memcpy(dst, self.data + self.pos, count)
        self.pos = self.pos + count
        count
    }

    # Write a null-terminated string (length-prefixed: i32 len + bytes)
    F write_str(&self, s: str) -> i64 {
        p := str_to_ptr(s)
        # Calculate string length manually to avoid use-after-move
        slen := mut 0
        L {
            b := load_byte(p + slen)
            I b == 0 { B }
            slen = slen + 1
        }
        @.write_i32_le(slen)
        @.ensure_capacity(self.len + slen)
        memcpy(self.data + self.len, p, slen)
        self.len = self.len + slen
        slen + 4
    }

    # Clear buffer
    F clear(&self) -> i64 {
        self.len = 0
        self.pos = 0
        0
    }

    # Write unsigned varint (LEB128 encoding)
    # Each byte stores 7 bits of data + 1 continuation bit (MSB)
    # Returns number of bytes written
    F write_varint(&self, value: i64) -> i64 {
        count := mut 0
        v := mut value
        L {
            byte := v & 127  # lower 7 bits
            v = v >> 7
            I v > 0 {
                @.write_u8(byte | 128)  # set continuation bit
            } E {
                @.write_u8(byte)
            }
            count = count + 1
            I v == 0 { B }
        }
        count
    }

    # Read unsigned varint (LEB128 decoding)
    # Returns the decoded value, or -1 on error
    F read_varint(&self) -> i64 {
        result := mut 0
        shift := mut 0
        L {
            I self.pos >= self.len { R 0 - 1 }
            byte := @.read_u8()
            I byte < 0 { R 0 - 1 }
            result = result | ((byte & 127) << shift)
            I (byte & 128) == 0 { B }
            shift = shift + 7
            I shift >= 64 { R 0 - 1 }  # overflow protection
        }
        result
    }

    # Write u16 in little-endian (2 bytes)
    F write_u16_le(&self, value: i64) -> i64 {
        @.ensure_capacity(self.len + 2)
        store_byte(self.data + self.len, value & 255)
        store_byte(self.data + self.len + 1, (value >> 8) & 255)
        self.len = self.len + 2
        2
    }

    # Read u16 little-endian
    F read_u16_le(&self) -> i64 {
        I self.pos + 2 > self.len { R 0 - 1 }
        b0 := load_byte(self.data + self.pos)
        b1 := load_byte(self.data + self.pos + 1)
        self.pos = self.pos + 2
        b0 | (b1 << 8)
    }

    # Write f64 value (stored as 8-byte little-endian, same bit pattern as i64)
    # Caller should use f64_to_bits() to convert f64 to i64 before calling
    F write_f64_le(&self, bits: i64) -> i64 {
        @.write_i64_le(bits)
    }

    # Read f64 value (returns i64 bit pattern)
    # Caller should use bits_to_f64() to convert back to f64
    F read_f64_le(&self) -> i64 {
        @.read_i64_le()
    }

    # Read a length-prefixed string
    # Format: [i32 length (LE)] [bytes]
    # Returns a new heap-allocated null-terminated string as i64 pointer
    # Returns 0 on error (insufficient data)
    F read_str(&self) -> i64 {
        I self.pos + 4 > self.len { R 0 }
        slen := @.read_i32_le()
        I slen < 0 { R 0 }
        I self.pos + slen > self.len { R 0 }
        buf := malloc(slen + 1)
        memcpy(buf, self.data + self.pos, slen)
        store_byte(buf + slen, 0)  # null terminator
        self.pos = self.pos + slen
        buf
    }

    # Free memory
    F drop(&self) -> i64 {
        I self.data != 0 { free(self.data) }
        self.data = 0
        self.len = 0
        self.cap = 0
        self.pos = 0
        0
    }
}
