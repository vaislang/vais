// Compiler interface for Vais
// This module handles compilation using the vaisc compiler

export class VaisCompiler {
  constructor() {
    this.isReady = false;
    this.wasmSupported = this.checkWasmSupport();
  }

  checkWasmSupport() {
    try {
      if (typeof WebAssembly === 'object' &&
          typeof WebAssembly.instantiate === 'function') {
        return true;
      }
    } catch (e) {
      console.error('WebAssembly check failed:', e);
    }
    return false;
  }

  async initialize() {
    if (!this.wasmSupported) {
      throw new Error('WebAssembly is not supported in this browser');
    }

    // TODO: Load WASM module when available
    // For now, we'll use a mock implementation
    this.isReady = true;
    return true;
  }

  async compile(sourceCode) {
    if (!this.isReady) {
      await this.initialize();
    }

    // Mock compilation for demonstration
    // In production, this would call the WASM-compiled vaisc compiler
    return this.mockCompile(sourceCode);
  }

  mockCompile(sourceCode) {
    // Simple validation and mock compilation
    const errors = [];
    const warnings = [];

    // Check for basic syntax errors
    if (!sourceCode.trim()) {
      errors.push({
        line: 1,
        column: 1,
        message: 'Empty source file'
      });
    }

    // Check for main function
    if (!sourceCode.includes('F main')) {
      warnings.push({
        line: 1,
        column: 1,
        message: 'No main function found'
      });
    }

    // Check for unclosed braces
    const openBraces = (sourceCode.match(/\{/g) || []).length;
    const closeBraces = (sourceCode.match(/\}/g) || []).length;
    if (openBraces !== closeBraces) {
      errors.push({
        line: sourceCode.split('\n').length,
        column: 1,
        message: `Mismatched braces: ${openBraces} opening, ${closeBraces} closing`
      });
    }

    if (errors.length > 0) {
      return {
        success: false,
        errors,
        warnings,
        output: null
      };
    }

    // Generate mock LLVM IR
    const ir = this.generateMockIR(sourceCode);

    return {
      success: true,
      errors: [],
      warnings,
      ir,
      output: 'Compilation successful (mock mode)'
    };
  }

  generateMockIR(sourceCode) {
    // Generate simple mock LLVM IR
    return `; ModuleID = 'playground.vais'
source_filename = "playground.vais"

; Mock LLVM IR for Vais Playground
; In production, this would be generated by the actual compiler

declare i32 @puts(i8*)
declare i32 @putchar(i32)

define i64 @main() {
entry:
  ; Your code would be compiled here
  ret i64 0
}
`;
  }

  async execute(ir) {
    // Mock execution
    // In production, this would execute the compiled WASM or interpret the IR
    return this.mockExecute(ir);
  }

  mockExecute(ir) {
    // Simple mock execution
    // Parse the IR to determine output
    const output = [];

    // Check for puts calls
    const putsMatches = ir.match(/@puts\("([^"]*)"\)/g);
    if (putsMatches) {
      putsMatches.forEach(match => {
        const str = match.match(/"([^"]*)"/)[1];
        output.push(str);
      });
    }

    // Check for numeric return value
    const retMatch = ir.match(/ret i64 (\d+)/);
    if (retMatch) {
      const exitCode = parseInt(retMatch[1]);
      if (exitCode !== 0) {
        output.push(`Exit code: ${exitCode}`);
      }
    }

    return {
      success: true,
      output: output.length > 0 ? output.join('\n') : 'Program executed successfully',
      exitCode: 0
    };
  }

  async compileAndRun(sourceCode) {
    try {
      // Compile
      const compileResult = await this.compile(sourceCode);

      if (!compileResult.success) {
        return {
          success: false,
          errors: compileResult.errors,
          warnings: compileResult.warnings,
          output: null
        };
      }

      // Execute
      const execResult = await this.execute(compileResult.ir);

      return {
        success: true,
        errors: [],
        warnings: compileResult.warnings,
        output: execResult.output,
        exitCode: execResult.exitCode
      };
    } catch (error) {
      return {
        success: false,
        errors: [{
          line: 0,
          column: 0,
          message: `Internal error: ${error.message}`
        }],
        warnings: [],
        output: null
      };
    }
  }

  formatError(error) {
    return `Error at line ${error.line}, column ${error.column}: ${error.message}`;
  }

  formatWarning(warning) {
    return `Warning at line ${warning.line}, column ${warning.column}: ${warning.message}`;
  }
}

export default VaisCompiler;
