{
  "Function Definition": {
    "prefix": ["F", "func", "function"],
    "body": [
      "F ${1:name}(${2:params}) -> ${3:ReturnType} {",
      "\t$0",
      "}"
    ],
    "description": "Define a new function"
  },
  "Function Expression": {
    "prefix": ["Fe", "funce"],
    "body": "F ${1:name}(${2:params}) -> ${3:ReturnType} = ${0:expression}",
    "description": "Define a function with expression body"
  },
  "Struct Definition": {
    "prefix": ["S", "struct"],
    "body": [
      "S ${1:Name} {",
      "\t${2:field}: ${3:Type},$0",
      "}"
    ],
    "description": "Define a new struct"
  },
  "Generic Struct": {
    "prefix": ["Sg", "gstruct"],
    "body": [
      "S ${1:Name}<${2:T}> {",
      "\t${3:field}: ${4:T},$0",
      "}"
    ],
    "description": "Define a generic struct"
  },
  "Enum Definition": {
    "prefix": ["E", "enum"],
    "body": [
      "E ${1:Name} {",
      "\t${2:Variant1},",
      "\t${3:Variant2},$0",
      "}"
    ],
    "description": "Define a new enum"
  },
  "Enum with Data": {
    "prefix": ["Ed", "enumd"],
    "body": [
      "E ${1:Name} {",
      "\t${2:Variant}(${3:Type}),$0",
      "}"
    ],
    "description": "Define an enum with data variants"
  },
  "Trait Definition": {
    "prefix": ["W", "trait"],
    "body": [
      "W ${1:TraitName} {",
      "\tF ${2:method}(${3:&self}) -> ${4:ReturnType};$0",
      "}"
    ],
    "description": "Define a new trait"
  },
  "Impl Block": {
    "prefix": ["X", "impl"],
    "body": [
      "X ${1:Type} {",
      "\tF ${2:method}(&self) -> ${3:ReturnType} {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Implement methods for a type"
  },
  "Trait Impl": {
    "prefix": ["Xt", "implt"],
    "body": [
      "X ${1:Type}: ${2:Trait} {",
      "\tF ${3:method}(&self) -> ${4:ReturnType} {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Implement a trait for a type"
  },
  "Match Expression": {
    "prefix": ["M", "match"],
    "body": [
      "M ${1:expr} {",
      "\t${2:pattern} => ${3:result},",
      "\t_ => ${0:default},",
      "}"
    ],
    "description": "Match expression"
  },
  "If Expression": {
    "prefix": ["I", "if"],
    "body": [
      "I ${1:condition} {",
      "\t$0",
      "}"
    ],
    "description": "If expression"
  },
  "If-Else Expression": {
    "prefix": ["Ie", "ifelse"],
    "body": [
      "I ${1:condition} {",
      "\t$2",
      "} E {",
      "\t$0",
      "}"
    ],
    "description": "If-else expression"
  },
  "Loop": {
    "prefix": ["L", "loop"],
    "body": [
      "L {",
      "\t$0",
      "}"
    ],
    "description": "Infinite loop"
  },
  "While Loop": {
    "prefix": ["Lw", "while"],
    "body": [
      "L ${1:condition} {",
      "\t$0",
      "}"
    ],
    "description": "While-style loop with condition"
  },
  "For Loop": {
    "prefix": ["for"],
    "body": [
      "for ${1:item} in ${2:iter} {",
      "\t$0",
      "}"
    ],
    "description": "For loop over iterator"
  },
  "Main Function": {
    "prefix": ["main", "Fmain"],
    "body": [
      "F main() -> i64 {",
      "\t$0",
      "\t0",
      "}"
    ],
    "description": "Main entry point function"
  },
  "Print": {
    "prefix": ["print", "printf"],
    "body": "printf(\"${1:%s}\\n\", ${2:args})",
    "description": "Print formatted string"
  },
  "Let Binding": {
    "prefix": ["let"],
    "body": "${1:name} := ${0:value}",
    "description": "Variable binding"
  },
  "Mutable Binding": {
    "prefix": ["letm", "mut"],
    "body": "${1:name} := mut ${0:value}",
    "description": "Mutable variable binding"
  },
  "Import": {
    "prefix": ["U", "import", "use"],
    "body": "U \"${1:path}\"",
    "description": "Import/use a module"
  },
  "Return": {
    "prefix": ["R", "return"],
    "body": "R ${0:value}",
    "description": "Return statement"
  },
  "Break": {
    "prefix": ["B", "break"],
    "body": "B",
    "description": "Break from loop"
  },
  "Continue": {
    "prefix": ["C", "continue"],
    "body": "C",
    "description": "Continue to next iteration"
  },
  "Assert": {
    "prefix": ["assert"],
    "body": "assert(${1:condition}, \"${2:message}\")",
    "description": "Assert condition"
  },
  "Async Function": {
    "prefix": ["A", "async", "Fasync"],
    "body": [
      "A F ${1:name}(${2:params}) -> ${3:ReturnType} {",
      "\t$0",
      "}"
    ],
    "description": "Async function definition"
  },
  "Await": {
    "prefix": ["Y", "await"],
    "body": "${0:future}.Y",
    "description": "Await a future (postfix .Y)"
  },
  "Spawn": {
    "prefix": ["spawn"],
    "body": "spawn ${0:async_fn}()",
    "description": "Spawn an async task"
  },
  "Defer": {
    "prefix": ["D", "defer"],
    "body": [
      "D {",
      "\t${0:cleanup_code}",
      "}"
    ],
    "description": "Defer block until scope exit"
  },
  "Test Function": {
    "prefix": ["test", "Ftest"],
    "body": [
      "#[test]",
      "F test_${1:name}() {",
      "\t$0",
      "}"
    ],
    "description": "Test function"
  },
  "Derive": {
    "prefix": ["derive"],
    "body": "#[derive(${1:Debug, Clone})]",
    "description": "Derive attribute"
  },
  "Option Some": {
    "prefix": ["Some"],
    "body": "Some(${0:value})",
    "description": "Some variant of Option"
  },
  "Option None": {
    "prefix": ["None"],
    "body": "None",
    "description": "None variant of Option"
  },
  "Result Ok": {
    "prefix": ["Ok"],
    "body": "Ok(${0:value})",
    "description": "Ok variant of Result"
  },
  "Result Err": {
    "prefix": ["Err"],
    "body": "Err(${0:error})",
    "description": "Err variant of Result"
  },
  "Impl for Trait": {
    "prefix": ["implfor", "Xfor"],
    "body": [
      "X ${1:TypeName}: ${2:TraitName} {",
      "\tF ${3:method}(&self) -> ${4:ReturnType} {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Implement a trait for a type"
  },
  "Impl Constructor": {
    "prefix": ["implnew", "new"],
    "body": [
      "F new(${1:params}) -> Self {",
      "\tSelf {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Constructor pattern returning Self"
  },
  "Derive Multiple": {
    "prefix": ["derives"],
    "body": "#[derive(Debug, Clone, PartialEq)]",
    "description": "Derive Debug, Clone, and PartialEq"
  },
  "Match Option": {
    "prefix": ["moption", "matchopt"],
    "body": [
      "M ${1:option_expr} {",
      "\tSome(${2:v}) => ${3:v},",
      "\tNone => ${0:default},",
      "}"
    ],
    "description": "Match on Option with Some/None"
  },
  "Match Result": {
    "prefix": ["mresult", "matchres"],
    "body": [
      "M ${1:result_expr} {",
      "\tOk(${2:v}) => ${3:v},",
      "\tErr(${4:e}) => ${0:handle_error},",
      "}"
    ],
    "description": "Match on Result with Ok/Err"
  },
  "Match Enum": {
    "prefix": ["menum", "matchenum"],
    "body": [
      "M ${1:enum_expr} {",
      "\t${2:Variant1} => ${3:result1},",
      "\t${4:Variant2}(${5:data}) => ${6:result2},",
      "\t_ => ${0:default},",
      "}"
    ],
    "description": "Match on enum with multiple variants"
  },
  "Async Main": {
    "prefix": ["asyncmain", "amain"],
    "body": [
      "A F main() -> i64 {",
      "\t$0",
      "\t0",
      "}"
    ],
    "description": "Async main function"
  },
  "Spawn Await": {
    "prefix": ["spawnawait", "spawny"],
    "body": [
      "handle := spawn ${1:async_fn}(${2:args})",
      "result := handle.Y",
      "$0"
    ],
    "description": "Spawn async task and await result"
  },
  "Async Handler": {
    "prefix": ["asynchandler", "ahandler"],
    "body": [
      "A F ${1:handler}(${2:request}: ${3:Request}) -> ${4:Response} {",
      "\t$0",
      "}"
    ],
    "description": "Async handler function"
  },
  "Try Chain": {
    "prefix": ["trychain", "??"],
    "body": "${1:fn1}()?${2:.fn2}()?${0}",
    "description": "Chain try operator for error propagation"
  },
  "Unwrap Or": {
    "prefix": ["unwrapor", "!or"],
    "body": "${1:option}! ?: ${0:default}",
    "description": "Unwrap with default value fallback"
  },
  "Vec New": {
    "prefix": ["vecnew", "vec"],
    "body": [
      "${1:v} := Vec::new<${2:T}>()",
      "${1:v}.push(${0:value})"
    ],
    "description": "Create new Vec and push value"
  },
  "HashMap New": {
    "prefix": ["hashmapnew", "hashmap"],
    "body": [
      "${1:map} := HashMap::new<${2:K}, ${3:V}>()",
      "${1:map}.insert(${4:key}, ${0:value})"
    ],
    "description": "Create new HashMap and insert key-value"
  },
  "For Range": {
    "prefix": ["forrange", "fori"],
    "body": [
      "L ${1:i} := 0..${2:n} {",
      "\t$0",
      "}"
    ],
    "description": "Loop over range 0..n"
  },
  "Iter Chain": {
    "prefix": ["iterchain", "ichain"],
    "body": [
      "${1:collection}",
      "\t.iter_map(|${2:x}| ${3:x * 2})",
      "\t.iter_filter(|${4:x}| ${5:x > 0})",
      "\t${0}"
    ],
    "description": "Iterator chain with map and filter"
  },
  "Module File": {
    "prefix": ["module", "mod"],
    "body": [
      "# ${1:Module description}",
      "",
      "U \"${2:dependency}\"",
      "",
      "F ${3:function}(${4:params}) -> ${5:ReturnType} {",
      "\t$0",
      "}",
      ""
    ],
    "description": "Basic module file structure"
  },
  "Const Definition": {
    "prefix": ["const", "C"],
    "body": "const ${1:NAME}: ${2:Type} = ${0:value}",
    "description": "Constant definition"
  },
  "Extern Function": {
    "prefix": ["N", "extern", "NF"],
    "body": "N F ${1:name}(${2:params}) -> ${0:ReturnType}",
    "description": "External function declaration"
  },
  "Closure": {
    "prefix": ["closure", "lambda"],
    "body": "|${1:params}| ${0:body}",
    "description": "Closure/lambda expression"
  },
  "Test Assert Eq": {
    "prefix": ["testeq", "asserteq"],
    "body": [
      "#[test]",
      "F test_${1:name}() {",
      "\tresult := ${2:function_call}()",
      "\tassert_eq(result, ${0:expected})",
      "}"
    ],
    "description": "Test function with assert_eq"
  },
  "Benchmark": {
    "prefix": ["benchmark", "bench"],
    "body": [
      "#[bench]",
      "F bench_${1:name}(b: &mut Bencher) {",
      "\tb.iter(|| {",
      "\t\t${0:code_to_benchmark}",
      "\t})",
      "}"
    ],
    "description": "Benchmark function"
  },
  "Vais Binding": {
    "prefix": [":="],
    "body": "${1:name} := ${0:value}",
    "description": "Vais variable binding"
  },
  "Vais Mut Binding": {
    "prefix": [":=mut", "mutbind"],
    "body": "${1:name} := mut ${0:value}",
    "description": "Vais mutable variable binding"
  },
  "Self Recursion": {
    "prefix": ["@", "selfrecur"],
    "body": "@(${0:args})",
    "description": "Self-recursion operator"
  },
  "Postfix Await": {
    "prefix": [".Y", "postfixawait"],
    "body": "${1:future}.Y",
    "description": "Postfix await operator"
  },
  "Use Import": {
    "prefix": ["use"],
    "body": "U \"${0:module_path}\"",
    "description": "Use/import statement"
  },
  "Ternary": {
    "prefix": ["ternary", "?:"],
    "body": "${1:condition} ? ${2:if_true} : ${0:if_false}",
    "description": "Ternary conditional operator"
  },
  "Type Alias": {
    "prefix": ["T", "type", "talias"],
    "body": "T ${1:Alias} = ${0:Type}",
    "description": "Type alias definition"
  },
  "Global Variable": {
    "prefix": ["G", "global"],
    "body": "G ${1:name}: ${2:Type} = ${0:value}",
    "description": "Global variable definition"
  },
  "Public Function": {
    "prefix": ["P", "pub", "pfn"],
    "body": [
      "P F ${1:name}(${2:params}) -> ${3:ReturnType} {",
      "\t$0",
      "}"
    ],
    "description": "Public function definition"
  },
  "Public Struct": {
    "prefix": ["PS", "pubstruct"],
    "body": [
      "P S ${1:Name} {",
      "\t${2:field}: ${3:Type},$0",
      "}"
    ],
    "description": "Public struct definition"
  },
  "Pipe Operator": {
    "prefix": ["pipe", "|>"],
    "body": "${1:value} |> ${0:function}",
    "description": "Pipe operator for function composition"
  },
  "String Interpolation": {
    "prefix": ["interp", "~"],
    "body": "~\"${1:text} ~{${2:expr}}${0}\"",
    "description": "String interpolation with ~{expr}"
  },
  "For Each": {
    "prefix": ["foreach", "forin"],
    "body": [
      "L ${1:item} := ${2:collection} {",
      "\t$0",
      "}"
    ],
    "description": "Loop over each item in collection"
  },
  "Result Try": {
    "prefix": ["try", "?"],
    "body": "${0:result_expr}?",
    "description": "Try operator for Result/Option"
  },
  "Unwrap": {
    "prefix": ["unwrap", "!"],
    "body": "${0:option_expr}!",
    "description": "Unwrap operator for Result/Option"
  },
  "Generic Function": {
    "prefix": ["Fg", "gfn"],
    "body": [
      "F ${1:name}<${2:T}>(${3:param}: ${4:T}) -> ${5:T} {",
      "\t$0",
      "}"
    ],
    "description": "Generic function definition"
  },
  "Generic Trait": {
    "prefix": ["Wg", "gtrait"],
    "body": [
      "W ${1:TraitName}<${2:T}> {",
      "\tF ${3:method}(&self, ${4:param}: ${5:T}) -> ${6:T};$0",
      "}"
    ],
    "description": "Generic trait definition"
  },
  "Match Guard": {
    "prefix": ["mguard", "matchguard"],
    "body": [
      "M ${1:expr} {",
      "\t${2:pattern} I ${3:guard_condition} => ${4:result},",
      "\t${5:pattern} => ${6:default},",
      "\t_ => ${0:fallback},",
      "}"
    ],
    "description": "Match with guard condition"
  },
  "Error Propagation": {
    "prefix": ["eprop", "errprop"],
    "body": [
      "M ${1:result} {",
      "\tOk(${2:v}) => ${3:v},",
      "\tErr(${4:e}) => R Err(${5:e}),",
      "}"
    ],
    "description": "Error propagation pattern"
  },
  "Builder Pattern": {
    "prefix": ["builder", "build"],
    "body": [
      "X ${1:Builder} {",
      "\tF new() -> Self {",
      "\t\tSelf { ${2:field}: ${3:default} }",
      "\t}",
      "\t",
      "\tF ${4:with_field}(&mut self, ${5:value}: ${6:Type}) -> &mut Self {",
      "\t\tself.${7:field} = ${8:value}",
      "\t\tself",
      "\t}",
      "\t",
      "\tF build(&self) -> ${9:Target} {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Builder pattern implementation"
  },
  "Visitor Pattern": {
    "prefix": ["visitor", "visit"],
    "body": [
      "W ${1:Visitor} {",
      "\tF visit_${2:variant}(&mut self, ${3:param}: &${4:Type});$0",
      "}",
      "",
      "X ${5:Type}: ${1:Visitor} {",
      "\tF visit_${2:variant}(&mut self, ${3:param}: &${4:Type}) {",
      "\t\t${6}",
      "\t}",
      "}"
    ],
    "description": "Visitor pattern trait and impl"
  },
  "State Pattern": {
    "prefix": ["state", "statemachine"],
    "body": [
      "E ${1:State} {",
      "\t${2:StateA},",
      "\t${3:StateB},$0",
      "}",
      "",
      "S ${4:StateMachine} {",
      "\tstate: ${1:State},",
      "}",
      "",
      "X ${4:StateMachine} {",
      "\tF transition(&mut self, event: ${5:Event}) {",
      "\t\tself.state = M self.state {",
      "\t\t\t${2:StateA} => ${3:StateB},",
      "\t\t\t${3:StateB} => ${2:StateA},",
      "\t\t\t_ => self.state,",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "State machine pattern"
  },
  "Iterator Trait": {
    "prefix": ["iterator", "iter"],
    "body": [
      "W Iterator {",
      "\ttype Item;",
      "\tF next(&mut self) -> Option<Self::Item>;",
      "}",
      "",
      "X ${1:Type}: Iterator {",
      "\ttype Item = ${2:ItemType};",
      "\t",
      "\tF next(&mut self) -> Option<Self::Item> {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Iterator trait implementation"
  },
  "Drop Trait": {
    "prefix": ["drop", "cleanup"],
    "body": [
      "W Drop {",
      "\tF drop(&mut self);",
      "}",
      "",
      "X ${1:Type}: Drop {",
      "\tF drop(&mut self) {",
      "\t\t${0:# cleanup code}",
      "\t}",
      "}"
    ],
    "description": "Drop trait for cleanup"
  },
  "Range Loop": {
    "prefix": ["range", ".."],
    "body": [
      "L ${1:i} := ${2:start}..${3:end} {",
      "\t$0",
      "}"
    ],
    "description": "Loop over custom range"
  },
  "Inclusive Range": {
    "prefix": ["rangeinc", "..="],
    "body": [
      "L ${1:i} := ${2:start}..=${3:end} {",
      "\t$0",
      "}"
    ],
    "description": "Loop over inclusive range"
  },
  "Macro Rules": {
    "prefix": ["macro", "macrorules"],
    "body": [
      "macro_rules! ${1:name} {",
      "\t(${2:pattern}) => {",
      "\t\t${0:expansion}",
      "\t};",
      "}"
    ],
    "description": "Declarative macro definition"
  },
  "WASM Import": {
    "prefix": ["wasmimport", "wasm"],
    "body": [
      "#[wasm_import(\"${1:module}\", \"${2:name}\")]",
      "N F ${3:name}(${4:params}) -> ${0:ReturnType}"
    ],
    "description": "WASM import declaration"
  },
  "WASM Export": {
    "prefix": ["wasmexport", "wasmexp"],
    "body": [
      "#[wasm_export(\"${1:name}\")]",
      "P F ${2:name}(${3:params}) -> ${4:ReturnType} {",
      "\t$0",
      "}"
    ],
    "description": "WASM export function"
  },
  "Cfg Attribute": {
    "prefix": ["cfg", "conditional"],
    "body": "#[cfg(${1|target_os,feature,test|}=\"${2:value}\")]",
    "description": "Conditional compilation attribute"
  },
  "Inline Attribute": {
    "prefix": ["inline"],
    "body": "#[inline${1|(always),|}]",
    "description": "Inline function hint"
  },
  "Test Suite": {
    "prefix": ["testsuite", "tests"],
    "body": [
      "#[cfg(test)]",
      "mod tests {",
      "\tU \"super::*\"",
      "\t",
      "\t#[test]",
      "\tF test_${1:name}() {",
      "\t\t${0:# test code}",
      "\t}",
      "}"
    ],
    "description": "Test module structure"
  },
  "Error Enum": {
    "prefix": ["error", "errorenum"],
    "body": [
      "E ${1:Error} {",
      "\t${2:NotFound}(String),",
      "\t${3:Invalid}(String),",
      "\t${4:Io}(IoError),$0",
      "}",
      "",
      "X ${1:Error} {",
      "\tF message(&self) -> String {",
      "\t\tM self {",
      "\t\t\t${2:NotFound}(msg) => ~\"Not found: ~{msg}\",",
      "\t\t\t${3:Invalid}(msg) => ~\"Invalid: ~{msg}\",",
      "\t\t\t${4:Io}(err) => ~\"IO error: ~{err}\",",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Error enum with message method"
  },
  "Newtype Pattern": {
    "prefix": ["newtype"],
    "body": [
      "S ${1:TypeName}(${2:InnerType});",
      "",
      "X ${1:TypeName} {",
      "\tF new(${3:value}: ${2:InnerType}) -> Self {",
      "\t\tSelf(${3:value})",
      "\t}",
      "\t",
      "\tF inner(&self) -> &${2:InnerType} {",
      "\t\t&self.0",
      "\t}",
      "}"
    ],
    "description": "Newtype wrapper pattern"
  },
  "Singleton Pattern": {
    "prefix": ["singleton"],
    "body": [
      "S ${1:Singleton} {",
      "\t${2:data}: ${3:Type},",
      "}",
      "",
      "G ${1:Singleton}_INSTANCE: Option<${1:Singleton}> = None",
      "",
      "X ${1:Singleton} {",
      "\tF instance() -> &'static ${1:Singleton} {",
      "\t\tI ${1:Singleton}_INSTANCE.is_none() {",
      "\t\t\t${1:Singleton}_INSTANCE = Some(${1:Singleton} { ${2:data}: ${4:default} })",
      "\t\t}",
      "\t\t${1:Singleton}_INSTANCE!",
      "\t}",
      "}"
    ],
    "description": "Singleton pattern with global instance"
  }
}
