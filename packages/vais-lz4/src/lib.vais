# LZ4 Compression/Decompression Library
# Pure Vais implementation of LZ4 block and frame formats

# ============================================================================
# Constants
# ============================================================================

C LZ4_MAX_INPUT_SIZE: i64 = 2113929216
C LZ4_HASH_LOG: i64 = 16
C LZ4_HASH_SIZE: i64 = 65536
C LZ4_MIN_MATCH: i64 = 4
C LZ4_LAST_LITERALS: i64 = 5
C LZ4_MF_LIMIT: i64 = 12

C LZ4_MAGIC: i64 = 407710212

# ============================================================================
# Extern Declarations
# ============================================================================

X F malloc(size: i64) -> i64
X F free(ptr: i64) -> i64
X F str_to_ptr(s: str) -> i64
X F load_byte(ptr: i64) -> i64
X F store_byte(ptr: i64, val: i64) -> i64
X F load_i64(ptr: i64) -> i64
X F store_i64(ptr: i64, val: i64) -> i64
X F memcpy(dest: i64, src: i64, n: i64) -> i64
X F memset(dest: i64, val: i64, n: i64) -> i64

# ============================================================================
# Result Type
# ============================================================================

S Lz4Result {
    data: i64,
    len: i64,
    status: i64
}

# ============================================================================
# Helper Functions
# ============================================================================

F read_u16_le(ptr: i64) -> i64 {
    b0 := load_byte(ptr)
    b1 := load_byte(ptr + 1)
    R (b0 & 255) | ((b1 & 255) << 8)
}

F write_u16_le(ptr: i64, val: i64) -> i64 {
    store_byte(ptr, val & 255)
    store_byte(ptr + 1, (val >> 8) & 255)
    R 0
}

F read_u32_le(ptr: i64) -> i64 {
    b0 := load_byte(ptr)
    b1 := load_byte(ptr + 1)
    b2 := load_byte(ptr + 2)
    b3 := load_byte(ptr + 3)
    R (b0 & 255) | ((b1 & 255) << 8) | ((b2 & 255) << 16) | ((b3 & 255) << 24)
}

F write_u32_le(ptr: i64, val: i64) -> i64 {
    store_byte(ptr, val & 255)
    store_byte(ptr + 1, (val >> 8) & 255)
    store_byte(ptr + 2, (val >> 16) & 255)
    store_byte(ptr + 3, (val >> 24) & 255)
    R 0
}

F lz4_hash(val: i64) -> i64 {
    # Knuth's multiplicative hash
    product := val * 2654435761
    shifted := (product >> 16) & 2147483647
    R shifted & 65535
}

# ============================================================================
# LZ4 Block Compression
# ============================================================================

F lz4_compress(src: i64, src_len: i64) -> Lz4Result {
    I src_len == 0 {
        result := Lz4Result { data: 0, len: 0, status: 0 }
        R result
    }

    I src_len > LZ4_MAX_INPUT_SIZE {
        result := Lz4Result { data: 0, len: 0, status: -1 }
        R result
    }

    # Allocate hash table (65536 entries * 8 bytes = 524288 bytes)
    hash_table := malloc(524288)
    I hash_table == 0 {
        result := Lz4Result { data: 0, len: 0, status: -2 }
        R result
    }
    memset(hash_table, 0, 524288)

    # Allocate output buffer (worst case: src_len + src_len/255 + 16)
    max_out := src_len + (src_len / 255) + 16
    dst := malloc(max_out)
    I dst == 0 {
        free(hash_table)
        result := Lz4Result { data: 0, len: 0, status: -2 }
        R result
    }

    ip := mut 0
    anchor := mut 0
    op := mut 0

    # Main compression loop
    L ip < (src_len - LZ4_MF_LIMIT) {
        # Hash current position
        val := read_u32_le(src + ip)
        h := lz4_hash(val)

        # Get candidate from hash table
        candidate := load_i64(hash_table + (h * 8))

        # Store current position in hash table
        store_i64(hash_table + (h * 8), ip)

        # Check if candidate is valid and matches
        match_found := mut 0
        I candidate < ip {
            I candidate >= 0 {
                # Check if bytes match (at least 4 bytes)
                v1 := read_u32_le(src + candidate)
                v2 := read_u32_le(src + ip)
                I v1 == v2 {
                    match_found = 1
                }
            }
        }

        I match_found == 0 {
            ip = ip + 1
            C
        }

        # We have a match! Encode it
        literal_len := ip - anchor

        # Count match length
        match_len := mut LZ4_MIN_MATCH
        L (ip + match_len) < src_len {
            I load_byte(src + candidate + match_len) == load_byte(src + ip + match_len) {
                match_len = match_len + 1
            } E {
                B
            }
        }

        # Write token
        token_lit := I literal_len >= 15 { 15 } E { literal_len }
        token_match := I (match_len - LZ4_MIN_MATCH) >= 15 { 15 } E { match_len - LZ4_MIN_MATCH }
        token := (token_lit << 4) | token_match
        store_byte(dst + op, token)
        op = op + 1

        # Write extra literal length if needed
        I literal_len >= 15 {
            extra := mut literal_len - 15
            L extra >= 255 {
                store_byte(dst + op, 255)
                op = op + 1
                extra = extra - 255
            }
            store_byte(dst + op, extra)
            op = op + 1
        }

        # Copy literals
        memcpy(dst + op, src + anchor, literal_len)
        op = op + literal_len

        # Write match offset
        offset := ip - candidate
        write_u16_le(dst + op, offset)
        op = op + 2

        # Write extra match length if needed
        I (match_len - LZ4_MIN_MATCH) >= 15 {
            extra := mut match_len - LZ4_MIN_MATCH - 15
            L extra >= 255 {
                store_byte(dst + op, 255)
                op = op + 1
                extra = extra - 255
            }
            store_byte(dst + op, extra)
            op = op + 1
        }

        # Update positions
        ip = ip + match_len
        anchor = ip
    }

    # Write final literals
    final_literals := src_len - anchor
    I final_literals > 0 {
        token_lit := I final_literals >= 15 { 15 } E { final_literals }
        token := token_lit << 4
        store_byte(dst + op, token)
        op = op + 1

        I final_literals >= 15 {
            extra := mut final_literals - 15
            L extra >= 255 {
                store_byte(dst + op, 255)
                op = op + 1
                extra = extra - 255
            }
            store_byte(dst + op, extra)
            op = op + 1
        }

        memcpy(dst + op, src + anchor, final_literals)
        op = op + final_literals
    }

    free(hash_table)

    result := Lz4Result { data: dst, len: op, status: 0 }
    R result
}

# ============================================================================
# LZ4 Block Decompression
# ============================================================================

F lz4_decompress(src: i64, src_len: i64, original_len: i64) -> Lz4Result {
    I original_len == 0 {
        result := Lz4Result { data: 0, len: 0, status: 0 }
        R result
    }

    dst := malloc(original_len)
    I dst == 0 {
        result := Lz4Result { data: 0, len: 0, status: -2 }
        R result
    }

    ip := mut 0
    op := mut 0

    L ip < src_len {
        # Read token
        token := load_byte(src + ip)
        ip = ip + 1

        # Extract literal length
        literal_len := mut (token >> 4) & 15
        I literal_len == 15 {
            L 1 == 1 {
                extra_byte := load_byte(src + ip)
                ip = ip + 1
                literal_len = literal_len + extra_byte
                I extra_byte != 255 {
                    B
                }
            }
        }

        # Copy literals
        I literal_len > 0 {
            memcpy(dst + op, src + ip, literal_len)
            ip = ip + literal_len
            op = op + literal_len
        }

        # Check if we're done
        I ip >= src_len {
            B
        }

        # Read match offset
        offset := read_u16_le(src + ip)
        ip = ip + 2

        # Extract match length
        match_len := mut (token & 15) + LZ4_MIN_MATCH
        I (token & 15) == 15 {
            L 1 == 1 {
                extra_byte := load_byte(src + ip)
                ip = ip + 1
                match_len = match_len + extra_byte
                I extra_byte != 255 {
                    B
                }
            }
        }

        # Copy match (byte by byte to handle overlaps)
        match_pos := op - offset
        i := mut 0
        L i < match_len {
            store_byte(dst + op, load_byte(dst + match_pos))
            op = op + 1
            match_pos = match_pos + 1
            i = i + 1
        }
    }

    result := Lz4Result { data: dst, len: op, status: 0 }
    R result
}

# ============================================================================
# LZ4 Frame Format
# ============================================================================

S Lz4Frame {
    content_size: i64,
    block_max_size: i64
}

F lz4_frame_compress(src: i64, src_len: i64) -> Lz4Result {
    # Compress block first
    block_result := lz4_compress(src, src_len)
    I block_result.status != 0 {
        R block_result
    }

    # Allocate frame buffer (magic + descriptor + block size + block + end mark)
    frame_size := 4 + 3 + 4 + block_result.len + 4
    frame := malloc(frame_size)
    I frame == 0 {
        free(block_result.data)
        result := Lz4Result { data: 0, len: 0, status: -2 }
        R result
    }

    pos := mut 0

    # Write magic number
    write_u32_le(frame + pos, LZ4_MAGIC)
    pos = pos + 4

    # Write frame descriptor (simplified: FLG=0x40, BD=0x70, HC=0x00)
    store_byte(frame + pos, 64)
    pos = pos + 1
    store_byte(frame + pos, 112)
    pos = pos + 1
    store_byte(frame + pos, 0)
    pos = pos + 1

    # Write block size
    write_u32_le(frame + pos, block_result.len)
    pos = pos + 4

    # Write block data
    memcpy(frame + pos, block_result.data, block_result.len)
    pos = pos + block_result.len

    # Write end mark
    write_u32_le(frame + pos, 0)
    pos = pos + 4

    free(block_result.data)

    result := Lz4Result { data: frame, len: pos, status: 0 }
    R result
}

F lz4_frame_decompress(src: i64, src_len: i64) -> Lz4Result {
    I src_len < 11 {
        result := Lz4Result { data: 0, len: 0, status: -3 }
        R result
    }

    pos := mut 0

    # Verify magic number
    magic := read_u32_le(src + pos)
    pos = pos + 4
    I magic != LZ4_MAGIC {
        result := Lz4Result { data: 0, len: 0, status: -4 }
        R result
    }

    # Skip frame descriptor (3 bytes)
    pos = pos + 3

    # Read block size
    block_size := read_u32_le(src + pos)
    pos = pos + 4

    I block_size == 0 {
        result := Lz4Result { data: 0, len: 0, status: 0 }
        R result
    }

    # For decompression, we need to estimate original size
    # In real LZ4 frames, content_size would be in the descriptor (FLG bit 3)
    # This simplified implementation estimates at most 10x compressed size
    # Cap at LZ4_MAX_INPUT_SIZE to prevent overflow
    I block_size > (LZ4_MAX_INPUT_SIZE / 10) {
        estimated_original := LZ4_MAX_INPUT_SIZE
        result := lz4_decompress(src + pos, block_size, estimated_original)
        R result
    } E {
        estimated_original := block_size * 10
        result := lz4_decompress(src + pos, block_size, estimated_original)
        R result
    }
}

# ============================================================================
# Convenience Functions
# ============================================================================

# Calculate string length from pointer (counts bytes until null terminator)
F ptr_strlen(ptr: i64) -> i64 {
    len := mut 0
    L load_byte(ptr + len) != 0 {
        len = len + 1
    }
    R len
}

# Compress a null-terminated string buffer
# ptr: pointer from str_to_ptr(), automatically calculates length
F lz4_compress_ptr(ptr: i64) -> Lz4Result {
    len := ptr_strlen(ptr)
    R lz4_compress(ptr, len)
}

# ============================================================================
# Simple XXHash32 (simplified for checksums)
# ============================================================================

F xxhash32(data: i64, len: i64, seed: i64) -> i64 {
    # Simplified version - just accumulate bytes
    h := mut seed + 374761393
    i := mut 0
    L i < len {
        b := load_byte(data + i)
        h = h + (b * 668265263)
        h = (h << 13) | ((h >> 19) & 8191)
        h = h * 2246822519
        i = i + 1
    }
    h = h + len
    R h & 2147483647
}
