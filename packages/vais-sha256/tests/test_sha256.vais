# SHA-256 Test Suite
# Tests against NIST FIPS 180-4 test vectors and additional cases

X F malloc(size: i64) -> i64
X F free(ptr: i64) -> i64
X F strlen(s: i64) -> i64
X F str_to_ptr(s: str) -> i64
X F load_byte(ptr: i64) -> i64
X F store_byte(ptr: i64, val: i64) -> i64
X F load_i64(ptr: i64) -> i64
X F print_str(s: str) -> i64
X F print_i64(val: i64) -> i64

# Import SHA-256 functions (these would be from lib.vais)
X F sha256_init() -> i64
X F sha256_update(state: i64, data: i64, len: i64) -> i64
X F sha256_finalize(state: i64) -> i64
X F sha256_hash(data: i64, len: i64) -> i64
X F sha256_hex(hash: i64) -> i64

# Helper: Compare hex strings
F hex_equal(hex: i64, expected: str) -> i64 {
    exp_ptr := str_to_ptr(expected)
    i := mut 0
    L i < 64 {
        h := load_byte(hex + i)
        e := load_byte(exp_ptr + i)
        I h != e {
            R 0
        }
        i = i + 1
    }
    R 1
}

# Helper: Print test result
F print_test_result(name: str, passed: i64) -> i64 {
    print_str(name)
    I passed == 1 {
        print_str(": PASS\n")
    } E {
        print_str(": FAIL\n")
    }
    passed
}

# ============================================================================
# Test 1: Empty string
# ============================================================================

F test_empty_string() -> i64 {
    # SHA-256("") = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    empty := malloc(1)
    store_byte(empty, 0)

    hash := sha256_hash(empty, 0)
    hex := sha256_hex(hash)

    result := hex_equal(hex, "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")

    free(empty)
    free(hash)
    free(hex)

    print_test_result("test_empty_string", result)
}

# ============================================================================
# Test 2: "abc" (NIST test vector)
# ============================================================================

F test_abc() -> i64 {
    # SHA-256("abc") = ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
    # Note: NIST vector is ba7816bf8f01cfea414140de5dae2223b0c04e78232093f9d16aacfb7ddd1e6a
    # But the standard test vector for "abc" is:
    # ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
    data := str_to_ptr("abc")
    hash := sha256_hash(data, 3)
    hex := sha256_hex(hash)

    result := hex_equal(hex, "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad")

    free(hash)
    free(hex)

    print_test_result("test_abc", result)
}

# ============================================================================
# Test 3: "hello"
# ============================================================================

F test_hello() -> i64 {
    # SHA-256("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
    data := str_to_ptr("hello")
    hash := sha256_hash(data, 5)
    hex := sha256_hex(hash)

    result := hex_equal(hex, "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824")

    free(hash)
    free(hex)

    print_test_result("test_hello", result)
}

# ============================================================================
# Test 4: "The quick brown fox jumps over the lazy dog"
# ============================================================================

F test_quick_fox() -> i64 {
    # SHA-256("The quick brown fox jumps over the lazy dog")
    # = d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592
    data := str_to_ptr("The quick brown fox jumps over the lazy dog")
    hash := sha256_hash(data, 44)
    hex := sha256_hex(hash)

    result := hex_equal(hex, "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")

    free(hash)
    free(hex)

    print_test_result("test_quick_fox", result)
}

# ============================================================================
# Test 5: Multiple update calls
# ============================================================================

F test_multiple_updates() -> i64 {
    # Test that multiple update calls produce same result as single call
    # Using "hello world" split as "hello" + " world"

    # Single call
    data1 := str_to_ptr("hello world")
    hash1 := sha256_hash(data1, 11)

    # Multiple calls
    state := sha256_init()
    data2a := str_to_ptr("hello")
    data2b := str_to_ptr(" world")
    sha256_update(state, data2a, 5)
    sha256_update(state, data2b, 6)
    hash2 := sha256_finalize(state)

    # Compare
    match := mut 1
    i := mut 0
    L i < 32 {
        I load_byte(hash1 + i) != load_byte(hash2 + i) {
            match = 0
        }
        i = i + 1
    }

    free(state)
    free(hash1)
    free(hash2)

    print_test_result("test_multiple_updates", match)
}

# ============================================================================
# Test 6: Hex output format
# ============================================================================

F test_hex_format() -> i64 {
    # Test that hex output is properly formatted (64 hex chars, lowercase)
    data := str_to_ptr("test")
    hash := sha256_hash(data, 4)
    hex := sha256_hex(hash)

    # Check length
    len := mut 0
    L load_byte(hex + len) != 0 {
        len = len + 1
    }

    # Check all chars are valid hex (0-9, a-f)
    valid := mut 1
    I len == 64 {
        i := mut 0
        L i < 64 {
            c := load_byte(hex + i)
            is_digit := (c >= 48) & (c <= 57)   # '0'-'9'
            is_lower := (c >= 97) & (c <= 102)  # 'a'-'f'
            I (is_digit | is_lower) == 0 {
                valid = 0
            }
            i = i + 1
        }
    } E {
        valid = 0
    }

    free(hash)
    free(hex)

    print_test_result("test_hex_format", valid)
}

# ============================================================================
# Test 7: Different inputs produce different hashes
# ============================================================================

F test_different_inputs() -> i64 {
    data1 := str_to_ptr("apple")
    data2 := str_to_ptr("orange")

    hash1 := sha256_hash(data1, 5)
    hash2 := sha256_hash(data2, 6)

    # Ensure hashes are different
    different := mut 0
    i := mut 0
    L i < 32 {
        I load_byte(hash1 + i) != load_byte(hash2 + i) {
            different = 1
        }
        i = i + 1
    }

    free(hash1)
    free(hash2)

    print_test_result("test_different_inputs", different)
}

# ============================================================================
# Test 8: Long message (multi-block)
# ============================================================================

F test_long_message() -> i64 {
    # Test a message that spans multiple 64-byte blocks
    # Using 100-byte message: "a" repeated 100 times
    data := malloc(101)
    i := mut 0
    L i < 100 {
        store_byte(data + i, 97)  # 'a'
        i = i + 1
    }
    store_byte(data + 100, 0)

    hash := sha256_hash(data, 100)
    hex := sha256_hex(hash)

    # SHA-256 of 100 'a's
    # = cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0
    result := hex_equal(hex, "cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0")

    free(data)
    free(hash)
    free(hex)

    print_test_result("test_long_message", result)
}

# ============================================================================
# Test 9: Single byte message
# ============================================================================

F test_single_byte() -> i64 {
    # SHA-256("a") = ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb
    data := str_to_ptr("a")
    hash := sha256_hash(data, 1)
    hex := sha256_hex(hash)

    result := hex_equal(hex, "ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb")

    free(hash)
    free(hex)

    print_test_result("test_single_byte", result)
}

# ============================================================================
# Test 10: Boundary case - 55 bytes (just before padding length field)
# ============================================================================

F test_55_bytes() -> i64 {
    # Test 55-byte message (fits in one block with padding and length)
    data := malloc(56)
    i := mut 0
    L i < 55 {
        store_byte(data + i, 65)  # 'A'
        i = i + 1
    }
    store_byte(data + 55, 0)

    hash := sha256_hash(data, 55)
    hex := sha256_hex(hash)

    # SHA-256 of 55 'A's
    # = 9f4390f8d30c2dd92ec9f095b65e2b9ae9b0a925a5258e241c9f1e910f734318
    result := hex_equal(hex, "9f4390f8d30c2dd92ec9f095b65e2b9ae9b0a925a5258e241c9f1e910f734318")

    free(data)
    free(hash)
    free(hex)

    print_test_result("test_55_bytes", result)
}

# ============================================================================
# Main - Run all tests
# ============================================================================

F main() -> i64 {
    print_str("\n=== SHA-256 Test Suite ===\n\n")

    passed := mut 0
    total := 10

    passed = passed + test_empty_string()
    passed = passed + test_abc()
    passed = passed + test_hello()
    passed = passed + test_quick_fox()
    passed = passed + test_multiple_updates()
    passed = passed + test_hex_format()
    passed = passed + test_different_inputs()
    passed = passed + test_long_message()
    passed = passed + test_single_byte()
    passed = passed + test_55_bytes()

    print_str("\n=== Results ===\n")
    print_str("Passed: ")
    print_i64(passed)
    print_str(" / ")
    print_i64(total)
    print_str("\n")

    I passed == total {
        print_str("All tests passed!\n")
        R 0
    } E {
        print_str("Some tests failed.\n")
        R 1
    }
}
