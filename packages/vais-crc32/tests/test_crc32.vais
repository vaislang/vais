# CRC32 Test Suite
# Tests both IEEE and Castagnoli variants with known test vectors

# ============================================================================
# CRC32 Library Functions (inlined for testing)
# ============================================================================

# Generate CRC32 lookup table (IEEE polynomial)
F crc32_make_table() -> i64 {
    table := malloc(2048)  # 256 entries * 8 bytes
    idx := mut 0

    L idx < 256 {
        crc := mut idx
        bit := mut 0

        L bit < 8 {
            I (crc & 1) == 1 {
                crc = ((crc >> 1) & 2147483647) ^ 3988292384  # 0xEDB88320
            } E {
                crc = (crc >> 1) & 2147483647
            }
            bit = bit + 1
        }

        store_i64(table + (idx * 8), crc & 4294967295)
        idx = idx + 1
    }

    table
}

# Update CRC32 state with data buffer (IEEE)
F crc32_update(table: i64, state: i64, data: i64, len: i64) -> i64 {
    crc := mut state
    idx := mut 0

    L idx < len {
        byte_val := load_byte(data + idx)
        table_idx := (crc ^ byte_val) & 255
        table_offset := table + (table_idx * 8)
        table_val := load_i64(table_offset)
        crc = (((crc >> 8) & 16777215) ^ table_val) & 4294967295
        idx = idx + 1
    }

    crc & 4294967295
}

# Finalize CRC32 (XOR with 0xFFFFFFFF)
F crc32_finalize(state: i64) -> i64 {
    (state ^ 4294967295) & 4294967295
}

# Generate CRC32C lookup table (Castagnoli polynomial)
F crc32c_make_table() -> i64 {
    table := malloc(2048)  # 256 entries * 8 bytes
    idx := mut 0

    L idx < 256 {
        crc := mut idx
        bit := mut 0

        L bit < 8 {
            I (crc & 1) == 1 {
                crc = ((crc >> 1) & 2147483647) ^ 2197175160  # 0x82F63B78
            } E {
                crc = (crc >> 1) & 2147483647
            }
            bit = bit + 1
        }

        store_i64(table + (idx * 8), crc & 4294967295)
        idx = idx + 1
    }

    table
}

# Update CRC32C state with data buffer (Castagnoli)
F crc32c_update(table: i64, state: i64, data: i64, len: i64) -> i64 {
    crc := mut state
    idx := mut 0

    L idx < len {
        byte_val := load_byte(data + idx)
        table_idx := (crc ^ byte_val) & 255
        table_offset := table + (table_idx * 8)
        table_val := load_i64(table_offset)
        crc = (((crc >> 8) & 16777215) ^ table_val) & 4294967295
        idx = idx + 1
    }

    crc & 4294967295
}

# Finalize CRC32C (XOR with 0xFFFFFFFF)
F crc32c_finalize(state: i64) -> i64 {
    (state ^ 4294967295) & 4294967295
}

# One-shot CRC32 IEEE computation
F crc32(data: i64, len: i64) -> i64 {
    table := crc32_make_table()
    state := crc32_update(table, 4294967295, data, len)
    result := crc32_finalize(state)
    free(table)
    result
}

# One-shot CRC32C Castagnoli computation
F crc32c(data: i64, len: i64) -> i64 {
    table := crc32c_make_table()
    state := crc32c_update(table, 4294967295, data, len)
    result := crc32c_finalize(state)
    free(table)
    result
}

# ============================================================================
# Test helpers
# ============================================================================

# Print i64 in decimal (helper for test output)
F my_print_i64(val: i64) -> i64 {
    I val == 0 {
        putchar(48)  # '0'
        R 0
    }

    I val < 0 {
        putchar(45)  # '-'
        my_print_i64(0 - val)
        R 0
    }

    # Simple approach: recursively print
    I val >= 10 {
        my_print_i64(val / 10)
    }
    putchar(48 + (val % 10))
    0
}

# Assert equality helper
F assert_eq(actual: i64, expected: i64) -> i64 {
    I actual == expected {
        puts("  PASS")
        putchar(10)
        1
    } E {
        puts("  FAIL - expected ")
        my_print_i64(expected)
        puts(", got ")
        my_print_i64(actual)
        putchar(10)
        0
    }
}

# ============================================================================
# Test cases
# ============================================================================

# Test: CRC32 table generation
F test_crc32_table_generation() -> i64 {
    puts("\n[test_crc32_table_generation]")

    table := crc32_make_table()

    # Verify first entry
    entry0 := load_i64(table)

    # Verify entry exists and is in valid range
    valid := I entry0 >= 0 { I entry0 <= 4294967295 { 1 } E { 0 } } E { 0 }

    free(table)

    I valid == 1 {
        puts("  PASS: table generation")
        putchar(10)
        1
    } E {
        puts("  FAIL: table generation")
        putchar(10)
        0
    }
}

# Test: CRC32 of empty string (should be 0)
F test_crc32_empty() -> i64 {
    puts("\n[test_crc32_empty]")

    table := crc32_make_table()
    result := crc32_finalize(4294967295)
    free(table)

    assert_eq(result, 0)
}

# Test: CRC32 standard check value "123456789" -> 0xCBF43926 (3421780262)
F test_crc32_check_value() -> i64 {
    puts("\n[test_crc32_check_value]")

    len := strlen("123456789")
    p := str_to_ptr("123456789")
    result := crc32(p, len)
    assert_eq(result, 3421780262)
}

# Test: Incremental CRC32 update
F test_crc32_incremental() -> i64 {
    puts("\n[test_crc32_incremental]")

    # Compute "123456789" incrementally
    table := crc32_make_table()
    state := mut 4294967295

    p1 := str_to_ptr("123")
    len1 := strlen("123")
    state = crc32_update(table, state, p1, len1)

    p2 := str_to_ptr("456")
    len2 := strlen("456")
    state = crc32_update(table, state, p2, len2)

    p3 := str_to_ptr("789")
    len3 := strlen("789")
    state = crc32_update(table, state, p3, len3)

    result := crc32_finalize(state)
    free(table)

    assert_eq(result, 3421780262)
}

# Test: CRC32C standard check value "123456789" -> 0xE3069283 (3808858755)
F test_crc32c_check_value() -> i64 {
    puts("\n[test_crc32c_check_value]")

    len := strlen("123456789")
    p := str_to_ptr("123456789")
    result := crc32c(p, len)
    assert_eq(result, 3808858755)
}

# Test: CRC32 convenience function
F test_crc32_hello() -> i64 {
    puts("\n[test_crc32_hello]")

    # "Hello" - compute expected value
    len := strlen("Hello")
    p := str_to_ptr("Hello")
    result := crc32(p, len)

    # Verify it's a valid CRC (non-zero for non-empty string)
    valid := I result > 0 { 1 } E { 0 }

    I valid == 1 {
        puts("  PASS: crc32 Hello (")
        my_print_i64(result)
        puts(")")
        putchar(10)
        1
    } E {
        puts("  FAIL: crc32 Hello")
        putchar(10)
        0
    }
}

# Test: CRC32 reset and reuse
F test_crc32_reset() -> i64 {
    puts("\n[test_crc32_reset]")

    table := crc32_make_table()

    # First computation
    p1 := str_to_ptr("test")
    len1 := strlen("test")
    state1 := crc32_update(table, 4294967295, p1, len1)
    result1 := crc32_finalize(state1)

    # Reset and compute again
    state2 := crc32_update(table, 4294967295, p1, len1)
    result2 := crc32_finalize(state2)

    free(table)

    assert_eq(result1, result2)
}

# ============================================================================
# Main test runner
# ============================================================================

F main() -> i64 {
    puts("===========================================")
    puts("\n  CRC32 Test Suite")
    puts("\n===========================================")

    total := mut 0
    total = total + test_crc32_table_generation()
    total = total + test_crc32_empty()
    total = total + test_crc32_check_value()
    total = total + test_crc32_incremental()
    total = total + test_crc32c_check_value()
    total = total + test_crc32_hello()
    total = total + test_crc32_reset()

    puts("\n===========================================")
    puts("\n  Total passed: ")
    my_print_i64(total)
    puts(" / 7")
    puts("\n===========================================")
    putchar(10)

    0
}

# ============================================================================
# Extern declarations
# ============================================================================

X F puts(s: str) -> i64
X F putchar(c: i64) -> i64
X F strlen(s: str) -> i64
X F str_to_ptr(s: str) -> i64
X F malloc(size: i64) -> i64
X F free(ptr: i64) -> i64
X F load_byte(ptr: i64) -> i64
X F load_i64(ptr: i64) -> i64
X F store_i64(ptr: i64, val: i64) -> i64
