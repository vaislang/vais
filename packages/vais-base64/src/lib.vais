# Base64 Encoding/Decoding Library
# RFC 4648 compliant implementation with standard and URL-safe variants

# ============================================================================
# Base64 Standard Alphabet (RFC 4648 Table 1)
# ============================================================================
# A-Z (0-25), a-z (26-51), 0-9 (52-61), + (62), / (63), = (padding)

# Encode a 6-bit value to Base64 character (standard alphabet)
F base64_encode_char(idx: i64) -> i64 {
    I idx < 26 {
        # A-Z (65-90)
        65 + idx
    } E {
        I idx < 52 {
            # a-z (97-122)
            97 + (idx - 26)
        } E {
            I idx < 62 {
                # 0-9 (48-57)
                48 + (idx - 52)
            } E {
                I idx == 62 {
                    # +
                    43
                } E {
                    # / (idx == 63)
                    47
                }
            }
        }
    }
}

# Encode a 6-bit value to Base64URL character (URL-safe alphabet)
F base64url_encode_char(idx: i64) -> i64 {
    I idx < 26 {
        # A-Z (65-90)
        65 + idx
    } E {
        I idx < 52 {
            # a-z (97-122)
            97 + (idx - 26)
        } E {
            I idx < 62 {
                # 0-9 (48-57)
                48 + (idx - 52)
            } E {
                I idx == 62 {
                    # - (minus)
                    45
                } E {
                    # _ (underscore, idx == 63)
                    95
                }
            }
        }
    }
}

# Decode a Base64 character to 6-bit value (standard alphabet)
# Returns -1 for invalid characters
F base64_decode_char(c: i64) -> i64 {
    I c >= 65 {
        I c <= 90 {
            # A-Z -> 0-25
            c - 65
        } E {
            I c >= 97 {
                I c <= 122 {
                    # a-z -> 26-51
                    c - 97 + 26
                } E {
                    -1
                }
            } E {
                I c >= 48 {
                    I c <= 57 {
                        # 0-9 -> 52-61
                        c - 48 + 52
                    } E {
                        I c == 43 {
                            # + -> 62
                            62
                        } E {
                            I c == 47 {
                                # / -> 63
                                63
                            } E {
                                -1
                            }
                        }
                    }
                } E {
                    -1
                }
            }
        }
    } E {
        I c >= 48 {
            I c <= 57 {
                # 0-9 -> 52-61
                c - 48 + 52
            } E {
                I c == 43 {
                    # + -> 62
                    62
                } E {
                    I c == 47 {
                        # / -> 63
                        63
                    } E {
                        -1
                    }
                }
            }
        } E {
            -1
        }
    }
}

# Decode a Base64URL character to 6-bit value (URL-safe alphabet)
# Returns -1 for invalid characters
F base64url_decode_char(c: i64) -> i64 {
    I c >= 65 {
        I c <= 90 {
            # A-Z -> 0-25
            c - 65
        } E {
            I c >= 97 {
                I c <= 122 {
                    # a-z -> 26-51
                    c - 97 + 26
                } E {
                    -1
                }
            } E {
                I c >= 48 {
                    I c <= 57 {
                        # 0-9 -> 52-61
                        c - 48 + 52
                    } E {
                        I c == 45 {
                            # - -> 62
                            62
                        } E {
                            I c == 95 {
                                # _ -> 63
                                63
                            } E {
                                -1
                            }
                        }
                    }
                } E {
                    -1
                }
            }
        }
    } E {
        I c >= 48 {
            I c <= 57 {
                # 0-9 -> 52-61
                c - 48 + 52
            } E {
                I c == 45 {
                    # - -> 62
                    62
                } E {
                    I c == 95 {
                        # _ -> 63
                        63
                    } E {
                        -1
                    }
                }
            }
        } E {
            -1
        }
    }
}

# ============================================================================
# Base64 Standard Encoding
# ============================================================================

# Encode binary data to Base64 string
# data: pointer to input bytes
# len: length of input data
# Returns: pointer to null-terminated Base64 string (caller must free)
F base64_encode(data: i64, len: i64) -> i64 {
    # Calculate output size: (len / 3) * 4, rounded up, plus null terminator
    out_len := ((len + 2) / 3) * 4
    out := malloc(out_len + 1)

    in_idx := mut 0
    out_idx := mut 0

    # Process complete 3-byte groups
    L in_idx + 2 < len {
        # Read 3 bytes
        b0 := load_byte(data + in_idx)
        b1 := load_byte(data + in_idx + 1)
        b2 := load_byte(data + in_idx + 2)

        # Convert to 4 Base64 chars
        c0 := base64_encode_char((b0 >> 2) & 63)
        c1 := base64_encode_char(((b0 << 4) | (b1 >> 4)) & 63)
        c2 := base64_encode_char(((b1 << 2) | (b2 >> 6)) & 63)
        c3 := base64_encode_char(b2 & 63)

        store_byte(out + out_idx, c0)
        store_byte(out + out_idx + 1, c1)
        store_byte(out + out_idx + 2, c2)
        store_byte(out + out_idx + 3, c3)

        in_idx = in_idx + 3
        out_idx = out_idx + 4
    }

    # Handle remaining bytes with padding
    remaining := len - in_idx

    I remaining == 1 {
        # 1 byte remaining -> 2 chars + 2 padding
        b0 := load_byte(data + in_idx)

        c0 := base64_encode_char((b0 >> 2) & 63)
        c1 := base64_encode_char((b0 << 4) & 63)

        store_byte(out + out_idx, c0)
        store_byte(out + out_idx + 1, c1)
        store_byte(out + out_idx + 2, 61)  # '='
        store_byte(out + out_idx + 3, 61)  # '='

        out_idx = out_idx + 4
    } E {
        I remaining == 2 {
            # 2 bytes remaining -> 3 chars + 1 padding
            b0 := load_byte(data + in_idx)
            b1 := load_byte(data + in_idx + 1)

            c0 := base64_encode_char((b0 >> 2) & 63)
            c1 := base64_encode_char(((b0 << 4) | (b1 >> 4)) & 63)
            c2 := base64_encode_char((b1 << 2) & 63)

            store_byte(out + out_idx, c0)
            store_byte(out + out_idx + 1, c1)
            store_byte(out + out_idx + 2, c2)
            store_byte(out + out_idx + 3, 61)  # '='

            out_idx = out_idx + 4
        } E {
            # remaining == 0, no action needed
            0
        }
    }

    # Null terminate
    store_byte(out + out_idx, 0)

    out
}

# ============================================================================
# Base64 Standard Decoding
# ============================================================================

# Decode Base64 string to binary data
# encoded: pointer to Base64 string
# encoded_len: length of Base64 string
# Returns: pointer to struct {data_ptr: i64, data_len: i64} (caller must free both)
F base64_decode(encoded: i64, encoded_len: i64) -> i64 {
    # Calculate maximum output size (may be less due to padding)
    max_out_len := (encoded_len / 4) * 3
    out := malloc(max_out_len)

    # Allocate result struct {data_ptr, data_len}
    result := malloc(16)

    in_idx := mut 0
    out_idx := mut 0

    # Process 4-character groups
    L in_idx + 3 < encoded_len {
        # Read 4 Base64 chars
        c0 := load_byte(encoded + in_idx)
        c1 := load_byte(encoded + in_idx + 1)
        c2 := load_byte(encoded + in_idx + 2)
        c3 := load_byte(encoded + in_idx + 3)

        # Decode to 6-bit values
        v0 := base64_decode_char(c0)
        v1 := base64_decode_char(c1)
        v2 := base64_decode_char(c2)
        v3 := base64_decode_char(c3)

        # Convert to 3 bytes
        I c2 == 61 {
            # Two padding chars: only 1 byte of output
            b0 := ((v0 << 2) | (v1 >> 4)) & 255
            store_byte(out + out_idx, b0)
            out_idx = out_idx + 1
        } E {
            I c3 == 61 {
                # One padding char: 2 bytes of output
                b0 := ((v0 << 2) | (v1 >> 4)) & 255
                b1 := ((v1 << 4) | (v2 >> 2)) & 255
                store_byte(out + out_idx, b0)
                store_byte(out + out_idx + 1, b1)
                out_idx = out_idx + 2
            } E {
                # No padding: 3 bytes of output
                b0 := ((v0 << 2) | (v1 >> 4)) & 255
                b1 := ((v1 << 4) | (v2 >> 2)) & 255
                b2 := ((v2 << 6) | v3) & 255
                store_byte(out + out_idx, b0)
                store_byte(out + out_idx + 1, b1)
                store_byte(out + out_idx + 2, b2)
                out_idx = out_idx + 3
            }
        }

        in_idx = in_idx + 4
    }

    # Store result struct
    store_i64(result, out)
    store_i64(result + 8, out_idx)

    result
}

# ============================================================================
# Base64URL (URL-safe) Encoding
# ============================================================================

# Encode binary data to Base64URL string (RFC 4648 Section 5)
# Uses - and _ instead of + and / for URL-safe encoding
F base64url_encode(data: i64, len: i64) -> i64 {
    # Calculate output size: (len / 3) * 4, rounded up, plus null terminator
    out_len := ((len + 2) / 3) * 4
    out := malloc(out_len + 1)

    in_idx := mut 0
    out_idx := mut 0

    # Process complete 3-byte groups
    L in_idx + 2 < len {
        # Read 3 bytes
        b0 := load_byte(data + in_idx)
        b1 := load_byte(data + in_idx + 1)
        b2 := load_byte(data + in_idx + 2)

        # Convert to 4 Base64URL chars
        c0 := base64url_encode_char((b0 >> 2) & 63)
        c1 := base64url_encode_char(((b0 << 4) | (b1 >> 4)) & 63)
        c2 := base64url_encode_char(((b1 << 2) | (b2 >> 6)) & 63)
        c3 := base64url_encode_char(b2 & 63)

        store_byte(out + out_idx, c0)
        store_byte(out + out_idx + 1, c1)
        store_byte(out + out_idx + 2, c2)
        store_byte(out + out_idx + 3, c3)

        in_idx = in_idx + 3
        out_idx = out_idx + 4
    }

    # Handle remaining bytes with padding
    remaining := len - in_idx

    I remaining == 1 {
        # 1 byte remaining -> 2 chars + 2 padding
        b0 := load_byte(data + in_idx)

        c0 := base64url_encode_char((b0 >> 2) & 63)
        c1 := base64url_encode_char((b0 << 4) & 63)

        store_byte(out + out_idx, c0)
        store_byte(out + out_idx + 1, c1)
        store_byte(out + out_idx + 2, 61)  # '='
        store_byte(out + out_idx + 3, 61)  # '='

        out_idx = out_idx + 4
    } E {
        I remaining == 2 {
            # 2 bytes remaining -> 3 chars + 1 padding
            b0 := load_byte(data + in_idx)
            b1 := load_byte(data + in_idx + 1)

            c0 := base64url_encode_char((b0 >> 2) & 63)
            c1 := base64url_encode_char(((b0 << 4) | (b1 >> 4)) & 63)
            c2 := base64url_encode_char((b1 << 2) & 63)

            store_byte(out + out_idx, c0)
            store_byte(out + out_idx + 1, c1)
            store_byte(out + out_idx + 2, c2)
            store_byte(out + out_idx + 3, 61)  # '='

            out_idx = out_idx + 4
        } E {
            # remaining == 0, no action needed
            0
        }
    }

    # Null terminate
    store_byte(out + out_idx, 0)

    out
}

# ============================================================================
# Base64URL (URL-safe) Decoding
# ============================================================================

# Decode Base64URL string to binary data
F base64url_decode(encoded: i64, encoded_len: i64) -> i64 {
    # Calculate maximum output size (may be less due to padding)
    max_out_len := (encoded_len / 4) * 3
    out := malloc(max_out_len)

    # Allocate result struct {data_ptr, data_len}
    result := malloc(16)

    in_idx := mut 0
    out_idx := mut 0

    # Process 4-character groups
    L in_idx + 3 < encoded_len {
        # Read 4 Base64URL chars
        c0 := load_byte(encoded + in_idx)
        c1 := load_byte(encoded + in_idx + 1)
        c2 := load_byte(encoded + in_idx + 2)
        c3 := load_byte(encoded + in_idx + 3)

        # Decode to 6-bit values
        v0 := base64url_decode_char(c0)
        v1 := base64url_decode_char(c1)
        v2 := base64url_decode_char(c2)
        v3 := base64url_decode_char(c3)

        # Convert to 3 bytes
        I c2 == 61 {
            # Two padding chars: only 1 byte of output
            b0 := ((v0 << 2) | (v1 >> 4)) & 255
            store_byte(out + out_idx, b0)
            out_idx = out_idx + 1
        } E {
            I c3 == 61 {
                # One padding char: 2 bytes of output
                b0 := ((v0 << 2) | (v1 >> 4)) & 255
                b1 := ((v1 << 4) | (v2 >> 2)) & 255
                store_byte(out + out_idx, b0)
                store_byte(out + out_idx + 1, b1)
                out_idx = out_idx + 2
            } E {
                # No padding: 3 bytes of output
                b0 := ((v0 << 2) | (v1 >> 4)) & 255
                b1 := ((v1 << 4) | (v2 >> 2)) & 255
                b2 := ((v2 << 6) | v3) & 255
                store_byte(out + out_idx, b0)
                store_byte(out + out_idx + 1, b1)
                store_byte(out + out_idx + 2, b2)
                out_idx = out_idx + 3
            }
        }

        in_idx = in_idx + 4
    }

    # Store result struct
    store_i64(result, out)
    store_i64(result + 8, out_idx)

    result
}

# ============================================================================
# Extern declarations
# ============================================================================

X F malloc(size: i64) -> i64
X F free(ptr: i64) -> i64
X F strlen(s: str) -> i64
X F str_to_ptr(s: str) -> i64
X F load_byte(ptr: i64) -> i64
X F store_byte(ptr: i64, val: i64) -> i64
X F load_i64(ptr: i64) -> i64
X F store_i64(ptr: i64, val: i64) -> i64
X F memcpy(dest: i64, src: i64, n: i64) -> i64
X F memset(dest: i64, val: i64, n: i64) -> i64
X F print_i64(val: i64) -> i64
X F print_str(s: str) -> i64
