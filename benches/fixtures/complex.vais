# Complex benchmark - mixed features for realistic workload

S Node {
    value: i64,
    left_val: i64,
    right_val: i64
}

E TreeResult {
    Found(i64),
    NotFound
}

F factorial(n: i64)->i64 = n <= 1 ? 1 : n * @(n - 1)

F gcd(a: i64, b: i64)->i64 = b == 0 ? a : @(b, a % b)

F is_prime(n: i64)->bool =
    n <= 1 ? false :
    n <= 3 ? true :
    n % 2 == 0 ? false :
    check_prime_loop(n, 3)

F check_prime_loop(n: i64, i: i64)->bool =
    i * i > n ? true :
    n % i == 0 ? false :
    @(n, i + 2)

F count_primes_helper(limit: i64, i: i64, count: i64)->i64 =
    i > limit ? count :
    is_prime(i) ? @(limit, i + 1, count + 1) :
    @(limit, i + 1, count)

F count_primes(limit: i64)->i64 = count_primes_helper(limit, 2, 0)

F power(base: i64, exp: i64)->i64 =
    exp == 0 ? 1 :
    exp % 2 == 0 ? power(base * base, exp / 2) :
    base * @(base, exp - 1)

F sum_digits(n: i64)->i64 =
    n < 10 ? n : n % 10 + @(n / 10)

F collatz_steps(n: i64)->i64 = collatz_helper(n, 0)

F collatz_helper(n: i64, steps: i64)->i64 =
    n == 1 ? steps :
    n % 2 == 0 ? @(n / 2, steps + 1) :
    @(3 * n + 1, steps + 1)

F main()->i64 =
    factorial(10) +
    gcd(48, 18) +
    count_primes(100) +
    power(2, 10) +
    sum_digits(12345) +
    collatz_steps(27)
