//! WebGPU WGSL code generator
//!
//! Generates WGSL (WebGPU Shading Language) code from Vais AST for browser-based GPU computing.

use vais_ast::{Module, Item, Stmt, Expr, Type, Function, FunctionBody};
use crate::{GpuError, GpuResult, GpuKernel, GpuType};
use crate::common::{binary_op_str, unary_op_str, GpuBuiltins};

/// Generate WGSL code from a Vais module
pub fn generate(module: &Module, kernels: &mut Vec<GpuKernel>) -> GpuResult<String> {
    let mut generator = WgslGenerator::new();
    generator.generate_module(module, kernels)
}

struct WgslGenerator {
    output: String,
    indent_level: usize,
    binding_counter: u32,
}

impl WgslGenerator {
    fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
            binding_counter: 0,
        }
    }

    fn generate_module(&mut self, module: &Module, kernels: &mut Vec<GpuKernel>) -> GpuResult<String> {
        // Header
        self.emit_line("// Generated by Vais GPU Compiler");
        self.emit_line("// Target: WebGPU WGSL");
        self.emit_line("");

        // Generate items
        for item in &module.items {
            self.generate_item(&item.node, kernels)?;
        }

        Ok(self.output.clone())
    }

    fn generate_item(&mut self, item: &Item, kernels: &mut Vec<GpuKernel>) -> GpuResult<()> {
        match item {
            Item::Function(func) => {
                let is_kernel = func.attributes.iter().any(|attr| {
                    attr.name == "gpu" || attr.name == "kernel"
                });

                if is_kernel {
                    self.generate_compute_shader(func, kernels)?;
                } else {
                    self.generate_helper_function(func)?;
                }
            }
            Item::Struct(s) => {
                self.generate_struct(&s.name.node, &s.fields)?;
            }
            _ => {}
        }
        Ok(())
    }

    fn generate_compute_shader(
        &mut self,
        func: &Function,
        kernels: &mut Vec<GpuKernel>,
    ) -> GpuResult<()> {
        let name = &func.name.node;

        // Generate bindings for parameters
        let mut param_types: Vec<(String, GpuType)> = Vec::new();

        for param in &func.params {
            let binding = self.binding_counter;
            self.binding_counter += 1;

            let wgsl_type = self.type_to_wgsl(&param.ty.node);

            // Generate storage buffer binding
            self.emit_line(&format!(
                "@group(0) @binding({}) var<storage, read_write> {}: {};",
                binding, param.name.node, wgsl_type
            ));

            param_types.push((param.name.node.clone(), GpuType::Ptr(Box::new(GpuType::F64))));
        }

        self.emit_line("");

        // Compute shader entry point
        self.emit_line("@compute @workgroup_size(256, 1, 1)");
        self.emit(&format!("fn {}(", name));
        self.emit("@builtin(global_invocation_id) global_id: vec3<u32>");
        self.emit_line(") {");
        self.indent_level += 1;

        // Add common variables
        self.emit_indent();
        self.emit_line("let idx = global_id.x;");
        self.emit_line("");

        self.generate_function_body(&func.body)?;

        self.indent_level -= 1;
        self.emit_line("}");
        self.emit_line("");

        kernels.push(GpuKernel {
            name: name.to_string(),
            params: param_types,
            shared_memory: 0,
            block_size: (256, 1, 1),
        });

        Ok(())
    }

    fn generate_helper_function(&mut self, func: &Function) -> GpuResult<()> {
        let name = &func.name.node;

        let ret_str = func.ret_type
            .as_ref()
            .map(|t| format!(" -> {}", self.type_to_wgsl(&t.node)))
            .unwrap_or_default();

        self.emit(&format!("fn {}(", name));

        for (i, param) in func.params.iter().enumerate() {
            if i > 0 {
                self.emit(", ");
            }
            self.emit(&format!("{}: {}", param.name.node, self.type_to_wgsl(&param.ty.node)));
        }

        self.emit(&format!("){} {{", ret_str));
        self.emit_line("");
        self.indent_level += 1;

        if func.ret_type.is_some() {
            self.emit_indent();
            self.emit("return ");
            match &func.body {
                FunctionBody::Expr(expr) => {
                    self.generate_expr(&expr.node)?;
                }
                FunctionBody::Block(stmts) => {
                    for stmt in stmts {
                        self.generate_stmt(&stmt.node)?;
                    }
                }
            }
            self.emit_line(";");
        } else {
            self.generate_function_body(&func.body)?;
        }

        self.indent_level -= 1;
        self.emit_line("}");
        self.emit_line("");

        Ok(())
    }

    fn generate_function_body(&mut self, body: &FunctionBody) -> GpuResult<()> {
        match body {
            FunctionBody::Expr(expr) => {
                self.emit_indent();
                self.generate_expr(&expr.node)?;
                self.emit_line(";");
            }
            FunctionBody::Block(stmts) => {
                for stmt in stmts {
                    self.generate_stmt(&stmt.node)?;
                }
            }
        }
        Ok(())
    }

    fn generate_struct(&mut self, name: &str, fields: &[vais_ast::Field]) -> GpuResult<()> {
        self.emit_line(&format!("struct {} {{", name));
        self.indent_level += 1;

        for field in fields {
            self.emit_indent();
            self.emit_line(&format!("{}: {},", field.name.node, self.type_to_wgsl(&field.ty.node)));
        }

        self.indent_level -= 1;
        self.emit_line("}");
        self.emit_line("");

        Ok(())
    }

    fn generate_expr(&mut self, expr: &Expr) -> GpuResult<()> {
        match expr {
            Expr::Int(n) => self.emit(&format!("{}i", n)),
            Expr::Float(f) => self.emit(&format!("{:.6}", f)),
            Expr::Bool(b) => self.emit(if *b { "true" } else { "false" }),
            Expr::Ident(name) => {
                if let Some(builtin) = GpuBuiltins::wgsl_builtin(name) {
                    self.emit(builtin);
                } else {
                    self.emit(name);
                }
            }
            Expr::Binary { op, left, right } => {
                self.emit("(");
                self.generate_expr(&left.node)?;
                self.emit(&format!(" {} ", binary_op_str(op)));
                self.generate_expr(&right.node)?;
                self.emit(")");
            }
            Expr::Unary { op, expr } => {
                self.emit(unary_op_str(op));
                self.generate_expr(&expr.node)?;
            }
            Expr::Call { func, args } => {
                if let Expr::Ident(name) = &func.node {
                    if let Some(builtin) = GpuBuiltins::wgsl_builtin(name) {
                        self.emit(builtin);
                        if !builtin.contains('.') && !builtin.ends_with(')') {
                            self.emit("(");
                            for (i, arg) in args.iter().enumerate() {
                                if i > 0 {
                                    self.emit(", ");
                                }
                                self.generate_expr(&arg.node)?;
                            }
                            self.emit(")");
                        }
                        return Ok(());
                    }
                }

                self.generate_expr(&func.node)?;
                self.emit("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.generate_expr(&arg.node)?;
                }
                self.emit(")");
            }
            Expr::Index { expr, index } => {
                self.generate_expr(&expr.node)?;
                self.emit("[");
                self.generate_expr(&index.node)?;
                self.emit("]");
            }
            Expr::Field { expr, field } => {
                self.generate_expr(&expr.node)?;
                self.emit(&format!(".{}", field.node));
            }
            Expr::If { cond, then, else_ } => {
                // WGSL uses select() for ternary-like operations
                self.emit("select(");
                if let Some(else_branch) = else_ {
                    self.generate_if_else_value(else_branch)?;
                } else {
                    self.emit("0");
                }
                self.emit(", ");
                // For simple expressions in then branch
                if then.len() == 1 {
                    if let Stmt::Expr(expr) = &then[0].node {
                        self.generate_expr(&expr.node)?;
                    } else {
                        self.emit("0");
                    }
                } else {
                    self.emit("0");
                }
                self.emit(", ");
                self.generate_expr(&cond.node)?;
                self.emit(")");
            }
            Expr::Block(stmts) => {
                for stmt in stmts {
                    self.generate_stmt(&stmt.node)?;
                }
            }
            Expr::Assign { target, value } => {
                self.emit_indent();
                self.generate_expr(&target.node)?;
                self.emit(" = ");
                self.generate_expr(&value.node)?;
                self.emit_line(";");
            }
            Expr::Loop { body, .. } => {
                self.emit_indent();
                self.emit_line("loop {");
                self.indent_level += 1;
                for stmt in body {
                    self.generate_stmt(&stmt.node)?;
                }
                self.indent_level -= 1;
                self.emit_indent();
                self.emit_line("}");
            }
            _ => {
                return Err(GpuError::UnsupportedOperation(format!(
                    "Expression not supported in WGSL: {:?}",
                    std::mem::discriminant(expr)
                )));
            }
        }
        Ok(())
    }

    fn generate_if_else_value(&mut self, else_branch: &vais_ast::IfElse) -> GpuResult<()> {
        match else_branch {
            vais_ast::IfElse::Else(stmts) => {
                if stmts.len() == 1 {
                    if let Stmt::Expr(expr) = &stmts[0].node {
                        self.generate_expr(&expr.node)?;
                    } else {
                        self.emit("0");
                    }
                } else {
                    self.emit("0");
                }
            }
            _ => {
                self.emit("0");
            }
        }
        Ok(())
    }

    fn generate_stmt(&mut self, stmt: &Stmt) -> GpuResult<()> {
        match stmt {
            Stmt::Let { name, ty, value, .. } => {
                self.emit_indent();
                if let Some(t) = ty {
                    self.emit(&format!("var {}: {} = ", name.node, self.type_to_wgsl(&t.node)));
                } else {
                    self.emit(&format!("var {} = ", name.node));
                }
                self.generate_expr(&value.node)?;
                self.emit_line(";");
            }
            Stmt::Expr(expr) => {
                self.emit_indent();
                self.generate_expr(&expr.node)?;
                self.emit_line(";");
            }
            Stmt::Return(expr) => {
                self.emit_indent();
                self.emit("return");
                if let Some(e) = expr {
                    self.emit(" ");
                    self.generate_expr(&e.node)?;
                }
                self.emit_line(";");
            }
            Stmt::Break(_) => {
                self.emit_indent();
                self.emit_line("break;");
            }
            Stmt::Continue => {
                self.emit_indent();
                self.emit_line("continue;");
            }
            _ => {}
        }
        Ok(())
    }

    fn type_to_wgsl(&self, ty: &Type) -> String {
        match ty {
            Type::Named { name, .. } => {
                match name.as_str() {
                    "i64" => "i32".to_string(),  // WGSL doesn't have i64 widely
                    "i32" => "i32".to_string(),
                    "u32" => "u32".to_string(),
                    "f64" => "f32".to_string(),  // WGSL f64 is limited
                    "f32" => "f32".to_string(),
                    "bool" => "bool".to_string(),
                    "unit" | "()" => "".to_string(),
                    _ => name.clone(),
                }
            }
            Type::Pointer(inner) => {
                format!("ptr<storage, {}>", self.type_to_wgsl(&inner.node))
            }
            Type::ConstArray { element, size } => {
                format!("array<{}, {}>", self.type_to_wgsl(&element.node), size)
            }
            _ => "i32".to_string(),
        }
    }

    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn emit_line(&mut self, s: &str) {
        self.output.push_str(s);
        self.output.push('\n');
    }

    fn emit_indent(&mut self) {
        for _ in 0..self.indent_level {
            self.output.push_str("    ");
        }
    }
}

/// Generate JavaScript/TypeScript host code for WebGPU
pub fn generate_host_code(kernels: &[GpuKernel], wgsl_code: &str) -> String {
    let mut code = String::new();

    code.push_str("// WebGPU Host Code (TypeScript)\n\n");

    // Escape WGSL code for embedding
    let escaped_wgsl = wgsl_code.replace("\\", "\\\\").replace("`", "\\`");

    code.push_str(&format!("const shaderCode = `{}`;\n\n", escaped_wgsl));

    code.push_str("async function initGPU() {\n");
    code.push_str("    const adapter = await navigator.gpu.requestAdapter();\n");
    code.push_str("    if (!adapter) throw new Error('No GPU adapter found');\n");
    code.push_str("    const device = await adapter.requestDevice();\n");
    code.push_str("    return device;\n");
    code.push_str("}\n\n");

    for kernel in kernels {
        code.push_str(&format!("async function run_{}(device: GPUDevice", kernel.name));
        for (pname, _) in &kernel.params {
            code.push_str(&format!(", {}: Float32Array", pname));
        }
        code.push_str(") {\n");

        code.push_str("    const shaderModule = device.createShaderModule({ code: shaderCode });\n");
        code.push_str("    \n");

        // Create buffers
        for (pname, _) in kernel.params.iter() {
            code.push_str(&format!(
                "    const {}Buffer = device.createBuffer({{\n",
                pname
            ));
            code.push_str(&format!("        size: {}.byteLength,\n", pname));
            code.push_str("        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n");
            code.push_str("    });\n");
            code.push_str(&format!(
                "    device.queue.writeBuffer({}Buffer, 0, {});\n",
                pname, pname
            ));
        }

        code.push_str("    \n");
        code.push_str("    const pipeline = device.createComputePipeline({\n");
        code.push_str("        layout: 'auto',\n");
        code.push_str("        compute: {\n");
        code.push_str("            module: shaderModule,\n");
        code.push_str(&format!("            entryPoint: '{}',\n", kernel.name));
        code.push_str("        },\n");
        code.push_str("    });\n");
        code.push_str("    \n");

        // Bind group
        code.push_str("    const bindGroup = device.createBindGroup({\n");
        code.push_str("        layout: pipeline.getBindGroupLayout(0),\n");
        code.push_str("        entries: [\n");
        for (i, (pname, _)) in kernel.params.iter().enumerate() {
            code.push_str(&format!(
                "            {{ binding: {}, resource: {{ buffer: {}Buffer }} }},\n",
                i, pname
            ));
        }
        code.push_str("        ],\n");
        code.push_str("    });\n");
        code.push_str("    \n");

        // Dispatch
        code.push_str("    const commandEncoder = device.createCommandEncoder();\n");
        code.push_str("    const passEncoder = commandEncoder.beginComputePass();\n");
        code.push_str("    passEncoder.setPipeline(pipeline);\n");
        code.push_str("    passEncoder.setBindGroup(0, bindGroup);\n");
        code.push_str(&format!(
            "    passEncoder.dispatchWorkgroups(Math.ceil({}.length / {}));\n",
            kernel.params.first().map(|(n, _)| n.as_str()).unwrap_or("data"),
            kernel.block_size.0
        ));
        code.push_str("    passEncoder.end();\n");
        code.push_str("    device.queue.submit([commandEncoder.finish()]);\n");
        code.push_str("}\n\n");
    }

    code
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wgsl_generator_basic() {
        let gen = WgslGenerator::new();
        assert_eq!(gen.type_to_wgsl(&Type::Named { name: "i32".to_string(), generics: vec![] }), "i32");
        assert_eq!(gen.type_to_wgsl(&Type::Named { name: "f32".to_string(), generics: vec![] }), "f32");
    }
}
