//! CUDA code generator
//!
//! Generates CUDA C code from Vais AST for NVIDIA GPUs.

use vais_ast::{Module, Item, Stmt, Expr, Spanned, Type, Function, FunctionBody};
use crate::{GpuError, GpuResult, GpuKernel, GpuType};
use crate::common::{binary_op_str, unary_op_str, GpuBuiltins};

/// Generate CUDA code from a Vais module
pub fn generate(module: &Module, kernels: &mut Vec<GpuKernel>) -> GpuResult<String> {
    let mut generator = CudaGenerator::new();
    generator.generate_module(module, kernels)
}

struct CudaGenerator {
    output: String,
    indent_level: usize,
}

impl CudaGenerator {
    fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
        }
    }

    fn generate_module(&mut self, module: &Module, kernels: &mut Vec<GpuKernel>) -> GpuResult<String> {
        // Header
        self.emit_line("// Generated by Vais GPU Compiler");
        self.emit_line("// Target: CUDA");
        self.emit_line("");
        self.emit_line("#include <cuda_runtime.h>");
        self.emit_line("#include <stdio.h>");
        self.emit_line("");

        // Generate items
        for item in &module.items {
            self.generate_item(&item.node, kernels)?;
        }

        Ok(self.output.clone())
    }

    fn generate_item(&mut self, item: &Item, kernels: &mut Vec<GpuKernel>) -> GpuResult<()> {
        match item {
            Item::Function(func) => {
                // Check if this is a GPU kernel (has #[gpu] or #[kernel] attribute)
                let is_kernel = func.attributes.iter().any(|attr| {
                    attr.name == "gpu" || attr.name == "kernel"
                });

                if is_kernel {
                    self.generate_kernel(func, kernels)?;
                } else {
                    // Regular device function
                    self.generate_device_function(func)?;
                }
            }
            Item::Struct(s) => {
                self.generate_struct(&s.name.node, &s.fields)?;
            }
            _ => {
                // Skip other items (enums, traits, etc.)
            }
        }
        Ok(())
    }

    fn generate_kernel(
        &mut self,
        func: &Function,
        kernels: &mut Vec<GpuKernel>,
    ) -> GpuResult<()> {
        let name = &func.name.node;

        // Emit kernel function
        self.emit("__global__ void ");
        self.emit(name);
        self.emit("(");

        // Parameters
        let param_types: Vec<(String, GpuType)> = func.params
            .iter()
            .map(|p| (p.name.node.clone(), GpuType::Ptr(Box::new(GpuType::F64))))
            .collect();

        for (i, param) in func.params.iter().enumerate() {
            if i > 0 {
                self.emit(", ");
            }
            self.emit(&format!("{} {}", self.type_to_cuda(&param.ty.node), param.name.node));
        }

        self.emit_line(") {");
        self.indent_level += 1;

        // Generate body
        self.generate_function_body(&func.body)?;

        self.indent_level -= 1;
        self.emit_line("}");
        self.emit_line("");

        // Record kernel metadata
        kernels.push(GpuKernel {
            name: name.to_string(),
            params: param_types,
            shared_memory: 0,
            block_size: (256, 1, 1), // Default
        });

        Ok(())
    }

    fn generate_device_function(&mut self, func: &Function) -> GpuResult<()> {
        let name = &func.name.node;

        let ret_str = func.ret_type
            .as_ref()
            .map(|t| self.type_to_cuda(&t.node))
            .unwrap_or_else(|| "void".to_string());

        self.emit(&format!("__device__ {} {}(", ret_str, name));

        for (i, param) in func.params.iter().enumerate() {
            if i > 0 {
                self.emit(", ");
            }
            self.emit(&format!("{} {}", self.type_to_cuda(&param.ty.node), param.name.node));
        }

        self.emit_line(") {");
        self.indent_level += 1;

        // Generate body
        if func.ret_type.is_some() {
            self.emit_indent();
            self.emit("return ");
            match &func.body {
                FunctionBody::Expr(expr) => {
                    self.generate_expr(&expr.node)?;
                }
                FunctionBody::Block(stmts) => {
                    for stmt in stmts {
                        self.generate_stmt(&stmt.node)?;
                    }
                }
            }
            self.emit_line(";");
        } else {
            self.generate_function_body(&func.body)?;
        }

        self.indent_level -= 1;
        self.emit_line("}");
        self.emit_line("");

        Ok(())
    }

    fn generate_function_body(&mut self, body: &FunctionBody) -> GpuResult<()> {
        match body {
            FunctionBody::Expr(expr) => {
                self.emit_indent();
                self.generate_expr(&expr.node)?;
                self.emit_line(";");
            }
            FunctionBody::Block(stmts) => {
                for stmt in stmts {
                    self.generate_stmt(&stmt.node)?;
                }
            }
        }
        Ok(())
    }

    fn generate_struct(&mut self, name: &str, fields: &[vais_ast::Field]) -> GpuResult<()> {
        self.emit_line(&format!("struct {} {{", name));
        self.indent_level += 1;

        for field in fields {
            self.emit_indent();
            self.emit_line(&format!("{} {};", self.type_to_cuda(&field.ty.node), field.name.node));
        }

        self.indent_level -= 1;
        self.emit_line("};");
        self.emit_line("");

        Ok(())
    }

    fn generate_expr(&mut self, expr: &Expr) -> GpuResult<()> {
        match expr {
            Expr::Int(n) => self.emit(&n.to_string()),
            Expr::Float(f) => self.emit(&format!("{:.6}", f)),
            Expr::Bool(b) => self.emit(if *b { "true" } else { "false" }),
            Expr::Ident(name) => {
                // Check for GPU built-in
                if let Some(builtin) = GpuBuiltins::cuda_builtin(name) {
                    self.emit(builtin);
                } else {
                    self.emit(name);
                }
            }
            Expr::Binary { op, left, right } => {
                self.emit("(");
                self.generate_expr(&left.node)?;
                self.emit(&format!(" {} ", binary_op_str(op)));
                self.generate_expr(&right.node)?;
                self.emit(")");
            }
            Expr::Unary { op, expr } => {
                self.emit(unary_op_str(op));
                self.generate_expr(&expr.node)?;
            }
            Expr::Call { func, args } => {
                // Check if it's a built-in
                if let Expr::Ident(name) = &func.node {
                    if let Some(builtin) = GpuBuiltins::cuda_builtin(name) {
                        self.emit(builtin);
                        if !builtin.contains('.') {
                            // Not a struct member access
                            self.emit("(");
                            for (i, arg) in args.iter().enumerate() {
                                if i > 0 {
                                    self.emit(", ");
                                }
                                self.generate_expr(&arg.node)?;
                            }
                            self.emit(")");
                        }
                        return Ok(());
                    }
                }

                self.generate_expr(&func.node)?;
                self.emit("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.generate_expr(&arg.node)?;
                }
                self.emit(")");
            }
            Expr::Index { expr, index } => {
                self.generate_expr(&expr.node)?;
                self.emit("[");
                self.generate_expr(&index.node)?;
                self.emit("]");
            }
            Expr::Field { expr, field } => {
                self.generate_expr(&expr.node)?;
                self.emit(&format!(".{}", field.node));
            }
            Expr::If { cond, then, else_ } => {
                self.emit_indent();
                self.emit("if (");
                self.generate_expr(&cond.node)?;
                self.emit_line(") {");
                self.indent_level += 1;
                for stmt in then {
                    self.generate_stmt(&stmt.node)?;
                }
                self.indent_level -= 1;
                self.emit_indent();
                if let Some(else_branch) = else_ {
                    self.emit("} else ");
                    self.generate_if_else(else_branch)?;
                } else {
                    self.emit_line("}");
                }
            }
            Expr::Block(stmts) => {
                for stmt in stmts {
                    self.generate_stmt(&stmt.node)?;
                }
            }
            Expr::Assign { target, value } => {
                self.emit_indent();
                self.generate_expr(&target.node)?;
                self.emit(" = ");
                self.generate_expr(&value.node)?;
                self.emit_line(";");
            }
            Expr::Loop { body, .. } => {
                self.emit_indent();
                self.emit_line("while (true) {");
                self.indent_level += 1;
                for stmt in body {
                    self.generate_stmt(&stmt.node)?;
                }
                self.indent_level -= 1;
                self.emit_indent();
                self.emit_line("}");
            }
            Expr::Range { start, end, .. } => {
                // Generate for loop for range
                self.emit_indent();
                self.emit("for (int i = ");
                if let Some(s) = start {
                    self.generate_expr(&s.node)?;
                } else {
                    self.emit("0");
                }
                self.emit("; i < ");
                if let Some(e) = end {
                    self.generate_expr(&e.node)?;
                } else {
                    self.emit("SIZE_MAX");
                }
                self.emit_line("; i++) {");
            }
            _ => {
                return Err(GpuError::UnsupportedOperation(format!(
                    "Expression not supported in CUDA: {:?}",
                    std::mem::discriminant(expr)
                )));
            }
        }
        Ok(())
    }

    fn generate_if_else(&mut self, else_branch: &vais_ast::IfElse) -> GpuResult<()> {
        match else_branch {
            vais_ast::IfElse::ElseIf(cond, then, next) => {
                self.emit("if (");
                self.generate_expr(&cond.node)?;
                self.emit_line(") {");
                self.indent_level += 1;
                for stmt in then {
                    self.generate_stmt(&stmt.node)?;
                }
                self.indent_level -= 1;
                self.emit_indent();
                if let Some(next_else) = next {
                    self.emit("} else ");
                    self.generate_if_else(next_else)?;
                } else {
                    self.emit_line("}");
                }
            }
            vais_ast::IfElse::Else(stmts) => {
                self.emit_line("{");
                self.indent_level += 1;
                for stmt in stmts {
                    self.generate_stmt(&stmt.node)?;
                }
                self.indent_level -= 1;
                self.emit_indent();
                self.emit_line("}");
            }
        }
        Ok(())
    }

    fn generate_stmt(&mut self, stmt: &Stmt) -> GpuResult<()> {
        match stmt {
            Stmt::Let { name, ty, value, .. } => {
                self.emit_indent();
                if let Some(t) = ty {
                    self.emit(&format!("{} {} = ", self.type_to_cuda(&t.node), name.node));
                } else {
                    self.emit(&format!("auto {} = ", name.node));
                }
                self.generate_expr(&value.node)?;
                self.emit_line(";");
            }
            Stmt::Expr(expr) => {
                self.emit_indent();
                self.generate_expr(&expr.node)?;
                self.emit_line(";");
            }
            Stmt::Return(expr) => {
                self.emit_indent();
                self.emit("return");
                if let Some(e) = expr {
                    self.emit(" ");
                    self.generate_expr(&e.node)?;
                }
                self.emit_line(";");
            }
            Stmt::Break(_) => {
                self.emit_indent();
                self.emit_line("break;");
            }
            Stmt::Continue => {
                self.emit_indent();
                self.emit_line("continue;");
            }
            _ => {}
        }
        Ok(())
    }

    fn type_to_cuda(&self, ty: &Type) -> String {
        match ty {
            Type::Named { name, .. } => {
                match name.as_str() {
                    "i64" => "long long".to_string(),
                    "i32" => "int".to_string(),
                    "f64" => "double".to_string(),
                    "f32" => "float".to_string(),
                    "bool" => "bool".to_string(),
                    "unit" | "()" => "void".to_string(),
                    _ => name.clone(),
                }
            }
            Type::Pointer(inner) => format!("{}*", self.type_to_cuda(&inner.node)),
            Type::ConstArray { element, size } => {
                format!("{}[{}]", self.type_to_cuda(&element.node), size)
            }
            _ => "void".to_string(),
        }
    }

    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn emit_line(&mut self, s: &str) {
        self.output.push_str(s);
        self.output.push('\n');
    }

    fn emit_indent(&mut self) {
        for _ in 0..self.indent_level {
            self.output.push_str("    ");
        }
    }
}

/// Generate CUDA host code for launching kernels
pub fn generate_host_code(kernels: &[GpuKernel]) -> String {
    let mut code = String::new();

    code.push_str("// CUDA Host Code\n\n");

    for kernel in kernels {
        code.push_str(&format!(
            "// Launch helper for {}\n",
            kernel.name
        ));
        code.push_str(&format!(
            "void launch_{}(dim3 grid, dim3 block",
            kernel.name
        ));

        for (pname, ptype) in &kernel.params {
            code.push_str(&format!(", {} {}", ptype.cuda_name(), pname));
        }

        code.push_str(") {\n");
        code.push_str(&format!("    {}<<<grid, block>>>(", kernel.name));

        for (i, (pname, _)) in kernel.params.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(pname);
        }

        code.push_str(");\n");
        code.push_str("    cudaDeviceSynchronize();\n");
        code.push_str("}\n\n");
    }

    code
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cuda_generator_basic() {
        let gen = CudaGenerator::new();
        assert_eq!(gen.type_to_cuda(&Type::Named { name: "i64".to_string(), generics: vec![] }), "long long");
        assert_eq!(gen.type_to_cuda(&Type::Named { name: "f32".to_string(), generics: vec![] }), "float");
    }
}
