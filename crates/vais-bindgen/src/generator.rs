use crate::config::BindgenConfig;
use crate::parser::{CDeclaration, CEnum, CFunction, CStruct, CType, CTypedef};
use crate::Result;

/// Generator for Vais FFI code
pub struct Generator<'a> {
    config: &'a BindgenConfig,
}

impl<'a> Generator<'a> {
    pub fn new(config: &'a BindgenConfig) -> Self {
        Self { config }
    }

    pub fn generate(&self, declarations: &[CDeclaration]) -> Result<String> {
        let mut output = String::new();

        // Header comment
        output.push_str("// Auto-generated by vais-bindgen\n");
        output.push_str("// DO NOT EDIT\n\n");

        // External block if library name is specified
        if let Some(lib_name) = self.config.library_name() {
            output.push_str(&format!("extern \"{}\" {{\n\n", lib_name));
        } else {
            output.push_str("extern \"C\" {\n\n");
        }

        // Generate declarations
        for decl in declarations {
            match decl {
                CDeclaration::Function(func) => {
                    output.push_str(&self.generate_function(func));
                    output.push_str("\n\n");
                }
                CDeclaration::Struct(s) => {
                    output.push_str(&self.generate_struct(s));
                    output.push_str("\n\n");
                }
                CDeclaration::Typedef(t) => {
                    output.push_str(&self.generate_typedef(t));
                    output.push_str("\n\n");
                }
                CDeclaration::Enum(e) => {
                    output.push_str(&self.generate_enum(e));
                    output.push_str("\n\n");
                }
            }
        }

        output.push_str("}\n");

        Ok(output)
    }

    pub fn generate_function(&self, func: &CFunction) -> String {
        let mut output = String::new();

        // Function signature
        output.push_str("    fn ");
        output.push_str(&func.name);
        output.push('(');

        // Parameters
        let params: Vec<String> = func
            .parameters
            .iter()
            .map(|(name, ty)| format!("{}: {}", name, self.type_to_vais(ty)))
            .collect();
        output.push_str(&params.join(", "));

        if func.is_variadic {
            if !params.is_empty() {
                output.push_str(", ");
            }
            output.push_str("...");
        }

        output.push(')');

        // Return type
        let return_type = self.type_to_vais(&func.return_type);
        if return_type != "()" {
            output.push_str(" -> ");
            output.push_str(&return_type);
        }

        output.push(';');

        output
    }

    pub fn generate_struct(&self, s: &CStruct) -> String {
        let mut output = String::new();

        if s.is_opaque {
            // Opaque struct - use void pointer
            output.push_str(&format!("    type {} = *mut ();\n", s.name));
        } else {
            // Regular struct
            output.push_str(&format!("    struct {} {{\n", s.name));

            for field in &s.fields {
                output.push_str(&format!(
                    "        {}: {},\n",
                    field.name,
                    self.type_to_vais(&field.field_type)
                ));
            }

            output.push_str("    }");
        }

        output
    }

    fn generate_typedef(&self, t: &CTypedef) -> String {
        format!(
            "    type {} = {};",
            t.name,
            self.type_to_vais(&t.underlying_type)
        )
    }

    fn generate_enum(&self, e: &CEnum) -> String {
        let mut output = String::new();

        output.push_str(&format!("    enum {} {{\n", e.name));

        for (name, value) in &e.variants {
            output.push_str("        ");
            output.push_str(name);
            if let Some(val) = value {
                output.push_str(&format!(" = {}", val));
            }
            output.push_str(",\n");
        }

        output.push_str("    }");

        output
    }

    pub fn type_to_vais(&self, c_type: &CType) -> String {
        match c_type {
            CType::Void => "()".to_string(),
            CType::Char => "i8".to_string(),
            CType::Short => "i16".to_string(),
            CType::Int => "i32".to_string(),
            CType::Long => "i64".to_string(),
            CType::LongLong => "i64".to_string(),
            CType::UChar => "u8".to_string(),
            CType::UShort => "u16".to_string(),
            CType::UInt => "u32".to_string(),
            CType::ULong => "u64".to_string(),
            CType::ULongLong => "u64".to_string(),
            CType::Float => "f32".to_string(),
            CType::Double => "f64".to_string(),
            CType::Bool => "bool".to_string(),
            CType::SizeT => "usize".to_string(),
            CType::Custom(name) => {
                // Check if there's a custom mapping
                if let Some(mapped) = self.config.get_type_mapping(name) {
                    mapped.to_string()
                } else {
                    name.clone()
                }
            }
            CType::Pointer(inner) => {
                let inner_type = self.type_to_vais(inner);
                format!("*mut {}", inner_type)
            }
            CType::ConstPointer(inner) => {
                let inner_type = self.type_to_vais(inner);
                format!("*const {}", inner_type)
            }
            CType::Array(inner, size) => {
                let inner_type = self.type_to_vais(inner);
                if let Some(s) = size {
                    format!("[{}; {}]", inner_type, s)
                } else {
                    format!("*mut {}", inner_type)
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::CField;

    #[test]
    fn test_type_to_vais_primitives() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        assert_eq!(gen.type_to_vais(&CType::Void), "()");
        assert_eq!(gen.type_to_vais(&CType::Int), "i32");
        assert_eq!(gen.type_to_vais(&CType::UInt), "u32");
        assert_eq!(gen.type_to_vais(&CType::Float), "f32");
        assert_eq!(gen.type_to_vais(&CType::Double), "f64");
    }

    #[test]
    fn test_type_to_vais_pointers() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        let ptr = CType::Pointer(Box::new(CType::Int));
        assert_eq!(gen.type_to_vais(&ptr), "*mut i32");

        let const_ptr = CType::ConstPointer(Box::new(CType::Char));
        assert_eq!(gen.type_to_vais(&const_ptr), "*const i8");
    }

    #[test]
    fn test_generate_function_simple() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        let func = CFunction {
            name: "add".to_string(),
            return_type: CType::Int,
            parameters: vec![
                ("a".to_string(), CType::Int),
                ("b".to_string(), CType::Int),
            ],
            is_variadic: false,
        };

        let result = gen.generate_function(&func);
        assert!(result.contains("fn add(a: i32, b: i32) -> i32;"));
    }

    #[test]
    fn test_generate_function_void() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        let func = CFunction {
            name: "print".to_string(),
            return_type: CType::Void,
            parameters: vec![],
            is_variadic: false,
        };

        let result = gen.generate_function(&func);
        assert!(result.contains("fn print();"));
        assert!(!result.contains("->"));
    }

    #[test]
    fn test_generate_function_variadic() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        let func = CFunction {
            name: "printf".to_string(),
            return_type: CType::Int,
            parameters: vec![("fmt".to_string(), CType::ConstPointer(Box::new(CType::Char)))],
            is_variadic: true,
        };

        let result = gen.generate_function(&func);
        assert!(result.contains("..."));
    }

    #[test]
    fn test_generate_struct() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        let s = CStruct {
            name: "Point".to_string(),
            fields: vec![
                CField {
                    name: "x".to_string(),
                    field_type: CType::Int,
                },
                CField {
                    name: "y".to_string(),
                    field_type: CType::Int,
                },
            ],
            is_opaque: false,
        };

        let result = gen.generate_struct(&s);
        assert!(result.contains("struct Point"));
        assert!(result.contains("x: i32"));
        assert!(result.contains("y: i32"));
    }

    #[test]
    fn test_generate_opaque_struct() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        let s = CStruct {
            name: "Handle".to_string(),
            fields: vec![],
            is_opaque: true,
        };

        let result = gen.generate_struct(&s);
        assert!(result.contains("type Handle = *mut ()"));
    }

    #[test]
    fn test_generate_enum() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        let e = CEnum {
            name: "Status".to_string(),
            variants: vec![
                ("OK".to_string(), Some(0)),
                ("ERROR".to_string(), Some(1)),
            ],
        };

        let result = gen.generate_enum(&e);
        assert!(result.contains("enum Status"));
        assert!(result.contains("OK = 0"));
        assert!(result.contains("ERROR = 1"));
    }

    #[test]
    fn test_generate_typedef() {
        let config = BindgenConfig::default();
        let gen = Generator::new(&config);

        let t = CTypedef {
            name: "MyInt".to_string(),
            underlying_type: CType::Int,
        };

        let result = gen.generate_typedef(&t);
        assert!(result.contains("type MyInt = i32"));
    }
}
