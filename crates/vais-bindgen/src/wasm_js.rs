//! WASM JavaScript glue code generator
//!
//! Generates .js binding files that:
//! 1. Load and instantiate the WASM module
//! 2. Provide import functions from JS to WASM (for `#[wasm_import]`)
//! 3. Wrap exported WASM functions with JS-friendly APIs (for `#[wasm_export]`)
//! 4. Handle type serialization across the boundary

use std::collections::HashMap;

/// Information about a WASM-exported function
#[derive(Debug, Clone)]
pub struct WasmExportInfo {
    /// Function name in WASM module
    pub wasm_name: String,
    /// Export name visible to JS
    pub js_name: String,
    /// Parameter names and types (type as string for simplicity)
    pub params: Vec<(String, String)>,
    /// Return type (as string)
    pub return_type: Option<String>,
}

/// Information about a WASM-imported function
#[derive(Debug, Clone)]
pub struct WasmImportInfo {
    /// Module name (e.g., "env")
    pub module: String,
    /// Function name in the import module
    pub name: String,
    /// Vais function name
    pub vais_name: String,
    /// Parameter types
    pub params: Vec<String>,
    /// Return type
    pub return_type: Option<String>,
}

/// Generates JavaScript glue code for WASM modules
#[derive(Debug)]
pub struct WasmJsBindgen {
    /// Module name
    pub module_name: String,
    /// Exported functions
    pub exports: Vec<WasmExportInfo>,
    /// Imported functions
    pub imports: Vec<WasmImportInfo>,
}

impl WasmJsBindgen {
    pub fn new(module_name: &str) -> Self {
        Self {
            module_name: module_name.to_string(),
            exports: Vec::new(),
            imports: Vec::new(),
        }
    }

    pub fn add_export(&mut self, info: WasmExportInfo) {
        self.exports.push(info);
    }

    pub fn add_import(&mut self, info: WasmImportInfo) {
        self.imports.push(info);
    }

    /// Generate the complete JS glue code file
    pub fn generate_js(&self) -> String {
        let mut js = String::new();

        js.push_str(&format!(
            "// Auto-generated WASM bindings for {}\n",
            self.module_name
        ));
        js.push_str("// Generated by vais-bindgen\n\n");

        // Generate import object builder
        js.push_str("/**\n * Create the import object for WASM instantiation.\n");
        js.push_str(
            " * Override individual functions to provide custom JS implementations.\n */\n",
        );
        js.push_str("export function createImports(overrides = {}) {\n");

        // Group imports by module
        let mut modules: HashMap<String, Vec<&WasmImportInfo>> = HashMap::new();
        for imp in &self.imports {
            modules.entry(imp.module.clone()).or_default().push(imp);
        }

        js.push_str("  const imports = {\n");
        for (module, funcs) in &modules {
            js.push_str(&format!("    \"{}\": {{\n", module));
            for func in funcs {
                let params = func
                    .params
                    .iter()
                    .enumerate()
                    .map(|(i, _)| format!("arg{}", i))
                    .collect::<Vec<_>>()
                    .join(", ");
                js.push_str(&format!(
                    "      {}: overrides[\"{}\"] || (({}) => {{ console.warn(\"Unimplemented import: {}.{}\"); }}),\n",
                    func.name, func.name, params, module, func.name
                ));
            }
            js.push_str("    },\n");
        }
        // Always include env module stub
        if !modules.contains_key("env") {
            js.push_str("    \"env\": {},\n");
        }
        js.push_str("  };\n");
        js.push_str("  return imports;\n");
        js.push_str("}\n\n");

        // Generate module loader
        js.push_str("/**\n * Load and instantiate the WASM module.\n");
        js.push_str(" * @param {string|ArrayBuffer} source - Path to .wasm file or ArrayBuffer\n");
        js.push_str(" * @param {Object} importOverrides - Custom import implementations\n */\n");
        js.push_str("export async function load(source, importOverrides = {}) {\n");
        js.push_str("  const imports = createImports(importOverrides);\n");
        js.push_str("  let instance;\n\n");
        js.push_str("  if (typeof source === 'string') {\n");
        js.push_str("    if (typeof fetch !== 'undefined') {\n");
        js.push_str("      const response = await fetch(source);\n");
        js.push_str("      const bytes = await response.arrayBuffer();\n");
        js.push_str("      const result = await WebAssembly.instantiate(bytes, imports);\n");
        js.push_str("      instance = result.instance;\n");
        js.push_str("    } else {\n");
        js.push_str("      const fs = await import('fs');\n");
        js.push_str("      const bytes = fs.readFileSync(source);\n");
        js.push_str("      const result = await WebAssembly.instantiate(bytes, imports);\n");
        js.push_str("      instance = result.instance;\n");
        js.push_str("    }\n");
        js.push_str("  } else {\n");
        js.push_str("    const result = await WebAssembly.instantiate(source, imports);\n");
        js.push_str("    instance = result.instance;\n");
        js.push_str("  }\n\n");

        // Wrap exports
        js.push_str("  return {\n");
        js.push_str("    instance,\n");
        js.push_str("    memory: instance.exports.memory,\n");
        for exp in &self.exports {
            if exp.params.is_empty() {
                js.push_str(&format!(
                    "    {}: () => instance.exports.{}(),\n",
                    exp.js_name, exp.wasm_name
                ));
            } else {
                let params = exp
                    .params
                    .iter()
                    .map(|(n, _)| n.clone())
                    .collect::<Vec<_>>()
                    .join(", ");
                js.push_str(&format!(
                    "    {}: ({}) => instance.exports.{}({}),\n",
                    exp.js_name, params, exp.wasm_name, params
                ));
            }
        }
        js.push_str("  };\n");
        js.push_str("}\n");

        js
    }

    /// Generate TypeScript declaration file
    pub fn generate_dts(&self) -> String {
        let mut dts = String::new();

        dts.push_str(&format!(
            "// Auto-generated TypeScript declarations for {}\n\n",
            self.module_name
        ));

        dts.push_str("export function createImports(overrides?: Record<string, Function>): WebAssembly.Imports;\n\n");

        // Module interface
        dts.push_str(&format!(
            "export interface {}Module {{\n",
            capitalize(&self.module_name)
        ));
        dts.push_str("  instance: WebAssembly.Instance;\n");
        dts.push_str("  memory: WebAssembly.Memory;\n");
        for exp in &self.exports {
            let params = exp
                .params
                .iter()
                .map(|(n, t)| format!("{}: {}", n, vais_type_to_ts(t)))
                .collect::<Vec<_>>()
                .join(", ");
            let ret = exp
                .return_type
                .as_ref()
                .map(|t| vais_type_to_ts(t))
                .unwrap_or_else(|| "void".to_string());
            dts.push_str(&format!("  {}({}): {};\n", exp.js_name, params, ret));
        }
        dts.push_str("}\n\n");

        dts.push_str(&format!(
            "export function load(source: string | ArrayBuffer, importOverrides?: Record<string, Function>): Promise<{}Module>;\n",
            capitalize(&self.module_name)
        ));

        dts
    }
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

fn vais_type_to_ts(ty: &str) -> String {
    match ty {
        "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64" => {
            "number".to_string()
        }
        "bool" => "boolean".to_string(),
        "str" | "String" => "string".to_string(),
        "()" => "void".to_string(),
        _ => ty.to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_module() {
        let gen = WasmJsBindgen::new("test_module");
        let js = gen.generate_js();
        assert!(js.contains("createImports"));
        assert!(js.contains("load"));
        assert!(js.contains("WebAssembly.instantiate"));
    }

    #[test]
    fn test_with_exports() {
        let mut gen = WasmJsBindgen::new("math");
        gen.add_export(WasmExportInfo {
            wasm_name: "add".to_string(),
            js_name: "add".to_string(),
            params: vec![
                ("a".to_string(), "i32".to_string()),
                ("b".to_string(), "i32".to_string()),
            ],
            return_type: Some("i32".to_string()),
        });
        let js = gen.generate_js();
        assert!(js.contains("add: (a, b) => instance.exports.add(a, b)"));
    }

    #[test]
    fn test_with_imports() {
        let mut gen = WasmJsBindgen::new("app");
        gen.add_import(WasmImportInfo {
            module: "env".to_string(),
            name: "js_log".to_string(),
            vais_name: "js_log".to_string(),
            params: vec!["i32".to_string()],
            return_type: None,
        });
        let js = gen.generate_js();
        assert!(js.contains("\"env\""));
        assert!(js.contains("js_log"));
    }

    #[test]
    fn test_dts_generation() {
        let mut gen = WasmJsBindgen::new("math");
        gen.add_export(WasmExportInfo {
            wasm_name: "add".to_string(),
            js_name: "add".to_string(),
            params: vec![
                ("a".to_string(), "i32".to_string()),
                ("b".to_string(), "i32".to_string()),
            ],
            return_type: Some("i32".to_string()),
        });
        let dts = gen.generate_dts();
        assert!(dts.contains("MathModule"));
        assert!(dts.contains("add(a: number, b: number): number"));
        assert!(dts.contains("Promise<MathModule>"));
    }

    #[test]
    fn test_multiple_import_modules() {
        let mut gen = WasmJsBindgen::new("app");
        gen.add_import(WasmImportInfo {
            module: "env".to_string(),
            name: "log".to_string(),
            vais_name: "log".to_string(),
            params: vec![],
            return_type: None,
        });
        gen.add_import(WasmImportInfo {
            module: "wasi_snapshot_preview1".to_string(),
            name: "fd_write".to_string(),
            vais_name: "fd_write".to_string(),
            params: vec![
                "i32".to_string(),
                "i32".to_string(),
                "i32".to_string(),
                "i32".to_string(),
            ],
            return_type: Some("i32".to_string()),
        });
        let js = gen.generate_js();
        assert!(js.contains("\"env\""));
        assert!(js.contains("\"wasi_snapshot_preview1\""));
    }

    #[test]
    fn test_no_params_export() {
        let mut gen = WasmJsBindgen::new("app");
        gen.add_export(WasmExportInfo {
            wasm_name: "main".to_string(),
            js_name: "main".to_string(),
            params: vec![],
            return_type: Some("i32".to_string()),
        });
        let js = gen.generate_js();
        assert!(js.contains("main: () => instance.exports.main()"));
    }
}
