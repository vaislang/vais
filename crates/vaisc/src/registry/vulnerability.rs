//! Vulnerability scanning using OSV (Open Source Vulnerability) database
//!
//! This module provides integration with the OSV.dev API to check packages
//! for known security vulnerabilities.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::Duration;

/// A vulnerability advisory
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Unique vulnerability ID (e.g., "GHSA-xxx-xxx-xxx" or "CVE-2024-1234")
    pub id: String,
    /// Summary of the vulnerability
    pub summary: String,
    /// Detailed description
    #[serde(default)]
    pub details: String,
    /// Affected package ranges
    #[serde(default)]
    pub affected: Vec<AffectedPackage>,
    /// Severity level
    #[serde(default)]
    pub severity: Vec<Severity>,
    /// Reference URLs
    #[serde(default)]
    pub references: Vec<Reference>,
    /// When the vulnerability was published
    #[serde(default)]
    pub published: String,
    /// When the vulnerability was last modified
    #[serde(default)]
    pub modified: String,
}

/// Affected package version range
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AffectedPackage {
    /// Package information
    #[serde(default)]
    pub package: Package,
    /// Version ranges that are affected
    #[serde(default)]
    pub ranges: Vec<Range>,
    /// Specific versions that are affected
    #[serde(default)]
    pub versions: Vec<String>,
}

/// Package information
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Package {
    /// Package name
    #[serde(default)]
    pub name: String,
    /// Package ecosystem (e.g., "vais", "npm", "crates.io")
    #[serde(default)]
    pub ecosystem: String,
}

/// Version range specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Range {
    /// Range type (e.g., "SEMVER", "GIT", "ECOSYSTEM")
    #[serde(rename = "type")]
    pub range_type: String,
    /// Events describing the range
    #[serde(default)]
    pub events: Vec<RangeEvent>,
}

/// Range event (introduced, fixed, last_affected, limit)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RangeEvent {
    /// Version where vulnerability was introduced
    #[serde(default)]
    pub introduced: Option<String>,
    /// Version where vulnerability was fixed
    #[serde(default)]
    pub fixed: Option<String>,
    /// Last affected version
    #[serde(default)]
    pub last_affected: Option<String>,
    /// Upper limit (exclusive)
    #[serde(default)]
    pub limit: Option<String>,
}

/// Severity information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Severity {
    /// Severity type (e.g., "CVSS_V3")
    #[serde(rename = "type")]
    pub severity_type: String,
    /// Score value
    #[serde(default)]
    pub score: String,
}

/// Reference URL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Reference {
    /// Reference type (e.g., "ADVISORY", "WEB", "PACKAGE")
    #[serde(rename = "type")]
    pub ref_type: String,
    /// URL
    #[serde(default)]
    pub url: String,
}

/// OSV API query request
#[derive(Debug, Serialize)]
struct QueryRequest {
    package: QueryPackage,
    version: String,
}

#[derive(Debug, Serialize)]
struct QueryPackage {
    name: String,
    ecosystem: String,
}

/// OSV API query response
#[derive(Debug, Deserialize)]
struct QueryResponse {
    #[serde(default)]
    vulns: Vec<Vulnerability>,
}

/// Batch query request for multiple packages
#[derive(Debug, Serialize)]
struct BatchQueryRequest {
    queries: Vec<QueryRequest>,
}

/// Batch query response
#[derive(Debug, Deserialize)]
struct BatchQueryResponse {
    #[serde(default)]
    results: Vec<BatchResult>,
}

#[derive(Debug, Deserialize)]
struct BatchResult {
    #[serde(default)]
    vulns: Vec<Vulnerability>,
}

/// Vulnerability scanner using OSV API
pub struct VulnerabilityScanner {
    /// HTTP client for API requests
    client: ureq::Agent,
    /// OSV API base URL
    api_url: String,
    /// Ecosystem name for Vais packages
    ecosystem: String,
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

impl VulnerabilityScanner {
    /// Create a new scanner with default settings
    pub fn new() -> Self {
        let client = ureq::AgentBuilder::new()
            .timeout_read(Duration::from_secs(30))
            .timeout_write(Duration::from_secs(30))
            .build();

        Self {
            client,
            api_url: "https://api.osv.dev/v1".to_string(),
            ecosystem: "vais".to_string(),
        }
    }

    /// Create a scanner with custom API URL (for testing)
    pub fn with_api_url(api_url: &str) -> Self {
        let mut scanner = Self::new();
        scanner.api_url = api_url.to_string();
        scanner
    }

    /// Query vulnerabilities for a single package
    pub fn query(&self, package_name: &str, version: &str) -> Result<Vec<Vulnerability>, String> {
        let request = QueryRequest {
            package: QueryPackage {
                name: package_name.to_string(),
                ecosystem: self.ecosystem.clone(),
            },
            version: version.to_string(),
        };

        let url = format!("{}/query", self.api_url);

        match self.client.post(&url)
            .set("Content-Type", "application/json")
            .send_json(&request)
        {
            Ok(response) => {
                match response.into_json::<QueryResponse>() {
                    Ok(resp) => Ok(resp.vulns),
                    Err(e) => Err(format!("Failed to parse response: {}", e)),
                }
            }
            Err(ureq::Error::Status(404, _)) => {
                // No vulnerabilities found
                Ok(Vec::new())
            }
            Err(e) => Err(format!("API request failed: {}", e)),
        }
    }

    /// Query vulnerabilities for multiple packages in batch
    pub fn query_batch(&self, packages: &[(String, String)]) -> Result<HashMap<String, Vec<Vulnerability>>, String> {
        if packages.is_empty() {
            return Ok(HashMap::new());
        }

        let queries: Vec<QueryRequest> = packages.iter()
            .map(|(name, version)| QueryRequest {
                package: QueryPackage {
                    name: name.clone(),
                    ecosystem: self.ecosystem.clone(),
                },
                version: version.clone(),
            })
            .collect();

        let request = BatchQueryRequest { queries };
        let url = format!("{}/querybatch", self.api_url);

        match self.client.post(&url)
            .set("Content-Type", "application/json")
            .send_json(&request)
        {
            Ok(response) => {
                match response.into_json::<BatchQueryResponse>() {
                    Ok(resp) => {
                        let mut result = HashMap::new();
                        for (i, batch_result) in resp.results.into_iter().enumerate() {
                            if !batch_result.vulns.is_empty() {
                                if let Some((name, _)) = packages.get(i) {
                                    result.insert(name.clone(), batch_result.vulns);
                                }
                            }
                        }
                        Ok(result)
                    }
                    Err(e) => Err(format!("Failed to parse batch response: {}", e)),
                }
            }
            Err(ureq::Error::Status(404, _)) => {
                Ok(HashMap::new())
            }
            Err(e) => Err(format!("Batch API request failed: {}", e)),
        }
    }

    /// Check if a version is affected by a vulnerability
    pub fn is_version_affected(vuln: &Vulnerability, version: &str) -> bool {
        // Check explicit versions list
        for affected in &vuln.affected {
            if affected.versions.contains(&version.to_string()) {
                return true;
            }

            // Check version ranges
            for range in &affected.ranges {
                if Self::is_in_range(version, range) {
                    return true;
                }
            }
        }
        false
    }

    /// Check if version is within a range
    fn is_in_range(version: &str, range: &Range) -> bool {
        let mut introduced = false;
        let mut fixed = false;

        for event in &range.events {
            if let Some(ref intro_ver) = event.introduced {
                if intro_ver == "0" || Self::version_compare(version, intro_ver) >= 0 {
                    introduced = true;
                }
            }

            if let Some(ref fix_ver) = event.fixed {
                if Self::version_compare(version, fix_ver) >= 0 {
                    fixed = true;
                }
            }

            if let Some(ref last) = event.last_affected {
                if Self::version_compare(version, last) > 0 {
                    fixed = true;
                }
            }
        }

        introduced && !fixed
    }

    /// Simple semantic version comparison
    /// Returns: -1 if a < b, 0 if a == b, 1 if a > b
    fn version_compare(a: &str, b: &str) -> i32 {
        let parse_version = |s: &str| -> Vec<u64> {
            s.split('.')
                .filter_map(|p| {
                    // Handle pre-release suffixes like "1.0.0-rc1"
                    let num_part = p.split('-').next().unwrap_or(p);
                    num_part.parse().ok()
                })
                .collect()
        };

        let va = parse_version(a);
        let vb = parse_version(b);

        let max_len = va.len().max(vb.len());
        for i in 0..max_len {
            let pa = va.get(i).copied().unwrap_or(0);
            let pb = vb.get(i).copied().unwrap_or(0);

            if pa < pb {
                return -1;
            }
            if pa > pb {
                return 1;
            }
        }

        0
    }

    /// Get severity label from CVSS score
    pub fn severity_label(vuln: &Vulnerability) -> &'static str {
        for sev in &vuln.severity {
            if sev.severity_type == "CVSS_V3" {
                if let Ok(score) = sev.score.parse::<f64>() {
                    return match score {
                        s if s >= 9.0 => "CRITICAL",
                        s if s >= 7.0 => "HIGH",
                        s if s >= 4.0 => "MEDIUM",
                        _ => "LOW",
                    };
                }
            }
        }
        "UNKNOWN"
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version_compare() {
        assert_eq!(VulnerabilityScanner::version_compare("1.0.0", "1.0.0"), 0);
        assert_eq!(VulnerabilityScanner::version_compare("1.0.0", "1.0.1"), -1);
        assert_eq!(VulnerabilityScanner::version_compare("1.0.1", "1.0.0"), 1);
        assert_eq!(VulnerabilityScanner::version_compare("2.0.0", "1.9.9"), 1);
        assert_eq!(VulnerabilityScanner::version_compare("1.0", "1.0.0"), 0);
    }

    #[test]
    fn test_is_in_range() {
        let range = Range {
            range_type: "SEMVER".to_string(),
            events: vec![
                RangeEvent {
                    introduced: Some("1.0.0".to_string()),
                    fixed: Some("1.2.0".to_string()),
                    last_affected: None,
                    limit: None,
                },
            ],
        };

        assert!(VulnerabilityScanner::is_in_range("1.0.0", &range));
        assert!(VulnerabilityScanner::is_in_range("1.1.5", &range));
        assert!(!VulnerabilityScanner::is_in_range("1.2.0", &range));
        assert!(!VulnerabilityScanner::is_in_range("0.9.0", &range));
    }

    #[test]
    fn test_severity_label() {
        let vuln = Vulnerability {
            id: "TEST-001".to_string(),
            summary: "Test".to_string(),
            details: String::new(),
            affected: Vec::new(),
            severity: vec![Severity {
                severity_type: "CVSS_V3".to_string(),
                score: "9.5".to_string(),
            }],
            references: Vec::new(),
            published: String::new(),
            modified: String::new(),
        };

        assert_eq!(VulnerabilityScanner::severity_label(&vuln), "CRITICAL");
    }

    #[test]
    fn test_scanner_creation() {
        let scanner = VulnerabilityScanner::new();
        assert_eq!(scanner.ecosystem, "vais");
        assert!(scanner.api_url.contains("osv.dev"));
    }
}
