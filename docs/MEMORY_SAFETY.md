# Memory Safety in Vais

This document describes how memory safety is ensured in the Vais compiler and runtime, and how to test for memory-related issues.

## Table of Contents

- [Overview](#overview)
- [Memory Safety in the Compiler](#memory-safety-in-the-compiler)
- [Memory Safety in Generated Code](#memory-safety-in-generated-code)
- [Running Memory Safety Tests](#running-memory-safety-tests)
- [Unsafe Code Audit](#unsafe-code-audit)
- [Known Limitations](#known-limitations)
- [Best Practices](#best-practices)

## Overview

Vais takes memory safety seriously at two levels:

1. **Compiler Memory Safety**: The Vais compiler itself is written in Rust and leverages Rust's memory safety guarantees
2. **Generated Code Safety**: The code generated by Vais provides memory safety through garbage collection and runtime checks

## Memory Safety in the Compiler

### Rust's Safety Guarantees

The Vais compiler is primarily written in safe Rust, which provides:

- **No null pointer dereferences**: Option types make nullability explicit
- **No use-after-free**: Ownership system prevents dangling pointers
- **No buffer overflows**: Bounds checking on array/slice access
- **No data races**: Borrow checker prevents concurrent mutation

### Unsafe Code Usage

The compiler uses `unsafe` code sparingly and only when necessary:

#### vais-gc (Garbage Collector)

**Location**: `crates/vais-gc/src/gc.rs`

**Usage**: Conservative stack scanning requires reading raw memory
```rust
unsafe {
    let potential_ptr = ptr::read(data_vec.as_ptr().add(offset) as *const usize);
    // Checked to be within heap bounds before dereferencing
}
```

**Safety**: All pointer dereferences are bounds-checked before use.

#### vais-jit (Just-In-Time Compiler)

**Location**: `crates/vais-jit/src/compiler.rs`

**Usage**: FFI calls to LLVM's JIT execution engine
```rust
unsafe {
    let func = engine.get_function::<fn() -> i64>(name)?;
    func.call()
}
```

**Safety**: Function signatures are verified at compile time; runtime type safety enforced by LLVM.

#### vais-dynload (Dynamic Module Loading)

**Location**: `crates/vais-dynload/src/module_loader.rs`

**Usage**: Loading native libraries via `libloading`
```rust
unsafe {
    let lib = Library::new(path)?;
    let symbol: Symbol<fn() -> i64> = lib.get(name)?;
}
```

**Safety**: Symbol types are validated; loaded libraries must follow C ABI conventions.

#### vais-profiler (Performance Profiling)

**Location**: `crates/vais-profiler/src/ffi.rs`

**Usage**: FFI to native profiling libraries (perf, valgrind)

**Safety**: All FFI calls check return values; memory managed by external libraries.

### AddressSanitizer Testing

We use AddressSanitizer (ASan) to detect memory errors in the compiler:

- **Buffer overflows**: Reading/writing beyond array bounds
- **Use-after-free**: Accessing freed memory
- **Double-free**: Freeing memory twice
- **Memory leaks**: Failing to free allocated memory

## Memory Safety in Generated Code

### Garbage Collection

Vais uses a garbage collector to manage heap-allocated objects:

- **Generational GC**: Young objects collected frequently, old objects less often
- **Conservative scanning**: Scans stack/registers for potential pointers
- **Concurrent collection**: GC runs in parallel with program execution (optional)

See [gc-implementation.md](gc-implementation.md) for details.

### Runtime Checks

Generated code includes runtime safety checks:

- **Array bounds checking**: All array accesses verified at runtime
- **Null pointer checks**: Dereferences checked for null (Option unwrapping)
- **Integer overflow detection**: Arithmetic operations checked in debug mode
- **Type safety**: Dynamic type checks for downcasts and generics

### Ownership and Lifetimes

Vais implements Rust-style ownership checking:

- **Move semantics**: Values moved by default, preventing double-free
- **Borrow checking**: References tracked to prevent dangling pointers
- **Lifetime inference**: Automatic lifetime elision reduces annotation burden

See [ROADMAP.md](../ROADMAP.md) Phase 15 P2 for implementation details.

## Running Memory Safety Tests

### Local Testing

#### Run all memory safety tests (without ASan)

```bash
cargo test -p vaisc -- memory_safety
```

This runs the memory safety test suite in `crates/vaisc/tests/memory_safety_tests.rs` with standard compilation. Tests include:

- Deeply nested expressions
- Large string literals
- Many allocations (structs, arrays)
- Rapid create/drop cycles
- Error recovery (malformed input)
- Unicode edge cases

#### Run with AddressSanitizer

```bash
./scripts/asan-test.sh
```

This runs tests with AddressSanitizer enabled on all core packages:
- vais-parser
- vais-types
- vais-codegen
- vais-lexer
- vais-ast
- vais-gc
- vaisc (integration tests)

Test a specific package:
```bash
./scripts/asan-test.sh vais-parser
```

**Requirements**:
- Rust nightly: `rustup install nightly`
- rust-src component: `rustup component add rust-src --toolchain nightly`

#### Run all sanitizers

```bash
./scripts/run-sanitizers.sh all
```

This runs:
- AddressSanitizer (memory errors)
- UndefinedBehaviorSanitizer (UB detection)

For specific sanitizers:
```bash
./scripts/run-sanitizers.sh address    # ASan only
./scripts/run-sanitizers.sh undefined  # UBSan only
./scripts/run-sanitizers.sh thread     # ThreadSanitizer (data races)
```

### CI Testing

Memory safety tests run automatically in CI:

- **Every push to main**: Full ASan test suite
- **Every pull request**: Full ASan test suite
- **Weekly schedule**: Complete sanitizer sweep

See `.github/workflows/asan.yml` for configuration.

### Reading ASan Output

When AddressSanitizer detects an issue, it prints a detailed report:

```
=================================================================
==12345==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000013
READ of size 1 at 0x602000000013 thread T0
    #0 0x... in function_name file.rs:123
    #1 0x... in caller file.rs:456
    ...
```

Key information:
- **Error type**: heap-buffer-overflow, use-after-free, etc.
- **Address**: Memory location of the error
- **Stack trace**: Call stack showing where error occurred
- **Memory state**: Allocation/deallocation history

Logs are saved to `target/asan-logs/` for analysis.

## Unsafe Code Audit

### Current Unsafe Usage (as of 2026-01)

| Crate | File | Purpose | Safety Justification |
|-------|------|---------|---------------------|
| vais-gc | gc.rs | Conservative stack scanning | Pointers bounds-checked before use |
| vais-gc | generational.rs | GC metadata access | Invariants maintained by GC algorithm |
| vais-gc | concurrent.rs | Lock-free data structures | Atomic operations ensure memory safety |
| vais-jit | compiler.rs | LLVM FFI | Type signatures verified; LLVM ensures safety |
| vais-dynload | module_loader.rs | Dynamic library loading | Symbol types validated; C ABI safety |
| vais-profiler | ffi.rs | Native profiler FFI | Return values checked; external memory managed |
| vais-plugin | loader.rs | Plugin loading | Plugin API contract enforced |
| vais-hotreload | dylib_loader.rs | Hot reload library management | Library lifecycle managed carefully |
| vais-codegen | inkwell/generator.rs | LLVM IR generation | LLVM's type system ensures safety |
| vais-dap | debugger.rs | Debugger FFI | Debugger protocol ensures safe communication |
| vais-types | object_safety.rs | Trait object safety checks | Theoretical analysis; no runtime safety risk |
| vais-security | analyzer.rs | AST traversal optimization | Lifetime annotations prevent dangling refs |

### Auditing Process

Before adding new `unsafe` code:

1. **Justify necessity**: Can this be done in safe Rust?
2. **Document invariants**: What must be true for safety?
3. **Add tests**: Verify safety with ASan/Miri
4. **Review carefully**: Get sign-off from maintainers
5. **Update this document**: Add to audit table

## Known Limitations

### Recursive Descent Parser Stack Limits

The parser uses recursive descent, which has stack depth limitations:

- **Moderate nesting** (< 20 levels): ✓ Supported
- **Deep nesting** (> 50 levels): ✗ May stack overflow

Tests marked `#[ignore]` document these limits. Future work may add iterative parsing for deeply nested structures.

### Debug Build Performance

AddressSanitizer and debug builds are slower than release builds:

- **ASan overhead**: ~2x slowdown
- **Debug mode**: ~10x slower than release

Use release builds for performance testing.

### Platform-Specific Limitations

- **MemorySanitizer (MSan)**: Requires instrumented libc (difficult on macOS)
- **ThreadSanitizer (TSan)**: May have false positives with some lock-free algorithms

## Best Practices

### For Compiler Contributors

1. **Prefer safe Rust**: Only use `unsafe` when absolutely necessary
2. **Test with ASan**: Run `./scripts/asan-test.sh` before submitting PRs
3. **Document unsafe**: Add safety comments for all `unsafe` blocks
4. **Add regression tests**: Include tests that trigger the code path

### For Language Users

1. **Trust the compiler**: Vais's memory safety is enforced at compile-time
2. **Use ownership correctly**: Follow move/borrow semantics
3. **Handle Options explicitly**: Don't use `unwrap()` in production
4. **Enable debug mode**: Use debug builds during development for runtime checks

### For Runtime Developers

1. **GC invariants**: Maintain GC metadata consistency
2. **Atomic operations**: Use proper memory ordering
3. **Test concurrent scenarios**: Use TSan for concurrency code
4. **Profile allocation patterns**: Optimize GC for common workloads

## Resources

- [Rust Unsafe Code Guidelines](https://rust-lang.github.io/unsafe-code-guidelines/)
- [AddressSanitizer Documentation](https://clang.llvm.org/docs/AddressSanitizer.html)
- [Miri - Rust Interpreter for UB Detection](https://github.com/rust-lang/miri)
- [GC Implementation Details](gc-implementation.md)

## Future Work

- [ ] Miri integration for undefined behavior detection
- [ ] Valgrind memcheck as alternative to ASan
- [ ] Fuzzing integration with memory safety testing
- [ ] Stack-based parser for deeply nested structures
- [ ] Zero-copy parsing where possible
- [ ] Memory profiling in CI (track allocation trends)

---

**Last Updated**: 2026-01-31
**Maintainer**: Vais Team
