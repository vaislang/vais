# data-structures: Array-backed stack and queue for Vais
# Uses structs with pointer-based storage and manual index tracking.

# ===== Stack =====
# Fixed-capacity stack backed by a *i64 array.

S Stack {
    data: *i64,
    top: i64,
    cap: i64
}

X Stack {
    # Push a value. Returns 1 on success, 0 if full.
    F push(&self, val: i64) -> i64 {
        I self.top >= self.cap { ret 0; }
        self.data[self.top] = val
        self.top = self.top + 1
        1
    }

    # Pop a value. Returns the value, or -1 if empty.
    F pop(&self) -> i64 {
        I self.top <= 0 { ret 0 - 1; }
        self.top = self.top - 1
        self.data[self.top]
    }

    # Peek at the top value without removing. Returns -1 if empty.
    F peek(&self) -> i64 {
        I self.top <= 0 { ret 0 - 1; }
        self.data[self.top - 1]
    }

    # Return current size
    F size(&self) -> i64 = self.top

    # Check if empty (returns 1 if empty)
    F is_empty(&self) -> i64 = self.top == 0 ? 1 : 0
}

# ===== Queue =====
# Fixed-capacity circular queue backed by a *i64 array.

S Queue {
    data: *i64,
    head: i64,
    tail: i64,
    count: i64,
    cap: i64
}

X Queue {
    # Enqueue a value. Returns 1 on success, 0 if full.
    F enqueue(&self, val: i64) -> i64 {
        I self.count >= self.cap { ret 0; }
        self.data[self.tail] = val
        self.tail = (self.tail + 1) % self.cap
        self.count = self.count + 1
        1
    }

    # Dequeue a value. Returns the value, or -1 if empty.
    F dequeue(&self) -> i64 {
        I self.count <= 0 { ret 0 - 1; }
        val := self.data[self.head]
        self.head = (self.head + 1) % self.cap
        self.count = self.count - 1
        val
    }

    # Peek at the front value without removing. Returns -1 if empty.
    F front(&self) -> i64 {
        I self.count <= 0 { ret 0 - 1; }
        self.data[self.head]
    }

    # Return current size
    F size(&self) -> i64 = self.count

    # Check if empty (returns 1 if empty)
    F is_empty(&self) -> i64 = self.count == 0 ? 1 : 0
}

# --- Demo main ---

F main() -> i64 {
    puts("=== data-structures demo ===")

    # --- Stack demo ---
    puts("Stack test:")
    buf1: *i64 = [0, 0, 0, 0, 0, 0, 0, 0]
    s := Stack { data: buf1, top: 0, cap: 8 }

    s.push(3)
    s.push(7)
    s.push(1)

    puts("size after 3 pushes:")
    putchar(s.size() + 48)
    putchar(10)

    puts("peek:")
    putchar(s.peek() + 48)
    putchar(10)

    v1 := s.pop()
    puts("pop:")
    putchar(v1 + 48)
    putchar(10)

    v2 := s.pop()
    puts("pop:")
    putchar(v2 + 48)
    putchar(10)

    puts("size now:")
    putchar(s.size() + 48)
    putchar(10)

    # --- Queue demo ---
    puts("Queue test:")
    buf2: *i64 = [0, 0, 0, 0, 0, 0, 0, 0]
    q := Queue { data: buf2, head: 0, tail: 0, count: 0, cap: 8 }

    q.enqueue(5)
    q.enqueue(9)
    q.enqueue(2)

    puts("front:")
    putchar(q.front() + 48)
    putchar(10)

    d1 := q.dequeue()
    puts("dequeue:")
    putchar(d1 + 48)
    putchar(10)

    puts("size now:")
    putchar(q.size() + 48)
    putchar(10)

    d2 := q.dequeue()
    puts("dequeue:")
    putchar(d2 + 48)
    putchar(10)

    puts("=== done ===")
    0
}
