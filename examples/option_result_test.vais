# Test Option and Result error handling improvements

# Test Vec with Option
F test_vec() -> i64 {
    puts("=== Testing Vec with Option ===")

    v := vec_new()
    v.push(10)
    v.push(20)
    v.push(30)

    # Test get_opt - valid index
    result := v.get_opt(1)
    I result.is_some() == 1 {
        puts("Vec.get_opt(1) = Some(")
        print_i64(result.unwrap_or(0))
        puts(")")
    }

    # Test get_opt - invalid index
    result2 := v.get_opt(10)
    I result2.is_none() == 1 {
        puts("Vec.get_opt(10) = None (correct)")
    }

    # Test pop_opt
    pop_result := v.pop_opt()
    I pop_result.is_some() == 1 {
        puts("Vec.pop_opt() = Some(")
        print_i64(pop_result.unwrap_or(0))
        puts(")")
    }

    v.drop()
    puts("")
    0
}

# Test HashMap with Option
F test_hashmap() -> i64 {
    puts("=== Testing HashMap with Option ===")

    map := hashmap_new()
    map.set(1, 100)
    map.set(2, 200)
    map.set(3, 300)

    # Test get_opt - existing key
    result := map.get_opt(2)
    I result.is_some() == 1 {
        puts("HashMap.get_opt(2) = Some(")
        print_i64(result.unwrap_or(0))
        puts(")")
    }

    # Test get_opt - non-existing key
    result2 := map.get_opt(999)
    I result2.is_none() == 1 {
        puts("HashMap.get_opt(999) = None (correct)")
    }

    # Test remove_opt
    remove_result := map.remove_opt(1)
    I remove_result.is_some() == 1 {
        puts("HashMap.remove_opt(1) = Some(")
        print_i64(remove_result.unwrap_or(0))
        puts(")")
    }

    map.drop()
    puts("")
    0
}

# Test Deque with Option
F test_deque() -> i64 {
    puts("=== Testing Deque with Option ===")

    dq := deque_new()
    dq.push_back(10)
    dq.push_back(20)
    dq.push_front(5)

    # Test front_opt
    front := dq.front_opt()
    I front.is_some() == 1 {
        puts("Deque.front_opt() = Some(")
        print_i64(front.unwrap_or(0))
        puts(")")
    }

    # Test back_opt
    back := dq.back_opt()
    I back.is_some() == 1 {
        puts("Deque.back_opt() = Some(")
        print_i64(back.unwrap_or(0))
        puts(")")
    }

    # Test pop_front_opt
    pop := dq.pop_front_opt()
    I pop.is_some() == 1 {
        puts("Deque.pop_front_opt() = Some(")
        print_i64(pop.unwrap_or(0))
        puts(")")
    }

    # Test get_opt
    get_result := dq.get_opt(0)
    I get_result.is_some() == 1 {
        puts("Deque.get_opt(0) = Some(")
        print_i64(get_result.unwrap_or(0))
        puts(")")
    }

    dq.drop()
    puts("")
    0
}

# Test String with Option
F test_string() -> i64 {
    puts("=== Testing String with Option ===")

    s := str_from("Hello")

    # Test char_at_opt - valid index
    ch := s.char_at_opt(1)
    I ch.is_some() == 1 {
        puts("String.char_at_opt(1) = Some(")
        print_i64(ch.unwrap_or(0))
        puts(") [ASCII for 'e']")
    }

    # Test char_at_opt - invalid index
    ch2 := s.char_at_opt(100)
    I ch2.is_none() == 1 {
        puts("String.char_at_opt(100) = None (correct)")
    }

    s.drop()
    puts("")
    0
}

# Test PriorityQueue with Option
F test_priority_queue() -> i64 {
    puts("=== Testing PriorityQueue with Option ===")

    pq := PriorityQueue.with_capacity(8)
    pq.push(50)
    pq.push(20)
    pq.push(30)
    pq.push(10)

    # Test peek_opt
    peek := pq.peek_opt()
    I peek.is_some() == 1 {
        puts("PriorityQueue.peek_opt() = Some(")
        print_i64(peek.unwrap_or(0))
        puts(") [minimum element]")
    }

    # Test pop_opt
    pop1 := pq.pop_opt()
    I pop1.is_some() == 1 {
        puts("PriorityQueue.pop_opt() = Some(")
        print_i64(pop1.unwrap_or(0))
        puts(")")
    }

    pop2 := pq.pop_opt()
    I pop2.is_some() == 1 {
        puts("PriorityQueue.pop_opt() = Some(")
        print_i64(pop2.unwrap_or(0))
        puts(")")
    }

    pq.drop()
    puts("")
    0
}

# Test BTreeMap with Option
F test_btreemap() -> i64 {
    puts("=== Testing BTreeMap with Option ===")

    map := btreemap_new()
    btreemap_set(map, 5, 500)
    btreemap_set(map, 3, 300)
    btreemap_set(map, 7, 700)

    # Test btreemap_get_opt - existing key
    result := btreemap_get_opt(map, 5)
    I result.is_some() == 1 {
        puts("BTreeMap.get_opt(5) = Some(")
        print_i64(result.unwrap_or(0))
        puts(")")
    }

    # Test btreemap_get_opt - non-existing key
    result2 := btreemap_get_opt(map, 999)
    I result2.is_none() == 1 {
        puts("BTreeMap.get_opt(999) = None (correct)")
    }

    btreemap_free(map)
    puts("")
    0
}

# Test IO with Result
F test_io_result() -> i64 {
    puts("=== Testing IO with Result ===")

    # Test read_i64_result (simulated - would need actual input in real test)
    puts("IO Result functions added:")
    puts("- read_i64_result() -> Result")
    puts("- read_line_opt() -> Option")
    puts("- read_word_opt() -> Option")
    puts("")
    0
}

# Test File with Result
F test_file_result() -> i64 {
    puts("=== Testing File with Result ===")

    puts("File Result functions added:")
    puts("- File.read_byte_opt() -> Option")
    puts("- File.read_line_result() -> Result")
    puts("- file_read_all_result() -> Result")
    puts("")
    0
}

# Main
F main() -> i64 {
    puts("===================================")
    puts("Option/Result Error Handling Tests")
    puts("===================================")
    puts("")

    test_vec()
    test_hashmap()
    test_deque()
    test_string()
    test_priority_queue()
    test_btreemap()
    test_io_result()
    test_file_result()

    puts("All tests completed!")
    0
}
