# Dynamic Module Loading Test
# Demonstrates the dynamic loading capabilities of the Vais language.
#
# This example shows:
# 1. Loading dynamic libraries at runtime
# 2. Getting function pointers from loaded modules
# 3. Resource limits and capabilities
# 4. WASM sandbox basics
#
# Note: Some features require runtime support that may not be available
# in all environments.

# Import the dynload standard library
# IMP std/dynload

# ============================================================================
# Test 1: Basic Module Loading Simulation
# ============================================================================

# Since actual dynamic loading requires compiled libraries,
# we simulate the concepts here.

# Simulate a module handle
S TestModuleHandle {
    id: i64,
    name: i64,
    version: i64,
    is_loaded: i64
}

# Create a test module handle
F create_test_module(id: i64, name: i64) -> TestModuleHandle {
    TestModuleHandle {
        id: id,
        name: name,
        version: 1,
        is_loaded: 1
    }
}

# Simulate unloading
F unload_test_module(m: TestModuleHandle) -> TestModuleHandle {
    TestModuleHandle {
        id: m.id,
        name: m.name,
        version: m.version,
        is_loaded: 0
    }
}

# Simulate reloading
F reload_test_module(m: TestModuleHandle) -> TestModuleHandle {
    TestModuleHandle {
        id: m.id,
        name: m.name,
        version: m.version + 1,
        is_loaded: 1
    }
}

# ============================================================================
# Test 2: Resource Limits
# ============================================================================

# Resource limit structure
S ResourceLimit {
    max_memory: i64,
    max_time: i64,
    max_stack: i64,
    max_calls: i64
}

# Create default limits
F default_resource_limits() -> ResourceLimit {
    ResourceLimit {
        max_memory: 67108864,  # 64 MB
        max_time: 5000,        # 5 seconds
        max_stack: 1048576,    # 1 MB
        max_calls: 1000        # 1000 call depth
    }
}

# Check if usage exceeds limits
F check_limits(used_memory: i64, used_time: i64, limits: ResourceLimit) -> i64 {
    I used_memory > limits.max_memory {
        0  # Exceeded
    } E {
        I used_time > limits.max_time {
            0  # Exceeded
        } E {
            1  # OK
        }
    }
}

# ============================================================================
# Test 3: Capability System
# ============================================================================

# Capability flags
C CAP_CONSOLE: i64  = 1
C CAP_TIME: i64     = 2
C CAP_RANDOM: i64   = 4
C CAP_FS_READ: i64  = 8
C CAP_FS_WRITE: i64 = 16
C CAP_NETWORK: i64  = 32

# Check if capability is granted
F has_cap(caps: i64, cap: i64) -> i64 {
    I (caps & cap) != 0 {
        1
    } E {
        0
    }
}

# Grant a capability
F grant_cap(caps: i64, cap: i64) -> i64 {
    caps | cap
}

# Revoke a capability
F revoke_cap(caps: i64, cap: i64) -> i64 {
    caps & (~cap)
}

# Check for dangerous capabilities
F is_dangerous(caps: i64) -> i64 {
    dangerous := CAP_FS_WRITE | CAP_NETWORK
    has_cap(caps, dangerous)
}

# ============================================================================
# Test 4: Plugin Manifest Simulation
# ============================================================================

S PluginInfo {
    name: i64,
    version_major: i64,
    version_minor: i64,
    version_patch: i64,
    capabilities: i64
}

# Create plugin info
F create_plugin_info(name: i64, major: i64, minor: i64, patch: i64) -> PluginInfo {
    PluginInfo {
        name: name,
        version_major: major,
        version_minor: minor,
        version_patch: patch,
        capabilities: CAP_CONSOLE
    }
}

# Check version compatibility
# Returns 1 if plugin version >= required version
F is_version_compatible(plugin: PluginInfo, req_major: i64, req_minor: i64, req_patch: i64) -> i64 {
    I plugin.version_major > req_major {
        1
    } E {
        I plugin.version_major < req_major {
            0
        } E {
            I plugin.version_minor > req_minor {
                1
            } E {
                I plugin.version_minor < req_minor {
                    0
                } E {
                    I plugin.version_patch >= req_patch {
                        1
                    } E {
                        0
                    }
                }
            }
        }
    }
}

# ============================================================================
# Test 5: Hot Reload State Machine
# ============================================================================

C STATE_IDLE: i64 = 0
C STATE_WATCHING: i64 = 1
C STATE_COMPILING: i64 = 2
C STATE_LOADING: i64 = 3
C STATE_ERROR: i64 = 4

S HotReloadState {
    state: i64,
    version: i64,
    last_check: i64,
    error_code: i64
}

F hot_reload_init() -> HotReloadState {
    HotReloadState {
        state: STATE_IDLE,
        version: 0,
        last_check: 0,
        error_code: 0
    }
}

F hot_reload_start(s: HotReloadState) -> HotReloadState {
    HotReloadState {
        state: STATE_WATCHING,
        version: s.version,
        last_check: 0,
        error_code: 0
    }
}

F hot_reload_change_detected(s: HotReloadState) -> HotReloadState {
    I s.state == STATE_WATCHING {
        HotReloadState {
            state: STATE_COMPILING,
            version: s.version,
            last_check: s.last_check,
            error_code: 0
        }
    } E {
        s
    }
}

F hot_reload_compile_success(s: HotReloadState) -> HotReloadState {
    I s.state == STATE_COMPILING {
        HotReloadState {
            state: STATE_LOADING,
            version: s.version,
            last_check: s.last_check,
            error_code: 0
        }
    } E {
        s
    }
}

F hot_reload_load_success(s: HotReloadState) -> HotReloadState {
    I s.state == STATE_LOADING {
        HotReloadState {
            state: STATE_WATCHING,
            version: s.version + 1,
            last_check: 0,
            error_code: 0
        }
    } E {
        s
    }
}

# ============================================================================
# Test Runner (using puts for output)
# ============================================================================

F test_module_loading() -> i64 {
    puts("Testing module loading simulation...")

    m := create_test_module(1, 0)

    I m.is_loaded != 1 {
        puts("  FAIL: Module should be loaded")
        R 0
    }

    I m.version != 1 {
        puts("  FAIL: Initial version should be 1")
        R 0
    }

    m2 := reload_test_module(m)

    I m2.version != 2 {
        puts("  FAIL: Version should be 2 after reload")
        R 0
    }

    m3 := unload_test_module(m2)

    I m3.is_loaded != 0 {
        puts("  FAIL: Module should be unloaded")
        R 0
    }

    puts("  PASS: Module loading simulation")
    1
}

F test_resource_limits() -> i64 {
    puts("Testing resource limits...")

    limits := default_resource_limits()

    I limits.max_memory != 67108864 {
        puts("  FAIL: Default max_memory incorrect")
        R 0
    }

    I check_limits(10000000, 1000, limits) != 1 {
        puts("  FAIL: Should be within limits")
        R 0
    }

    I check_limits(100000000, 1000, limits) != 0 {
        puts("  FAIL: Should exceed memory limit")
        R 0
    }

    I check_limits(10000000, 10000, limits) != 0 {
        puts("  FAIL: Should exceed time limit")
        R 0
    }

    puts("  PASS: Resource limits")
    1
}

F test_capabilities() -> i64 {
    puts("Testing capability system...")

    caps := CAP_CONSOLE

    I has_cap(caps, CAP_CONSOLE) != 1 {
        puts("  FAIL: Should have console capability")
        R 0
    }

    I has_cap(caps, CAP_NETWORK) != 0 {
        puts("  FAIL: Should not have network capability")
        R 0
    }

    caps2 := grant_cap(caps, CAP_NETWORK)

    I has_cap(caps2, CAP_NETWORK) != 1 {
        puts("  FAIL: Should have network after grant")
        R 0
    }

    I is_dangerous(caps) != 0 {
        puts("  FAIL: Console-only should not be dangerous")
        R 0
    }

    I is_dangerous(caps2) != 1 {
        puts("  FAIL: Network capability should be dangerous")
        R 0
    }

    caps3 := revoke_cap(caps2, CAP_NETWORK)

    I has_cap(caps3, CAP_NETWORK) != 0 {
        puts("  FAIL: Should not have network after revoke")
        R 0
    }

    puts("  PASS: Capability system")
    1
}

F test_version_compatibility() -> i64 {
    puts("Testing version compatibility...")

    plugin := create_plugin_info(0, 2, 1, 0)

    I is_version_compatible(plugin, 1, 0, 0) != 1 {
        puts("  FAIL: 2.1.0 should be compatible with 1.0.0")
        R 0
    }

    I is_version_compatible(plugin, 2, 0, 0) != 1 {
        puts("  FAIL: 2.1.0 should be compatible with 2.0.0")
        R 0
    }

    I is_version_compatible(plugin, 2, 2, 0) != 0 {
        puts("  FAIL: 2.1.0 should not be compatible with 2.2.0")
        R 0
    }

    I is_version_compatible(plugin, 3, 0, 0) != 0 {
        puts("  FAIL: 2.1.0 should not be compatible with 3.0.0")
        R 0
    }

    puts("  PASS: Version compatibility")
    1
}

F test_hot_reload() -> i64 {
    puts("Testing hot reload state machine...")

    state := mut hot_reload_init()

    I state.state != STATE_IDLE {
        puts("  FAIL: Initial state should be IDLE")
        R 0
    }

    state = hot_reload_start(state)

    I state.state != STATE_WATCHING {
        puts("  FAIL: Should be WATCHING after start")
        R 0
    }

    state = hot_reload_change_detected(state)
    I state.state != STATE_COMPILING {
        puts("  FAIL: Should be COMPILING after change detected")
        R 0
    }

    state = hot_reload_compile_success(state)
    I state.state != STATE_LOADING {
        puts("  FAIL: Should be LOADING after compile success")
        R 0
    }

    state = hot_reload_load_success(state)
    I state.state != STATE_WATCHING {
        puts("  FAIL: Should be WATCHING after load success")
        R 0
    }

    I state.version != 1 {
        puts("  FAIL: Version should be 1 after successful reload")
        R 0
    }

    puts("  PASS: Hot reload state machine")
    1
}

# Main entry point
F main() -> i64 {
    puts("=== Dynamic Module Loading Tests ===")

    r1 := test_module_loading()
    r2 := test_resource_limits()
    r3 := test_capabilities()
    r4 := test_version_compatibility()
    r5 := test_hot_reload()

    passed := r1 + r2 + r3 + r4 + r5
    failed := 5 - passed

    puts("")
    puts("=== Results ===")

    I failed == 0 {
        puts("All 5 tests passed!")
        0
    } E {
        puts("Some tests failed.")
        1
    }
}
