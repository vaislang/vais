# Property-Based Testing Example
# Demonstrates the proptest library for Vais

U std/proptest

# ============================================
# Test Functions
# ============================================

# Test: addition is commutative
F test_add_commutative(x: i64) -> i64 {
    y := x * 2  # Derive y from x
    I x + y == y + x {
        0   # Pass
    } E {
        1   # Fail
    }
}

# Test: multiplication by zero is always zero
F test_mul_zero(x: i64) -> i64 {
    I x * 0 == 0 {
        0
    } E {
        1
    }
}

# Test: absolute value is non-negative
F test_abs_nonnegative(x: i64) -> i64 {
    abs_x := x
    I x < 0 {
        abs_x = 0 - x
    }
    I abs_x >= 0 {
        0
    } E {
        1
    }
}

# Test: division property (should fail for zero)
F test_div_identity(x: i64) -> i64 {
    I x == 0 {
        0   # Skip zero
    }
    I x / x == 1 {
        0
    } E {
        1
    }
}

# Test: positive number squared is positive
F test_positive_square(x: i64) -> i64 {
    I x > 0 {
        # Note: This might overflow for large x
        I x < 100000 {
            sq := x * x
            I sq > 0 {
                0
            } E {
                1
            }
        } E {
            0   # Skip large numbers
        }
    } E {
        0   # Skip non-positive
    }
}

# ============================================
# Main - Run Property Tests
# ============================================

F main() -> i64 {
    puts_str("=== Property-Based Testing Demo ===\n\n")

    # Create test function wrappers as lambdas
    # Lambdas get compiled to function pointers (i64)
    test_add := |x: i64| test_add_commutative(x)
    test_mul := |x: i64| test_mul_zero(x)
    test_abs := |x: i64| test_abs_nonnegative(x)
    test_div := |x: i64| test_div_identity(x)
    test_pos := |x: i64| test_positive_square(x)

    # Create a PropertyRunner
    runner := PropertyRunner.new()
    runner.with_verbose(1)
    runner.with_tests(100)

    # Add tests with appropriate generators
    runner.add("addition_commutative", test_add, Generator.i64_range(-1000, 1000))
    runner.add("multiply_by_zero", test_mul, Generator.i64_any())
    runner.add("abs_nonnegative", test_abs, Generator.i64_range(-1000000, 1000000))
    runner.add("division_identity", test_div, Generator.i64_nonzero())
    runner.add("positive_square", test_pos, Generator.i64_positive())

    # Run all tests and get statistics
    stats := runner.run_all()
    stats.print_summary()

    # Cleanup
    runner.destroy()

    puts_str("\n=== Individual Property Check ===\n")

    # Manual property check
    gen := Generator.i64_range(0, 100)
    result := prop_check("manual_test", test_mul, gen)

    I result.is_passed() {
        puts_str("Manual test PASSED!\n")
    } E {
        puts_str("Manual test FAILED!\n")
        puts_str("Counterexample: ")
        print_i64(result.counterexample)
        puts_str("\n")
    }

    puts_str("\n=== Demonstrating Shrinking ===\n")

    # Test that will fail: x + 1 > x (fails for MAX_INT due to overflow)
    # Using a range that won't overflow
    test_inc := |x: i64| test_increment(x)
    gen2 := Generator.i64_range(0, 9223372036854775806)
    prop := Property.new("increment_increases", test_inc, gen2)
    prop.with_tests(1000)
    result2 := prop.check()

    I result2.is_failed() {
        puts_str("Property failed (expected for overflow test)\n")
        puts_str("Original counterexample: ")
        print_i64(result2.counterexample)
        puts_str("\nShrunk to: ")
        print_i64(result2.shrunk_value)
        puts_str("\nShrinking steps: ")
        print_i64(result2.shrink_steps)
        puts_str("\n")
    } E {
        puts_str("Property passed (no overflow found)\n")
    }

    0
}

# Test that can fail: x + 1 > x (fails at MAX_INT)
F test_increment(x: i64) -> i64 {
    I x + 1 > x {
        0
    } E {
        1
    }
}

# External declarations
X F puts_str(s: str) -> i64
X F print_i64(n: i64) -> i64
