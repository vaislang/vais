# GC Vector Test - Demonstrates GC with dynamic data structures
# Run with: vaisc build gc_vec_test.vais --gc

U std/gc
U std/vec

# Simple GC-managed vector
S GcVec {
    data: i64,     # Pointer to data (GC-managed)
    len: i64,
    cap: i64
}

X GcVec {
    F new() -> GcVec {
        # Initialize GC if not already done
        gc_init()

        cap := 4
        size := cap * 8  # i64 size

        # Allocate using GC
        data_ptr := gc_alloc(size, 100)  # type_id = 100 for GcVec

        # Register as root to prevent collection
        gc_add_root(data_ptr)

        GcVec {
            data: data_ptr,
            len: 0,
            cap: cap
        }
    }

    F push(&self, value: i64) -> i64 {
        # Check if we need to grow
        L self.len >= self.cap {
            self.grow()
        }

        # Store value
        offset := self.len * 8
        ptr := self.data + offset
        store_i64(ptr, value)

        self.len = self.len + 1
        0
    }

    F get(&self, index: i64) -> i64 {
        L index >= self.len {
            R 0  # Out of bounds
        }

        offset := index * 8
        ptr := self.data + offset
        load_i64(ptr)
    }

    F grow(&self) -> i64 {
        # Double capacity
        new_cap := self.cap * 2
        new_size := new_cap * 8

        # Allocate new GC memory
        new_data := gc_alloc(new_size, 100)

        # Copy old data
        i := 0
        L i < self.len {
            old_offset := i * 8
            new_offset := i * 8
            value := load_i64(self.data + old_offset)
            store_i64(new_data + new_offset, value)
            i = i + 1
        }

        # Remove old root and add new root
        gc_remove_root(self.data)
        gc_add_root(new_data)

        # Update pointers
        self.data = new_data
        self.cap = new_cap

        0
    }

    F len(&self) -> i64 {
        self.len
    }

    F drop(&self) -> i64 {
        # Unregister root - GC will collect
        gc_remove_root(self.data)
        0
    }
}

# Memory helper functions
X F store_i64(ptr: i64, value: i64) -> i64
X F load_i64(ptr: i64) -> i64

F test_gc_vec() -> i64 {
    puts("Testing GC-managed vector...")

    vec := GcVec::new()

    # Add some elements
    i := 0
    L i < 10 {
        vec.push(i * 10)
        i = i + 1
    }

    # Verify elements
    printf("Vector length: %ld\n", vec.len())

    i = 0
    L i < vec.len() {
        val := vec.get(i)
        printf("  vec[%ld] = %ld\n", i, val)
        i = i + 1
    }

    # Test growth
    puts("\nTesting vector growth...")
    i = 0
    L i < 20 {
        vec.push(i * 100)
        i = i + 1
    }

    printf("Vector length after growth: %ld\n", vec.len())

    # Cleanup
    vec.drop()

    0
}

F main() -> i64 {
    puts("=== GC Vector Test ===\n")

    gc_init()

    test_gc_vec()

    puts("\n=== GC Statistics ===")
    gc_print_stats()

    # Force final collection
    gc_collect()

    puts("\n=== After Final Collection ===")
    gc_print_stats()

    0
}
