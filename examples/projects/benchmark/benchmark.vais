# Performance Benchmark Suite - Vais vs C comparison
# Implements common algorithms for performance testing:
# 1. Fibonacci (recursive) - tests function call overhead
# 2. Sum 1 to N (tail recursive) - tests recursive loop performance
# 3. Prime counting - tests conditional logic and arithmetic

# === Algorithm 1: Fibonacci (Recursive) ===
# Classic recursive Fibonacci with self-recursion operator @
F fib(n: i64) -> i64 = n < 2 ? n : @(n - 1) + @(n - 2)

# === Algorithm 2: Sum 1 to N (Iterative with Loop) ===
# Uses tail recursion to simulate iteration
F sum_to_n_helper(n: i64, acc: i64) -> i64 =
    I n == 0 { acc } E { @(n - 1, acc + n) }

F sum_to_n(n: i64) -> i64 = sum_to_n_helper(n, 0)

# === Algorithm 3: Prime Counting ===
# Trial division primality test helper
F is_prime_helper(n: i64, d: i64) -> i64 =
    I d * d > n { 1 }
    E I n % d == 0 { 0 }
    E { @(n, d + 2) }

# Check if n is prime (returns 1 for prime, 0 for not)
F is_prime(n: i64) -> i64 =
    I n < 2 { 0 }
    E I n < 4 { 1 }
    E I n % 2 == 0 { 0 }
    E { is_prime_helper(n, 3) }

# Count primes up to n using tail recursion
F count_primes_helper(n: i64, current: i64, count: i64) -> i64 =
    I current > n { count }
    E { @(n, current + 1, count + is_prime(current)) }

F count_primes(n: i64) -> i64 = count_primes_helper(n, 2, 0)

# === Main Benchmark Runner ===
F main() -> i64 {
    puts("=== Vais Performance Benchmark Suite ===")
    puts("")

    # Benchmark 1: Fibonacci(35)
    puts("Benchmark 1: Fibonacci(35)")
    result1 := fib(35)
    printf("Result: %ld\n", result1)
    puts("")

    # Benchmark 2: Sum 1 to 100,000
    puts("Benchmark 2: Sum 1 to 100,000")
    result2 := sum_to_n(100000)
    printf("Result: %ld\n", result2)
    puts("")

    # Benchmark 3: Count primes up to 5,000
    puts("Benchmark 3: Count primes up to 5,000")
    result3 := count_primes(5000)
    printf("Result: %ld\n", result3)
    puts("")

    puts("All benchmarks completed!")
    0
}
