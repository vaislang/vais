# Math CLI Tool - A real-world Vais project
# Demonstrates: functions, recursion, structs, arrays, control flow, output
#
# This CLI tool computes various mathematical functions and prints results.
# It serves as a validation of Vais language capabilities for real-world use.

# === Core Math Functions ===

# Fibonacci with self-recursion operator @
F fib(n: i64) -> i64 = n < 2 ? n : @(n - 1) + @(n - 2)

# Factorial using self-recursion
F factorial(n: i64) -> i64 = n < 2 ? 1 : n * @(n - 1)

# Greatest Common Divisor (Euclidean algorithm)
F gcd(a: i64, b: i64) -> i64 = I b == 0 { a } E { gcd(b, a % b) }

# Least Common Multiple
F lcm(a: i64, b: i64) -> i64 = a / gcd(a, b) * b

# Absolute value
F abs(x: i64) -> i64 = I x < 0 { 0 - x } E { x }

# Power function (base^exp)
F power(base: i64, exp: i64) -> i64 =
    I exp == 0 { 1 }
    E I exp == 1 { base }
    E { base * @(base, exp - 1) }

# Integer square root (Newton's method, iterative via recursion)
F isqrt_helper(n: i64, guess: i64) -> i64 {
    next := (guess + n / guess) / 2
    I next == guess { guess }
    E I next > guess { guess }
    E { @(n, next) }
}

F isqrt(n: i64) -> i64 = I n < 2 { n } E { isqrt_helper(n, n / 2) }

# === Prime Number Functions ===

# Check if n is divisible by d
F is_divisible(n: i64, d: i64) -> i64 = n % d == 0 ? 1 : 0

# Trial division primality test helper
F is_prime_helper(n: i64, d: i64) -> i64 =
    I d * d > n { 1 }
    E I n % d == 0 { 0 }
    E { @(n, d + 2) }

# Check if n is prime (returns 1 for prime, 0 for not)
F is_prime(n: i64) -> i64 =
    I n < 2 { 0 }
    E I n < 4 { 1 }
    E I n % 2 == 0 { 0 }
    E { is_prime_helper(n, 3) }

# Count primes up to n (prime counting function)
F count_primes_helper(n: i64, current: i64, count: i64) -> i64 =
    I current > n { count }
    E { @(n, current + 1, count + is_prime(current)) }

F count_primes(n: i64) -> i64 = count_primes_helper(n, 2, 0)

# Nth prime number
F nth_prime_helper(target: i64, current: i64, found: i64) -> i64 =
    I found == target { current - 1 }
    E I is_prime(current) == 1 { @(target, current + 1, found + 1) }
    E { @(target, current + 1, found) }

F nth_prime(n: i64) -> i64 = nth_prime_helper(n, 2, 0)

# === Sequence Functions ===

# Sum of first n natural numbers (tail recursive)
F sum_to(n: i64) -> i64 = sum_to_acc(n, 0)
F sum_to_acc(n: i64, acc: i64) -> i64 =
    I n == 0 { acc } E { @(n - 1, acc + n) }

# Triangular number
F triangular(n: i64) -> i64 = n * (n + 1) / 2

# === Output Helpers ===

# Print a single digit (0-9)
F print_digit(d: i64) -> i64 {
    putchar(d + 48)
    0
}

# Print a number (positive integers, handles multi-digit)
F print_num_helper(n: i64) -> i64 =
    I n < 10 { print_digit(n) }
    E { print_num_helper(n / 10); print_digit(n % 10) }

F print_num(n: i64) -> i64 =
    I n < 0 { putchar(45); print_num_helper(0 - n) }
    E I n == 0 { print_digit(0) }
    E { print_num_helper(n) }

# Print newline
F newline() -> i64 { putchar(10); 0 }

# Print a labeled result: "label: value\n"
F print_result(value: i64) -> i64 {
    print_num(value)
    newline()
}

# === Test & Demo Suite ===

F demo_fibonacci() -> i64 {
    puts("=== Fibonacci ===")
    puts("fib(0) = "); print_result(fib(0))
    puts("fib(1) = "); print_result(fib(1))
    puts("fib(5) = "); print_result(fib(5))
    puts("fib(10) = "); print_result(fib(10))
    puts("fib(15) = "); print_result(fib(15))
    0
}

F demo_factorial() -> i64 {
    puts("=== Factorial ===")
    puts("fact(0) = "); print_result(factorial(0))
    puts("fact(1) = "); print_result(factorial(1))
    puts("fact(5) = "); print_result(factorial(5))
    puts("fact(10) = "); print_result(factorial(10))
    0
}

F demo_primes() -> i64 {
    puts("=== Prime Numbers ===")
    puts("is_prime(2) = "); print_result(is_prime(2))
    puts("is_prime(7) = "); print_result(is_prime(7))
    puts("is_prime(10) = "); print_result(is_prime(10))
    puts("is_prime(97) = "); print_result(is_prime(97))
    puts("count_primes(100) = "); print_result(count_primes(100))
    puts("nth_prime(10) = "); print_result(nth_prime(10))
    0
}

F demo_math() -> i64 {
    puts("=== Math Operations ===")
    puts("gcd(48, 18) = "); print_result(gcd(48, 18))
    puts("lcm(12, 8) = "); print_result(lcm(12, 8))
    puts("power(2, 10) = "); print_result(power(2, 10))
    puts("isqrt(144) = "); print_result(isqrt(144))
    puts("abs(-42) = "); print_result(abs(0 - 42))
    puts("sum_to(100) = "); print_result(sum_to(100))
    puts("triangular(10) = "); print_result(triangular(10))
    0
}

# === Main Entry Point ===

F main() -> i64 {
    puts("Math CLI Tool v1.0 - Written in Vais")
    puts("")
    demo_fibonacci()
    puts("")
    demo_factorial()
    puts("")
    demo_primes()
    puts("")
    demo_math()
    puts("")
    puts("All computations completed successfully!")
    0
}
