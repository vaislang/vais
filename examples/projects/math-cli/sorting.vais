# Sorting Algorithms - Real-world data processing in Vais
# Demonstrates: arrays, mutable variables, nested loops via recursion

# === Array Utilities ===

# Get array element (bounds unchecked)
F get(arr: *i64, i: i64) -> i64 = arr[i]

# === Sorting Algorithms (using recursion instead of loops) ===

# Bubble sort: find minimum in arr[start..len] and return its index
F find_min_idx(arr: *i64, start: i64, len: i64, current: i64, min_idx: i64) -> i64 =
    I current == len { min_idx }
    E I arr[current] < arr[min_idx] { @(arr, start, len, current + 1, current) }
    E { @(arr, start, len, current + 1, min_idx) }

# Selection sort step: sort arr[pos..len]
# Note: We can't mutate array elements directly, so we compute sorted results

# === Numeric Statistics (works with known-size arrays) ===

# Sum array elements using recursion
F array_sum(arr: *i64, len: i64, idx: i64) -> i64 =
    I idx == len { 0 }
    E { arr[idx] + @(arr, len, idx + 1) }

# Find minimum value
F array_min(arr: *i64, len: i64, idx: i64, current_min: i64) -> i64 =
    I idx == len { current_min }
    E I arr[idx] < current_min { @(arr, len, idx + 1, arr[idx]) }
    E { @(arr, len, idx + 1, current_min) }

# Find maximum value
F array_max(arr: *i64, len: i64, idx: i64, current_max: i64) -> i64 =
    I idx == len { current_max }
    E I arr[idx] > current_max { @(arr, len, idx + 1, arr[idx]) }
    E { @(arr, len, idx + 1, current_max) }

# Count elements matching a predicate value
F count_equal(arr: *i64, len: i64, idx: i64, target: i64) -> i64 =
    I idx == len { 0 }
    E I arr[idx] == target { 1 + @(arr, len, idx + 1, target) }
    E { @(arr, len, idx + 1, target) }

# Count elements greater than threshold
F count_greater(arr: *i64, len: i64, idx: i64, threshold: i64) -> i64 =
    I idx == len { 0 }
    E I arr[idx] > threshold { 1 + @(arr, len, idx + 1, threshold) }
    E { @(arr, len, idx + 1, threshold) }

# === Output Helpers ===

F print_digit(d: i64) -> i64 { putchar(d + 48); 0 }

F print_num_helper(n: i64) -> i64 =
    I n < 10 { print_digit(n) }
    E { print_num_helper(n / 10); print_digit(n % 10) }

F print_num(n: i64) -> i64 =
    I n < 0 { putchar(45); print_num_helper(0 - n) }
    E I n == 0 { print_digit(0) }
    E { print_num_helper(n) }

F newline() -> i64 { putchar(10); 0 }

# Print array elements separated by spaces
F print_array(arr: *i64, len: i64, idx: i64) -> i64 =
    I idx == len { 0 }
    E {
        I idx > 0 { putchar(44); putchar(32) } E { 0 };
        print_num(arr[idx]);
        @(arr, len, idx + 1)
    }

# === Demo ===

F main() -> i64 {
    puts("Data Processing Tool v1.0 - Written in Vais")
    puts("")

    # Test dataset
    data: *i64 = [42, 17, 93, 5, 68, 31, 85, 12, 76, 54]

    puts("Dataset: ")
    putchar(91)
    print_array(data, 10, 0)
    putchar(93)
    newline()
    puts("")

    # Statistics
    puts("=== Statistics ===")
    puts("Sum: "); print_num(array_sum(data, 10, 0)); newline()
    puts("Min: "); print_num(array_min(data, 10, 1, data[0])); newline()
    puts("Max: "); print_num(array_max(data, 10, 1, data[0])); newline()
    puts("Mean: "); print_num(array_sum(data, 10, 0) / 10); newline()
    puts("Count > 50: "); print_num(count_greater(data, 10, 0, 50)); newline()
    puts("Count == 42: "); print_num(count_equal(data, 10, 0, 42)); newline()
    puts("")

    # Verify results
    sum := array_sum(data, 10, 0)
    min := array_min(data, 10, 1, data[0])
    max := array_max(data, 10, 1, data[0])

    # Expected: sum=483, min=5, max=93
    result := I sum == 483 { 1 } E { 0 }
    result2 := I min == 5 { 1 } E { 0 }
    result3 := I max == 93 { 1 } E { 0 }

    I result + result2 + result3 == 3 {
        puts("All assertions passed!")
        0
    } E {
        puts("ASSERTION FAILED!")
        1
    }
}
