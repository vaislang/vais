# Vais Self-Hosting Compiler - Code Generator Module
# Generates LLVM IR from typed AST
# Note: This is a simplified code generator for bootstrapping purposes

# ============================================================================
# LLVM IR Generation Constants
# ============================================================================

# Binary operators for LLVM
F OP_ADD() -> i64 = 1
F OP_SUB() -> i64 = 2
F OP_MUL() -> i64 = 3
F OP_DIV() -> i64 = 4
F OP_MOD() -> i64 = 5
F OP_LT() -> i64 = 6
F OP_LTE() -> i64 = 7
F OP_GT() -> i64 = 8
F OP_GTE() -> i64 = 9
F OP_EQ() -> i64 = 10
F OP_NEQ() -> i64 = 11
F OP_AND() -> i64 = 12
F OP_OR() -> i64 = 13
F OP_BIT_AND() -> i64 = 14
F OP_BIT_OR() -> i64 = 15
F OP_BIT_XOR() -> i64 = 16
F OP_SHL() -> i64 = 17
F OP_SHR() -> i64 = 18

# Unary operators
F UOP_NEG() -> i64 = 1
F UOP_NOT() -> i64 = 2
F UOP_BITNOT() -> i64 = 3

# Type kinds for LLVM mapping
F LLVM_VOID() -> i64 = 0
F LLVM_I1() -> i64 = 1
F LLVM_I8() -> i64 = 2
F LLVM_I16() -> i64 = 3
F LLVM_I32() -> i64 = 4
F LLVM_I64() -> i64 = 5
F LLVM_I128() -> i64 = 6
F LLVM_FLOAT() -> i64 = 7
F LLVM_DOUBLE() -> i64 = 8
F LLVM_PTR() -> i64 = 9
F LLVM_STRUCT() -> i64 = 10

# ============================================================================
# String Buffer for IR Output
# ============================================================================

S StringBuffer {
    data: i64,       # Pointer to string data
    len: i64,        # Current length
    cap: i64         # Capacity
}

X StringBuffer {
    F new(initial_cap: i64) -> StringBuffer {
        data := malloc(initial_cap)
        StringBuffer { data: data, len: 0, cap: initial_cap }
    }

    F append_byte(&self, byte: i64) -> i64 {
        I self.len >= self.cap {
            @.grow()
            0
        } E { 0 }
        store_byte(self.data + self.len, byte)
        self.len = self.len + 1
        1
    }

    F append_ptr(&self, ptr: i64, len: i64) -> i64 {
        I self.len + len > self.cap {
            @.grow_to(self.len + len + 1024)
            0
        } E { 0 }
        memcpy(self.data + self.len, ptr, len)
        self.len = self.len + len
        1
    }

    F append_cstr(&self, s: str) -> i64 {
        len := strlen(s)
        I self.len + len > self.cap {
            @.grow_to(self.len + len + 1024)
            0
        } E { 0 }
        memcpy_str(self.data + self.len, s, len)
        self.len = self.len + len
        1
    }

    F append_i64(&self, value: i64) -> i64 {
        # Convert i64 to string and append
        I value == 0 {
            @.append_byte(48)  # '0'
            1
        } E I value < 0 {
            @.append_byte(45)  # '-'
            @.append_i64(0 - value)
        } E {
            # Recursively build digits
            I value >= 10 {
                @.append_i64(value / 10)
                0
            } E { 0 }
            digit := (value % 10) + 48
            @.append_byte(digit)
            1
        }
    }

    F append_newline(&self) -> i64 = @.append_byte(10)

    F grow(&self) -> i64 {
        @.grow_to(self.cap * 2)
    }

    F grow_to(&self, new_cap: i64) -> i64 {
        new_data := malloc(new_cap)
        memcpy(new_data, self.data, self.len)
        free(self.data)
        self.data = new_data
        self.cap = new_cap
        1
    }

    F get_ptr(&self) -> i64 = self.data
    F get_len(&self) -> i64 = self.len

    F clear(&self) -> i64 {
        self.len = 0
        1
    }

    F drop(&self) -> i64 {
        free(self.data)
        1
    }
}

# ============================================================================
# Local Variable Info
# ============================================================================

S LocalVar {
    name_idx: i64,       # String pool index
    llvm_name_ptr: i64,  # LLVM register name (e.g., "%x", "%1")
    llvm_name_len: i64,
    type_kind: i64,      # LLVM type kind
    is_param: i64,       # 1 if function parameter
    is_alloca: i64       # 1 if stack allocated (has pointer semantics)
}

X LocalVar {
    F size() -> i64 = 48

    F new(name_idx: i64, llvm_ptr: i64, llvm_len: i64, type_kind: i64, is_param: i64) -> LocalVar = LocalVar {
        name_idx: name_idx,
        llvm_name_ptr: llvm_ptr,
        llvm_name_len: llvm_len,
        type_kind: type_kind,
        is_param: is_param,
        is_alloca: 0
    }
}

# ============================================================================
# Function Info
# ============================================================================

S FunctionInfo {
    name_idx: i64,
    params_ptr: i64,      # Array of (name_idx, type_kind) pairs
    params_len: i64,
    ret_type: i64,        # LLVM type kind
    is_extern: i64
}

X FunctionInfo {
    F size() -> i64 = 40

    F new(name_idx: i64) -> FunctionInfo = FunctionInfo {
        name_idx: name_idx,
        params_ptr: 0, params_len: 0,
        ret_type: LLVM_VOID(),
        is_extern: 0
    }
}

# ============================================================================
# Struct Info
# ============================================================================

S StructFieldInfo {
    name_idx: i64,
    type_kind: i64,
    offset: i64
}

X StructFieldInfo {
    F size() -> i64 = 24
}

S StructTypeInfo {
    name_idx: i64,
    fields_ptr: i64,
    fields_len: i64,
    total_size: i64
}

X StructTypeInfo {
    F size() -> i64 = 32

    F new(name_idx: i64) -> StructTypeInfo = StructTypeInfo {
        name_idx: name_idx,
        fields_ptr: 0, fields_len: 0,
        total_size: 0
    }
}

# ============================================================================
# Loop Context (for break/continue)
# ============================================================================

S LoopContext {
    break_label_ptr: i64,
    break_label_len: i64,
    continue_label_ptr: i64,
    continue_label_len: i64
}

X LoopContext {
    F size() -> i64 = 32
}

# ============================================================================
# Code Generator
# ============================================================================

S CodeGenerator {
    # Output buffer
    output: i64,         # Pointer to StringBuffer

    # String pool reference
    sp_data: i64,
    sp_offsets: i64,
    sp_count: i64,

    # Registered functions
    functions_ptr: i64,
    functions_len: i64,
    functions_cap: i64,

    # Registered structs
    structs_ptr: i64,
    structs_len: i64,
    structs_cap: i64,

    # Local variables in current function
    locals_ptr: i64,
    locals_len: i64,
    locals_cap: i64,

    # Loop stack for break/continue
    loop_stack_ptr: i64,
    loop_stack_len: i64,
    loop_stack_cap: i64,

    # Counters
    reg_counter: i64,
    label_counter: i64,
    string_counter: i64,

    # String constants (for global storage)
    strings_ptr: i64,     # Array of (name_ptr, name_len, value_ptr, value_len)
    strings_len: i64,
    strings_cap: i64,

    # Current function context
    current_fn_name_idx: i64,
    current_fn_ret_type: i64,

    # Temp buffer for building strings
    temp_buf: i64,        # Pointer to StringBuffer

    # Lambda functions buffer (emitted after main functions)
    lambda_buf: i64,      # Pointer to StringBuffer for lambda function defs
    lambda_counter: i64,  # Counter for generating unique lambda names

    # Monomorphization support
    # Generic function AST pointers (saved for later specialization)
    generic_fns_ptr: i64,    # Array of fn_ptr (i64 pointers to FunctionDef AST nodes)
    generic_fns_len: i64,
    generic_fns_cap: i64,

    # Monomorphization entries from type checker
    # Each entry: (fn_name_idx: i64, type_args_ptr: i64, type_args_len: i64) = 24 bytes
    mono_entries_ptr: i64,
    mono_entries_len: i64,
    mono_entries_cap: i64,

    # Current generic bindings for monomorphized function generation
    # Each binding: (generic_name_idx: i64, concrete_type_kind: i64) = 16 bytes
    mono_bind_keys_ptr: i64,
    mono_bind_values_ptr: i64,
    mono_bind_len: i64,
    mono_bind_cap: i64
}

X CodeGenerator {
    F new() -> CodeGenerator {
        output_buf := malloc(88)  # StringBuffer size (approximated)
        temp := StringBuffer.new(8192)
        store_i64(output_buf, temp.data)
        store_i64(output_buf + 8, temp.len)
        store_i64(output_buf + 16, temp.cap)

        temp_buf := malloc(88)
        temp2 := StringBuffer.new(4096)
        store_i64(temp_buf, temp2.data)
        store_i64(temp_buf + 8, temp2.len)
        store_i64(temp_buf + 16, temp2.cap)

        lambda_buf := malloc(88)
        lambda_sb := StringBuffer.new(4096)
        store_i64(lambda_buf, lambda_sb.data)
        store_i64(lambda_buf + 8, lambda_sb.len)
        store_i64(lambda_buf + 16, lambda_sb.cap)

        CodeGenerator {
            output: output_buf,
            sp_data: 0, sp_offsets: 0, sp_count: 0,
            functions_ptr: malloc(128 * FunctionInfo.size()),
            functions_len: 0, functions_cap: 128,
            structs_ptr: malloc(64 * StructTypeInfo.size()),
            structs_len: 0, structs_cap: 64,
            locals_ptr: malloc(64 * LocalVar.size()),
            locals_len: 0, locals_cap: 64,
            loop_stack_ptr: malloc(16 * LoopContext.size()),
            loop_stack_len: 0, loop_stack_cap: 16,
            reg_counter: 0,
            label_counter: 0,
            string_counter: 0,
            strings_ptr: malloc(256 * 32),  # 256 strings, 32 bytes each
            strings_len: 0, strings_cap: 256,
            current_fn_name_idx: 0,
            current_fn_ret_type: LLVM_VOID(),
            temp_buf: temp_buf,
            lambda_buf: lambda_buf,
            lambda_counter: 0,
            generic_fns_ptr: malloc(64 * 8),
            generic_fns_len: 0, generic_fns_cap: 64,
            mono_entries_ptr: malloc(64 * 24),
            mono_entries_len: 0, mono_entries_cap: 64,
            mono_bind_keys_ptr: malloc(32 * 8),
            mono_bind_values_ptr: malloc(32 * 8),
            mono_bind_len: 0, mono_bind_cap: 32
        }
    }

    # ========== String Pool Access ==========

    F set_string_pool(&self, sp_data: i64, sp_offsets: i64, sp_count: i64) -> i64 {
        self.sp_data = sp_data
        self.sp_offsets = sp_offsets
        self.sp_count = sp_count
        1
    }

    F get_string_ptr(&self, idx: i64) -> i64 {
        entry_ptr := self.sp_offsets + idx * 16
        offset := load_i64(entry_ptr)
        self.sp_data + offset
    }

    F get_string_len(&self, idx: i64) -> i64 {
        entry_ptr := self.sp_offsets + idx * 16
        load_i64(entry_ptr + 8)
    }

    # ========== Output Methods ==========

    F emit_ptr(&self, ptr: i64, len: i64) -> i64 {
        buf_data: mut i64 = load_i64(self.output)
        buf_len := load_i64(self.output + 8)
        buf_cap := load_i64(self.output + 16)

        I buf_len + len > buf_cap {
            new_cap := (buf_cap + len) * 2
            new_data := malloc(new_cap)
            memcpy(new_data, buf_data, buf_len)
            free(buf_data)
            store_i64(self.output, new_data)
            store_i64(self.output + 16, new_cap)
            buf_data = new_data
            0
        } E { 0 }

        memcpy(buf_data + buf_len, ptr, len)
        store_i64(self.output + 8, buf_len + len)
        1
    }

    F emit(&self, ptr: i64, len: i64) -> i64 = @.emit_ptr(ptr, len)

    F emit_cstr(&self, s: str) -> i64 {
        len := strlen(s)
        buf_data: mut i64 = load_i64(self.output)
        buf_len := load_i64(self.output + 8)
        buf_cap := load_i64(self.output + 16)

        I buf_len + len > buf_cap {
            new_cap := (buf_cap + len) * 2
            new_data := malloc(new_cap)
            memcpy(new_data, buf_data, buf_len)
            free(buf_data)
            store_i64(self.output, new_data)
            store_i64(self.output + 16, new_cap)
            buf_data = new_data
            0
        } E { 0 }

        memcpy_str(buf_data + buf_len, s, len)
        store_i64(self.output + 8, buf_len + len)
        1
    }

    F emit_i64(&self, value: i64) -> i64 {
        # Clear temp buffer
        store_i64(self.temp_buf + 8, 0)
        tb_data := load_i64(self.temp_buf)

        I value == 0 {
            store_byte(tb_data, 48)
            @.emit_ptr(tb_data, 1)
        } E I value < 0 {
            store_byte(tb_data, 45)
            @.emit_ptr(tb_data, 1)
            @.emit_i64(0 - value)
        } E {
            @.emit_positive_i64(value)
        }
    }

    F emit_positive_i64(&self, value: i64) -> i64 {
        I value == 0 { R 1 }
        @.emit_positive_i64(value / 10)
        digit := (value % 10) + 48
        tb_data := load_i64(self.temp_buf)
        store_byte(tb_data, digit)
        @.emit_ptr(tb_data, 1)
    }

    F emit_newline(&self) -> i64 {
        tb_data := load_i64(self.temp_buf)
        store_byte(tb_data, 10)
        @.emit_ptr(tb_data, 1)
    }

    F emit_string_idx(&self, idx: i64) -> i64 {
        ptr := @.get_string_ptr(idx)
        len := @.get_string_len(idx)
        @.emit_ptr(ptr, len)
    }

    # ========== Register/Label Generation ==========

    F fresh_reg(&self) -> i64 {
        n := self.reg_counter
        self.reg_counter = self.reg_counter + 1
        n
    }

    F fresh_label(&self) -> i64 {
        n := self.label_counter
        self.label_counter = self.label_counter + 1
        n
    }

    F emit_reg(&self, n: i64) -> i64 {
        @.emit_cstr("%")
        @.emit_i64(n)
    }

    F emit_label(&self, prefix: str, n: i64) -> i64 {
        @.emit_cstr(prefix)
        @.emit_i64(n)
    }

    # ========== Type Conversion ==========

    F type_to_llvm_str(&self, type_kind: i64) -> i64 {
        I type_kind == LLVM_VOID() { @.emit_cstr("void") }
        E I type_kind == LLVM_I1() { @.emit_cstr("i1") }
        E I type_kind == LLVM_I8() { @.emit_cstr("i8") }
        E I type_kind == LLVM_I16() { @.emit_cstr("i16") }
        E I type_kind == LLVM_I32() { @.emit_cstr("i32") }
        E I type_kind == LLVM_I64() { @.emit_cstr("i64") }
        E I type_kind == LLVM_I128() { @.emit_cstr("i128") }
        E I type_kind == LLVM_FLOAT() { @.emit_cstr("float") }
        E I type_kind == LLVM_DOUBLE() { @.emit_cstr("double") }
        E I type_kind == LLVM_PTR() { @.emit_cstr("i8*") }
        E { @.emit_cstr("i64") }  # Default
    }

    F resolved_type_to_llvm(&self, resolved_kind: i64) -> i64 {
        # Map ResolvedType kind to LLVM type kind
        # TY_I8 = 1, TY_I16 = 2, TY_I32 = 3, TY_I64 = 4, etc.
        I resolved_kind == 1 { LLVM_I8() }
        E I resolved_kind == 2 { LLVM_I16() }
        E I resolved_kind == 3 { LLVM_I32() }
        E I resolved_kind == 4 { LLVM_I64() }
        E I resolved_kind == 5 { LLVM_I128() }
        E I resolved_kind == 6 { LLVM_I8() }   # u8
        E I resolved_kind == 7 { LLVM_I16() }  # u16
        E I resolved_kind == 8 { LLVM_I32() }  # u32
        E I resolved_kind == 9 { LLVM_I64() }  # u64
        E I resolved_kind == 10 { LLVM_I128() } # u128
        E I resolved_kind == 11 { LLVM_FLOAT() }
        E I resolved_kind == 12 { LLVM_DOUBLE() }
        E I resolved_kind == 13 { LLVM_I1() }  # bool
        E I resolved_kind == 14 { LLVM_PTR() } # str
        E I resolved_kind == 15 { LLVM_VOID() } # unit
        E I resolved_kind == 21 { LLVM_PTR() } # pointer
        E I resolved_kind == 22 { LLVM_PTR() } # ref
        E I resolved_kind == 23 { LLVM_PTR() } # ref_mut
        E { LLVM_I64() }
    }

    # ========== Local Variables ==========

    F add_local(&self, name_idx: i64, llvm_ptr: i64, llvm_len: i64, type_kind: i64, is_param: i64) -> i64 {
        I self.locals_len >= self.locals_cap {
            new_cap := self.locals_cap * 2
            new_ptr := malloc(new_cap * LocalVar.size())
            memcpy(new_ptr, self.locals_ptr, self.locals_len * LocalVar.size())
            free(self.locals_ptr)
            self.locals_ptr = new_ptr
            self.locals_cap = new_cap
            0
        } E { 0 }

        ptr := self.locals_ptr + self.locals_len * LocalVar.size()
        store_i64(ptr, name_idx)
        store_i64(ptr + 8, llvm_ptr)
        store_i64(ptr + 16, llvm_len)
        store_i64(ptr + 24, type_kind)
        store_i64(ptr + 32, is_param)
        store_i64(ptr + 40, 0)  # is_alloca

        self.locals_len = self.locals_len + 1
        self.locals_len - 1
    }

    F find_local(&self, name_idx: i64) -> i64 {
        i: mut i64 = self.locals_len
        L { I i == 0 { B }
            i = i - 1
            ptr := self.locals_ptr + i * LocalVar.size()
            local_name := load_i64(ptr)
            I local_name == name_idx {
                R ptr
            } E { 0 }
        }
        0  # Not found
    }

    F clear_locals(&self) -> i64 {
        self.locals_len = 0
        1
    }

    # ========== Function Registration ==========

    F add_function(&self, name_idx: i64, ret_type: i64, is_extern: i64) -> i64 {
        I self.functions_len >= self.functions_cap {
            new_cap := self.functions_cap * 2
            new_ptr := malloc(new_cap * FunctionInfo.size())
            memcpy(new_ptr, self.functions_ptr, self.functions_len * FunctionInfo.size())
            free(self.functions_ptr)
            self.functions_ptr = new_ptr
            self.functions_cap = new_cap
            0
        } E { 0 }

        ptr := self.functions_ptr + self.functions_len * FunctionInfo.size()
        store_i64(ptr, name_idx)
        store_i64(ptr + 8, 0)    # params_ptr
        store_i64(ptr + 16, 0)   # params_len
        store_i64(ptr + 24, ret_type)
        store_i64(ptr + 32, is_extern)

        self.functions_len = self.functions_len + 1
        ptr
    }

    F find_function(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.functions_len { B }
            ptr := self.functions_ptr + i * FunctionInfo.size()
            fn_name := load_i64(ptr)
            I fn_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0
    }

    # ========== Struct Registration ==========

    F add_struct(&self, name_idx: i64) -> i64 {
        I self.structs_len >= self.structs_cap {
            new_cap := self.structs_cap * 2
            new_ptr := malloc(new_cap * StructTypeInfo.size())
            memcpy(new_ptr, self.structs_ptr, self.structs_len * StructTypeInfo.size())
            free(self.structs_ptr)
            self.structs_ptr = new_ptr
            self.structs_cap = new_cap
            0
        } E { 0 }

        ptr := self.structs_ptr + self.structs_len * StructTypeInfo.size()
        store_i64(ptr, name_idx)
        store_i64(ptr + 8, 0)   # fields_ptr
        store_i64(ptr + 16, 0)  # fields_len
        store_i64(ptr + 24, 0)  # total_size

        self.structs_len = self.structs_len + 1
        ptr
    }

    F find_struct(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.structs_len { B }
            ptr := self.structs_ptr + i * StructTypeInfo.size()
            struct_name := load_i64(ptr)
            I struct_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0
    }

    # ========== Loop Stack ==========

    F push_loop(&self, break_ptr: i64, break_len: i64, continue_ptr: i64, continue_len: i64) -> i64 {
        I self.loop_stack_len >= self.loop_stack_cap {
            new_cap := self.loop_stack_cap * 2
            new_ptr := malloc(new_cap * LoopContext.size())
            memcpy(new_ptr, self.loop_stack_ptr, self.loop_stack_len * LoopContext.size())
            free(self.loop_stack_ptr)
            self.loop_stack_ptr = new_ptr
            self.loop_stack_cap = new_cap
            0
        } E { 0 }

        ptr := self.loop_stack_ptr + self.loop_stack_len * LoopContext.size()
        store_i64(ptr, break_ptr)
        store_i64(ptr + 8, break_len)
        store_i64(ptr + 16, continue_ptr)
        store_i64(ptr + 24, continue_len)

        self.loop_stack_len = self.loop_stack_len + 1
        1
    }

    F pop_loop(&self) -> i64 {
        I self.loop_stack_len > 0 {
            self.loop_stack_len = self.loop_stack_len - 1
            1
        } E { 0 }
    }

    F current_loop(&self) -> i64 {
        I self.loop_stack_len == 0 { 0 }
        E { self.loop_stack_ptr + (self.loop_stack_len - 1) * LoopContext.size() }
    }

    # ========== Monomorphization Support ==========

    # Save a generic function's AST pointer for later specialization
    F save_generic_fn(&self, fn_ptr: i64) -> i64 {
        I self.generic_fns_len >= self.generic_fns_cap {
            new_cap := self.generic_fns_cap * 2
            new_ptr := malloc(new_cap * 8)
            memcpy(new_ptr, self.generic_fns_ptr, self.generic_fns_len * 8)
            free(self.generic_fns_ptr)
            self.generic_fns_ptr = new_ptr
            self.generic_fns_cap = new_cap
            0
        } E { 0 }

        store_i64(self.generic_fns_ptr + self.generic_fns_len * 8, fn_ptr)
        self.generic_fns_len = self.generic_fns_len + 1
        1
    }

    # Find a saved generic function by name_idx
    F find_generic_fn(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.generic_fns_len { B }
            fn_ptr := load_i64(self.generic_fns_ptr + i * 8)
            fn_name := load_i64(fn_ptr)
            I fn_name == name_idx {
                R fn_ptr
            } E { 0 }
            i = i + 1
        }
        0
    }

    # Add a monomorphization entry
    # Each entry: fn_name_idx(8) + type_args_ptr(8) + type_args_len(8) = 24 bytes
    F add_mono_entry(&self, fn_name_idx: i64, type_args_ptr: i64, type_args_len: i64) -> i64 {
        # Check for duplicate
        i: mut i64 = 0
        L { I i >= self.mono_entries_len { B }
            entry_ptr := self.mono_entries_ptr + i * 24
            entry_fn := load_i64(entry_ptr)
            entry_len := load_i64(entry_ptr + 16)

            I entry_fn == fn_name_idx && entry_len == type_args_len {
                entry_args := load_i64(entry_ptr + 8)
                same: mut i64 = 1
                j: mut i64 = 0
                L { I j >= type_args_len { B }
                    I load_i64(entry_args + j * 8) != load_i64(type_args_ptr + j * 8) {
                        same = 0
                        B
                    } E { 0 }
                    j = j + 1
                }
                I same == 1 { R 1 }  # Already exists
                E { 0 }
            } E { 0 }
            i = i + 1
        }

        # Grow if needed
        I self.mono_entries_len >= self.mono_entries_cap {
            new_cap := self.mono_entries_cap * 2
            new_ptr := malloc(new_cap * 24)
            memcpy(new_ptr, self.mono_entries_ptr, self.mono_entries_len * 24)
            free(self.mono_entries_ptr)
            self.mono_entries_ptr = new_ptr
            self.mono_entries_cap = new_cap
            0
        } E { 0 }

        entry_ptr := self.mono_entries_ptr + self.mono_entries_len * 24
        store_i64(entry_ptr, fn_name_idx)
        store_i64(entry_ptr + 8, type_args_ptr)
        store_i64(entry_ptr + 16, type_args_len)
        self.mono_entries_len = self.mono_entries_len + 1
        1
    }

    # Import monomorphization entries from type checker
    # tc_mono_ptr: pointer to type checker's mono_entries array
    # tc_mono_len: number of entries
    F import_mono_entries(&self, tc_mono_ptr: i64, tc_mono_len: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= tc_mono_len { B }
            entry_ptr := tc_mono_ptr + i * 24
            fn_name := load_i64(entry_ptr)
            type_args := load_i64(entry_ptr + 8)
            type_args_len := load_i64(entry_ptr + 16)

            # Build concrete type kind array from ResolvedType pointers
            concrete_kinds := malloc(type_args_len * 8)
            j: mut i64 = 0
            L { I j >= type_args_len { B }
                type_ptr := load_i64(type_args + j * 8)
                type_kind := load_i64(type_ptr)  # ResolvedType.kind
                llvm_kind := @.resolved_type_to_llvm(type_kind)
                store_i64(concrete_kinds + j * 8, llvm_kind)
                j = j + 1
            }

            @.add_mono_entry(fn_name, concrete_kinds, type_args_len)
            i = i + 1
        }
        1
    }

    # Set generic binding for monomorphization
    F set_mono_binding(&self, name_idx: i64, llvm_type_kind: i64) -> i64 {
        I self.mono_bind_len >= self.mono_bind_cap {
            new_cap := self.mono_bind_cap * 2
            new_keys := malloc(new_cap * 8)
            new_vals := malloc(new_cap * 8)
            memcpy(new_keys, self.mono_bind_keys_ptr, self.mono_bind_len * 8)
            memcpy(new_vals, self.mono_bind_values_ptr, self.mono_bind_len * 8)
            free(self.mono_bind_keys_ptr)
            free(self.mono_bind_values_ptr)
            self.mono_bind_keys_ptr = new_keys
            self.mono_bind_values_ptr = new_vals
            self.mono_bind_cap = new_cap
            0
        } E { 0 }

        store_i64(self.mono_bind_keys_ptr + self.mono_bind_len * 8, name_idx)
        store_i64(self.mono_bind_values_ptr + self.mono_bind_len * 8, llvm_type_kind)
        self.mono_bind_len = self.mono_bind_len + 1
        1
    }

    # Get generic binding (returns LLVM type kind, or -1 if not found)
    F get_mono_binding(&self, name_idx: i64) -> i64 {
        i: mut i64 = self.mono_bind_len
        L { I i == 0 { B }
            i = i - 1
            key := load_i64(self.mono_bind_keys_ptr + i * 8)
            I key == name_idx {
                R load_i64(self.mono_bind_values_ptr + i * 8)
            } E { 0 }
        }
        0 - 1  # Not found
    }

    # Clear all generic bindings
    F clear_mono_bindings(&self) -> i64 {
        self.mono_bind_len = 0
        1
    }

    # Build monomorphized function name: "fn_name_T1_T2"
    # Returns (name_ptr, name_len) via temp buffer
    F build_mono_name(&self, fn_name_idx: i64, type_kinds_ptr: i64, type_kinds_len: i64) -> i64 {
        # Clear temp buffer
        store_i64(self.temp_buf + 8, 0)  # len = 0

        # Get base function name
        base_ptr := @.get_string_ptr(fn_name_idx)
        base_len := @.get_string_len(fn_name_idx)

        # Build: base_name + "_mono_" + kind1 + "_" + kind2 + ...
        tb_data := load_i64(self.temp_buf)
        tb_cap := load_i64(self.temp_buf + 16)

        # Ensure capacity
        needed := base_len + 6 + type_kinds_len * 6  # Generous estimate
        I needed > tb_cap {
            new_cap := needed * 2
            new_data := malloc(new_cap)
            free(tb_data)
            store_i64(self.temp_buf, new_data)
            store_i64(self.temp_buf + 16, new_cap)
            tb_data = new_data
            0
        } E { 0 }

        # Copy base name
        memcpy(tb_data, base_ptr, base_len)
        pos: mut i64 = base_len

        # Add "_mono_"
        store_byte(tb_data + pos, 95)  # _
        pos = pos + 1
        store_byte(tb_data + pos, 109) # m
        pos = pos + 1
        store_byte(tb_data + pos, 111) # o
        pos = pos + 1
        store_byte(tb_data + pos, 110) # n
        pos = pos + 1
        store_byte(tb_data + pos, 111) # o
        pos = pos + 1
        store_byte(tb_data + pos, 95)  # _
        pos = pos + 1

        # Add each type kind as number separated by _
        i: mut i64 = 0
        L { I i >= type_kinds_len { B }
            I i > 0 {
                store_byte(tb_data + pos, 95)  # _
                pos = pos + 1
                0
            } E { 0 }

            kind := load_i64(type_kinds_ptr + i * 8)
            # Write kind as digits
            I kind >= 10 {
                store_byte(tb_data + pos, 48 + kind / 10)
                pos = pos + 1
                store_byte(tb_data + pos, 48 + kind % 10)
                pos = pos + 1
                0
            } E {
                store_byte(tb_data + pos, 48 + kind)
                pos = pos + 1
                0
            }

            i = i + 1
        }

        store_i64(self.temp_buf + 8, pos)  # Update length
        tb_data  # Return pointer (length is at self.temp_buf + 8)
    }

    # Generate all monomorphized function specializations
    F generate_mono_functions(&self) -> i64 {
        I self.mono_entries_len == 0 { R 1 }

        @.emit_cstr("\n; ========== Monomorphized Functions ==========\n")

        i: mut i64 = 0
        L { I i >= self.mono_entries_len { B }
            entry_ptr := self.mono_entries_ptr + i * 24
            fn_name_idx := load_i64(entry_ptr)
            type_kinds_ptr := load_i64(entry_ptr + 8)
            type_kinds_len := load_i64(entry_ptr + 16)

            # Find the generic function AST
            fn_ptr := @.find_generic_fn(fn_name_idx)
            I fn_ptr != 0 {
                @.generate_mono_function(fn_ptr, type_kinds_ptr, type_kinds_len)
                0
            } E { 0 }

            i = i + 1
        }
        1
    }

    # Generate a single monomorphized function
    F generate_mono_function(&self, fn_ptr: i64, type_kinds_ptr: i64, type_kinds_len: i64) -> i64 {
        name_idx := load_i64(fn_ptr)
        generics_ptr := load_i64(fn_ptr + 8)
        generics_len := load_i64(fn_ptr + 16)
        params_ptr := load_i64(fn_ptr + 24)
        params_len := load_i64(fn_ptr + 32)
        ret_type_ptr := load_i64(fn_ptr + 40)
        body_kind := load_i64(fn_ptr + 48)
        body_expr_ptr := load_i64(fn_ptr + 56)
        body_stmts_ptr := load_i64(fn_ptr + 64)
        body_stmts_len := load_i64(fn_ptr + 72)

        # Set up generic bindings
        @.clear_mono_bindings()
        bind_count := I generics_len < type_kinds_len { generics_len } E { type_kinds_len }
        j: mut i64 = 0
        L { I j >= bind_count { B }
            # GenericParam.name_idx is at offset 0, GenericParam.size() = 40
            gen_name := load_i64(generics_ptr + j * 40)
            concrete_kind := load_i64(type_kinds_ptr + j * 8)
            @.set_mono_binding(gen_name, concrete_kind)
            j = j + 1
        }

        # Reset state for this function
        @.clear_locals()
        self.reg_counter = 0
        self.label_counter = 0
        self.current_fn_name_idx = name_idx

        # Determine return type (resolve generics)
        ret_llvm := I ret_type_ptr == 0 {
            self.current_fn_ret_type = LLVM_VOID()
            LLVM_VOID()
        } E {
            ret_kind := load_i64(ret_type_ptr)
            llvm_kind := @.resolve_mono_type(ret_type_ptr)
            self.current_fn_ret_type = llvm_kind
            llvm_kind
        }

        # Build monomorphized name
        mono_name_ptr := @.build_mono_name(name_idx, type_kinds_ptr, type_kinds_len)
        mono_name_len := load_i64(self.temp_buf + 8)

        # Emit function signature
        @.emit_cstr("define ")
        @.type_to_llvm_str(ret_llvm)
        @.emit_cstr(" @")
        @.emit_ptr(mono_name_ptr, mono_name_len)
        @.emit_cstr("(")

        # Register the mono function in function table
        @.add_function(name_idx, ret_llvm, 0)

        # Emit parameters (resolve generic types)
        k: mut i64 = 0
        L { I k >= params_len { B }
            I k > 0 { @.emit_cstr(", ") } E { 0 }

            param_ptr := params_ptr + k * 40  # Param.size() = 40
            param_name_idx := load_i64(param_ptr)
            param_type_ptr := load_i64(param_ptr + 8)

            param_llvm := I param_type_ptr == 0 {
                LLVM_I64()
            } E {
                @.resolve_mono_type(param_type_ptr)
            }

            @.type_to_llvm_str(param_llvm)
            @.emit_cstr(" %")
            @.emit_string_idx(param_name_idx)

            # Register parameter as local
            param_name_ptr := @.get_string_ptr(param_name_idx)
            param_name_len := @.get_string_len(param_name_idx)
            @.add_local(param_name_idx, param_name_ptr, param_name_len, param_llvm, 1)

            k = k + 1
        }

        @.emit_cstr(") {\n")
        @.emit_cstr("entry:\n")

        # Generate body (same as regular function)
        I body_kind == 0 {
            result_reg := @.generate_expr(body_expr_ptr)
            I ret_llvm == LLVM_VOID() {
                @.emit_cstr("  ret void\n")
            } E {
                @.emit_cstr("  ret ")
                @.type_to_llvm_str(ret_llvm)
                @.emit_cstr(" ")
                @.emit_reg(result_reg)
                @.emit_cstr("\n")
            }
        } E {
            @.generate_stmts(body_stmts_ptr, body_stmts_len)
            I ret_llvm == LLVM_VOID() {
                @.emit_cstr("  ret void\n")
            } E {
                @.emit_cstr("  ret ")
                @.type_to_llvm_str(ret_llvm)
                @.emit_cstr(" 0 ; implicit return\n")
            }
        }

        @.emit_cstr("}\n\n")

        # Clean up bindings
        @.clear_mono_bindings()
        1
    }

    # Resolve a type pointer considering current mono bindings
    # If the type is a generic parameter, look up the concrete type
    F resolve_mono_type(&self, type_ptr: i64) -> i64 {
        I type_ptr == 0 { R LLVM_I64() }

        type_kind := load_i64(type_ptr)

        # TY_GENERIC = 26 (from type_checker.vais)
        I type_kind == 26 {
            gen_name := load_i64(type_ptr + 8)  # ResolvedType.field0 = name_idx
            bound := @.get_mono_binding(gen_name)
            I bound != 0 - 1 {
                bound  # Return the concrete LLVM type kind
            } E {
                LLVM_I64()  # Fallback
            }
        }
        # TY_NAMED = 25 - check if it has generic args
        E I type_kind == 25 {
            LLVM_I64()  # Named types default to pointer-sized
        }
        E {
            @.resolved_type_to_llvm(type_kind)
        }
    }

    # ========== String Constants ==========

    F add_string_constant(&self, value_ptr: i64, value_len: i64) -> i64 {
        # Returns the string constant name index
        idx := self.strings_len

        I self.strings_len >= self.strings_cap {
            new_cap := self.strings_cap * 2
            new_ptr := malloc(new_cap * 32)
            memcpy(new_ptr, self.strings_ptr, self.strings_len * 32)
            free(self.strings_ptr)
            self.strings_ptr = new_ptr
            self.strings_cap = new_cap
            0
        } E { 0 }

        # Store: name will be ".str.N", value is the string content
        ptr := self.strings_ptr + self.strings_len * 32
        store_i64(ptr, idx)       # index as name
        store_i64(ptr + 8, value_ptr)
        store_i64(ptr + 16, value_len)

        self.strings_len = self.strings_len + 1
        idx
    }

    # ========== Code Generation Entry Point ==========

    F generate_module(&self, module_ptr: i64) -> i64 {
        # Get module data
        items_ptr := load_i64(module_ptr)
        items_len := load_i64(module_ptr + 8)

        # Set string pool
        sp_data := load_i64(module_ptr + 24)
        sp_offsets := load_i64(module_ptr + 32)
        sp_count := load_i64(module_ptr + 56)
        @.set_string_pool(sp_data, sp_offsets, sp_count)

        # Emit module header
        @.emit_cstr("; ModuleID = 'vais_module'\n")
        @.emit_cstr("source_filename = \"<vais>\"\n\n")

        # First pass: register all declarations
        i: mut i64 = 0
        L { I i >= items_len { B }
            item_ptr := items_ptr + i * 32
            kind := load_i64(item_ptr)
            data_ptr := load_i64(item_ptr + 8)

            # ITEM_FUNCTION = 1
            I kind == 1 {
                @.register_function_decl(data_ptr)
            }
            # ITEM_STRUCT = 2
            E I kind == 2 {
                @.register_struct_decl(data_ptr)
            }
            E { 0 }

            i = i + 1
        }

        # Emit struct type definitions
        j: mut i64 = 0
        L { I j >= self.structs_len { B }
            struct_ptr := self.structs_ptr + j * StructTypeInfo.size()
            @.emit_struct_type(struct_ptr)
            j = j + 1
        }

        # Emit extern function declarations
        @.emit_extern_declarations()

        # Second pass: generate function bodies
        i = 0
        L { I i >= items_len { B }
            item_ptr := items_ptr + i * 32
            kind := load_i64(item_ptr)
            data_ptr := load_i64(item_ptr + 8)

            # ITEM_FUNCTION = 1
            I kind == 1 {
                @.generate_function(data_ptr)
            }
            # ITEM_IMPL = 7
            E I kind == 7 {
                @.generate_impl(data_ptr)
            }
            E { 0 }

            i = i + 1
        }

        # Emit monomorphized function specializations
        @.generate_mono_functions()

        # Emit lambda functions
        @.emit_lambda_functions()

        # Emit string constants
        @.emit_string_constants()

        # Emit helper functions
        @.emit_helper_functions()

        1
    }

    F register_function_decl(&self, fn_ptr: i64) -> i64 {
        name_idx := load_i64(fn_ptr)
        ret_type_ptr := load_i64(fn_ptr + 40)

        ret_llvm := I ret_type_ptr == 0 {
            LLVM_VOID()
        } E {
            ret_kind := load_i64(ret_type_ptr)
            @.resolved_type_to_llvm(ret_kind)
        }

        @.add_function(name_idx, ret_llvm, 0)
    }

    F register_struct_decl(&self, struct_ptr: i64) -> i64 {
        name_idx := load_i64(struct_ptr)
        @.add_struct(name_idx)
    }

    F emit_struct_type(&self, struct_info_ptr: i64) -> i64 {
        name_idx := load_i64(struct_info_ptr)
        fields_ptr := load_i64(struct_info_ptr + 8)
        fields_len := load_i64(struct_info_ptr + 16)

        @.emit_cstr("%")
        @.emit_string_idx(name_idx)
        @.emit_cstr(" = type { ")

        i: mut i64 = 0
        L { I i >= fields_len { B }
            I i > 0 { @.emit_cstr(", ") } E { 0 }

            field_ptr := fields_ptr + i * StructFieldInfo.size()
            field_type := load_i64(field_ptr + 8)
            @.type_to_llvm_str(field_type)

            i = i + 1
        }

        @.emit_cstr(" }\n")
        1
    }

    F emit_extern_declarations(&self) -> i64 {
        # Emit built-in extern functions
        @.emit_cstr("\n; External declarations\n")
        @.emit_cstr("declare i8* @malloc(i64)\n")
        @.emit_cstr("declare void @free(i8*)\n")
        @.emit_cstr("declare i8* @memcpy(i8*, i8*, i64)\n")
        @.emit_cstr("declare i64 @strlen(i8*)\n")
        @.emit_cstr("declare i32 @puts(i8*)\n")
        @.emit_cstr("declare i64 @printf(i8*, ...)\n")
        @.emit_cstr("\n")
        1
    }

    F emit_string_constants(&self) -> i64 {
        I self.strings_len == 0 { R 1 }

        @.emit_cstr("\n; String constants\n")

        i: mut i64 = 0
        L { I i >= self.strings_len { B }
            ptr := self.strings_ptr + i * 32
            idx := load_i64(ptr)
            value_ptr := load_i64(ptr + 8)
            value_len := load_i64(ptr + 16)

            @.emit_cstr("@.str.")
            @.emit_i64(idx)
            @.emit_cstr(" = private unnamed_addr constant [")
            @.emit_i64(value_len + 1)
            @.emit_cstr(" x i8] c\"")

            # Emit string content with escaping
            j: mut i64 = 0
            L { I j >= value_len { B }
                c := load_byte(value_ptr + j)
                I c == 10 {
                    @.emit_cstr("\\0A")
                } E I c == 13 {
                    @.emit_cstr("\\0D")
                } E I c == 34 {
                    @.emit_cstr("\\22")
                } E I c == 92 {
                    @.emit_cstr("\\5C")
                } E I c == 0 {
                    @.emit_cstr("\\00")
                } E {
                    tb_data := load_i64(self.temp_buf)
                    store_byte(tb_data, c)
                    @.emit(tb_data, 1)
                }
                j = j + 1
            }

            @.emit_cstr("\\00\"\n")
            i = i + 1
        }
        1
    }

    F emit_helper_functions(&self) -> i64 {
        @.emit_cstr("\n; Helper functions for memory operations\n")

        # load_byte
        @.emit_cstr("define i64 @load_byte(i64 %ptr) {\n")
        @.emit_cstr("entry:\n")
        @.emit_cstr("  %0 = inttoptr i64 %ptr to i8*\n")
        @.emit_cstr("  %1 = load i8, i8* %0\n")
        @.emit_cstr("  %2 = zext i8 %1 to i64\n")
        @.emit_cstr("  ret i64 %2\n")
        @.emit_cstr("}\n\n")

        # store_byte
        @.emit_cstr("define void @store_byte(i64 %ptr, i64 %val) {\n")
        @.emit_cstr("entry:\n")
        @.emit_cstr("  %0 = inttoptr i64 %ptr to i8*\n")
        @.emit_cstr("  %1 = trunc i64 %val to i8\n")
        @.emit_cstr("  store i8 %1, i8* %0\n")
        @.emit_cstr("  ret void\n")
        @.emit_cstr("}\n\n")

        # load_i64
        @.emit_cstr("define i64 @load_i64(i64 %ptr) {\n")
        @.emit_cstr("entry:\n")
        @.emit_cstr("  %0 = inttoptr i64 %ptr to i64*\n")
        @.emit_cstr("  %1 = load i64, i64* %0\n")
        @.emit_cstr("  ret i64 %1\n")
        @.emit_cstr("}\n\n")

        # store_i64
        @.emit_cstr("define void @store_i64(i64 %ptr, i64 %val) {\n")
        @.emit_cstr("entry:\n")
        @.emit_cstr("  %0 = inttoptr i64 %ptr to i64*\n")
        @.emit_cstr("  store i64 %val, i64* %0\n")
        @.emit_cstr("  ret void\n")
        @.emit_cstr("}\n")

        1
    }

    # ========== Function Generation ==========

    F generate_function(&self, fn_ptr: i64) -> i64 {
        name_idx := load_i64(fn_ptr)
        generics_ptr := load_i64(fn_ptr + 8)
        generics_len := load_i64(fn_ptr + 16)
        params_ptr := load_i64(fn_ptr + 24)
        params_len := load_i64(fn_ptr + 32)
        ret_type_ptr := load_i64(fn_ptr + 40)
        body_kind := load_i64(fn_ptr + 48)
        body_expr_ptr := load_i64(fn_ptr + 56)
        body_stmts_ptr := load_i64(fn_ptr + 64)
        body_stmts_len := load_i64(fn_ptr + 72)

        # Save generic functions for monomorphization, don't generate them directly
        I generics_len > 0 {
            @.save_generic_fn(fn_ptr)
            R 1
        }

        # Reset state
        @.clear_locals()
        self.reg_counter = 0
        self.label_counter = 0
        self.current_fn_name_idx = name_idx

        # Determine return type
        ret_llvm := I ret_type_ptr == 0 {
            self.current_fn_ret_type = LLVM_VOID()
            LLVM_VOID()
        } E {
            ret_kind := load_i64(ret_type_ptr)
            llvm_kind := @.resolved_type_to_llvm(ret_kind)
            self.current_fn_ret_type = llvm_kind
            llvm_kind
        }

        # Emit function signature
        @.emit_cstr("define ")
        @.type_to_llvm_str(ret_llvm)
        @.emit_cstr(" @")
        @.emit_string_idx(name_idx)
        @.emit_cstr("(")

        # Emit parameters
        i: mut i64 = 0
        L { I i >= params_len { B }
            I i > 0 { @.emit_cstr(", ") } E { 0 }

            param_ptr := params_ptr + i * 40  # Param.size() = 40
            param_name_idx := load_i64(param_ptr)
            param_type_ptr := load_i64(param_ptr + 8)

            param_llvm := I param_type_ptr == 0 {
                LLVM_I64()
            } E {
                type_kind := load_i64(param_type_ptr)
                @.resolved_type_to_llvm(type_kind)
            }

            @.type_to_llvm_str(param_llvm)
            @.emit_cstr(" %")
            @.emit_string_idx(param_name_idx)

            # Register parameter as local
            param_name_ptr := @.get_string_ptr(param_name_idx)
            param_name_len := @.get_string_len(param_name_idx)
            @.add_local(param_name_idx, param_name_ptr, param_name_len, param_llvm, 1)

            i = i + 1
        }

        @.emit_cstr(") {\n")
        @.emit_cstr("entry:\n")

        # Generate body
        I body_kind == 0 {
            # Expression body
            result_reg := @.generate_expr(body_expr_ptr)

            I ret_llvm == LLVM_VOID() {
                @.emit_cstr("  ret void\n")
            } E {
                @.emit_cstr("  ret ")
                @.type_to_llvm_str(ret_llvm)
                @.emit_cstr(" ")
                @.emit_reg(result_reg)
                @.emit_cstr("\n")
            }
        } E {
            # Block body
            @.generate_stmts(body_stmts_ptr, body_stmts_len)

            # Add implicit return if needed
            I ret_llvm == LLVM_VOID() {
                @.emit_cstr("  ret void\n")
            } E { 0 }
        }

        @.emit_cstr("}\n\n")
        1
    }

    F generate_impl(&self, impl_ptr: i64) -> i64 {
        methods_ptr := load_i64(impl_ptr + 32)
        methods_len := load_i64(impl_ptr + 40)

        i: mut i64 = 0
        L { I i >= methods_len { B }
            method_ptr := load_i64(methods_ptr + i * 8)
            @.generate_function(method_ptr)
            i = i + 1
        }
        1
    }

    # ========== Statement Generation ==========

    F generate_stmts(&self, stmts_ptr: i64, stmts_len: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= stmts_len { B }
            stmt_ptr := load_i64(stmts_ptr + i * 8)
            @.generate_stmt(stmt_ptr)
            i = i + 1
        }
        1
    }

    F generate_stmt(&self, stmt_ptr: i64) -> i64 {
        kind := load_i64(stmt_ptr)

        # STMT_LET = 10
        I kind == 10 {
            @.generate_let_stmt(stmt_ptr)
        }
        # STMT_EXPR = 11
        E I kind == 11 {
            expr_ptr := load_i64(stmt_ptr + 24)
            @.generate_expr(expr_ptr)
            1
        }
        # STMT_RETURN = 12
        E I kind == 12 {
            @.generate_return_stmt(stmt_ptr)
        }
        # STMT_BREAK = 13
        E I kind == 13 {
            @.generate_break_stmt()
        }
        # STMT_CONTINUE = 14
        E I kind == 14 {
            @.generate_continue_stmt()
        }
        E { 1 }
    }

    F generate_let_stmt(&self, stmt_ptr: i64) -> i64 {
        name_idx := load_i64(stmt_ptr + 24)
        type_ptr := load_i64(stmt_ptr + 32)
        value_ptr := load_i64(stmt_ptr + 40)
        is_mut := load_i64(stmt_ptr + 48)

        # Determine type
        var_type := I type_ptr != 0 {
            type_kind := load_i64(type_ptr)
            @.resolved_type_to_llvm(type_kind)
        } E {
            LLVM_I64()  # Default
        }

        # Allocate stack space
        alloca_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(alloca_reg)
        @.emit_cstr(" = alloca ")
        @.type_to_llvm_str(var_type)
        @.emit_cstr("\n")

        # Store initial value if present
        I value_ptr != 0 {
            value_reg := @.generate_expr(value_ptr)
            @.emit_cstr("  store ")
            @.type_to_llvm_str(var_type)
            @.emit_cstr(" ")
            @.emit_reg(value_reg)
            @.emit_cstr(", ")
            @.type_to_llvm_str(var_type)
            @.emit_cstr("* ")
            @.emit_reg(alloca_reg)
            @.emit_cstr("\n")
            0
        } E { 0 }

        # Register local variable (store alloca register as name)
        name_ptr := @.get_string_ptr(name_idx)
        name_len := @.get_string_len(name_idx)

        # Store alloca reg number in local
        local_idx := @.add_local(name_idx, alloca_reg, 0, var_type, 0)
        # Mark as alloca
        local_ptr := self.locals_ptr + local_idx * LocalVar.size()
        store_i64(local_ptr + 40, 1)  # is_alloca = 1

        1
    }

    F generate_return_stmt(&self, stmt_ptr: i64) -> i64 {
        expr_ptr := load_i64(stmt_ptr + 24)

        I expr_ptr == 0 || self.current_fn_ret_type == LLVM_VOID() {
            @.emit_cstr("  ret void\n")
        } E {
            value_reg := @.generate_expr(expr_ptr)
            @.emit_cstr("  ret ")
            @.type_to_llvm_str(self.current_fn_ret_type)
            @.emit_cstr(" ")
            @.emit_reg(value_reg)
            @.emit_cstr("\n")
        }
        1
    }

    F generate_break_stmt(&self) -> i64 {
        loop_ctx := @.current_loop()
        I loop_ctx != 0 {
            break_label := load_i64(loop_ctx)
            @.emit_cstr("  br label %end")
            @.emit_i64(break_label)
            @.emit_cstr("\n")
            1
        } E { 0 }
    }

    F generate_continue_stmt(&self) -> i64 {
        loop_ctx := @.current_loop()
        I loop_ctx != 0 {
            continue_label := load_i64(loop_ctx + 16)
            @.emit_cstr("  br label %cond")
            @.emit_i64(continue_label)
            @.emit_cstr("\n")
            1
        } E { 0 }
    }

    # ========== Expression Generation ==========

    F generate_expr(&self, expr_ptr: i64) -> i64 {
        I expr_ptr == 0 { R 0 }

        kind := load_i64(expr_ptr)

        # EXPR_INT = 20
        I kind == 20 {
            value := load_i64(expr_ptr + 24)
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, ")
            @.emit_i64(value)
            @.emit_cstr("\n")
            result
        }
        # EXPR_FLOAT = 21
        E I kind == 21 {
            # For now, emit as i64 (float bits)
            value := load_i64(expr_ptr + 24)
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, ")
            @.emit_i64(value)
            @.emit_cstr("\n")
            result
        }
        # EXPR_BOOL = 22
        E I kind == 22 {
            value := load_i64(expr_ptr + 24)
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, ")
            I value != 0 { @.emit_cstr("1") } E { @.emit_cstr("0") }
            @.emit_cstr("\n")
            result
        }
        # EXPR_STRING = 23
        E I kind == 23 {
            str_idx := load_i64(expr_ptr + 24)
            str_ptr := @.get_string_ptr(str_idx)
            str_len := @.get_string_len(str_idx)

            # Add string constant
            const_idx := @.add_string_constant(str_ptr, str_len)

            # Get pointer to string constant
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = getelementptr [")
            @.emit_i64(str_len + 1)
            @.emit_cstr(" x i8], [")
            @.emit_i64(str_len + 1)
            @.emit_cstr(" x i8]* @.str.")
            @.emit_i64(const_idx)
            @.emit_cstr(", i64 0, i64 0\n")

            # Convert to i64
            result2 := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result2)
            @.emit_cstr(" = ptrtoint i8* ")
            @.emit_reg(result)
            @.emit_cstr(" to i64\n")

            result2
        }
        # EXPR_UNIT = 24
        E I kind == 24 {
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0 ; unit\n")
            result
        }
        # EXPR_IDENT = 25
        E I kind == 25 {
            name_idx := load_i64(expr_ptr + 24)
            @.generate_ident(name_idx)
        }
        # EXPR_SELF_CALL = 26
        E I kind == 26 {
            @.generate_self_call(expr_ptr)
        }
        # EXPR_BINARY = 27
        E I kind == 27 {
            @.generate_binary(expr_ptr)
        }
        # EXPR_UNARY = 28
        E I kind == 28 {
            @.generate_unary(expr_ptr)
        }
        # EXPR_IF = 30
        E I kind == 30 {
            @.generate_if(expr_ptr)
        }
        # EXPR_LOOP = 31
        E I kind == 31 {
            @.generate_loop(expr_ptr)
        }
        # EXPR_CALL = 33
        E I kind == 33 {
            @.generate_call(expr_ptr)
        }
        # EXPR_INDEX = 37
        E I kind == 37 {
            @.generate_index(expr_ptr)
        }
        # EXPR_ARRAY = 38
        E I kind == 38 {
            @.generate_array(expr_ptr)
        }
        # EXPR_BLOCK = 42
        E I kind == 42 {
            @.generate_block_expr(expr_ptr)
        }
        # EXPR_TERNARY = 29
        E I kind == 29 {
            @.generate_ternary(expr_ptr)
        }
        # EXPR_MATCH = 32
        E I kind == 32 {
            @.generate_match(expr_ptr)
        }
        # EXPR_METHOD_CALL = 34
        E I kind == 34 {
            @.generate_method_call(expr_ptr)
        }
        # EXPR_STATIC_CALL = 35
        E I kind == 35 {
            @.generate_static_call(expr_ptr)
        }
        # EXPR_FIELD = 36
        E I kind == 36 {
            @.generate_field_access(expr_ptr)
        }
        # EXPR_TUPLE = 39
        E I kind == 39 {
            @.generate_tuple(expr_ptr)
        }
        # EXPR_STRUCT_LIT = 40
        E I kind == 40 {
            @.generate_struct_lit(expr_ptr)
        }
        # EXPR_RANGE = 41
        E I kind == 41 {
            @.generate_range(expr_ptr)
        }
        # EXPR_TRY = 44
        E I kind == 44 {
            @.generate_try(expr_ptr)
        }
        # EXPR_UNWRAP = 45
        E I kind == 45 {
            @.generate_unwrap(expr_ptr)
        }
        # EXPR_REF = 46
        E I kind == 46 {
            @.generate_ref(expr_ptr)
        }
        # EXPR_DEREF = 47
        E I kind == 47 {
            @.generate_deref(expr_ptr)
        }
        # EXPR_ASSIGN = 48
        E I kind == 48 {
            @.generate_assign(expr_ptr)
        }
        # EXPR_ASSIGN_OP = 49
        E I kind == 49 {
            @.generate_assign_op(expr_ptr)
        }
        # EXPR_LAMBDA = 50
        E I kind == 50 {
            @.generate_lambda(expr_ptr)
        }
        E {
            # Unknown expression, return 0
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0 ; unknown expr kind ")
            @.emit_i64(kind)
            @.emit_cstr("\n")
            result
        }
    }

    F generate_ident(&self, name_idx: i64) -> i64 {
        local_ptr := @.find_local(name_idx)
        I local_ptr != 0 {
            is_alloca := load_i64(local_ptr + 40)
            type_kind := load_i64(local_ptr + 24)

            I is_alloca == 1 {
                # Load from alloca
                alloca_reg := load_i64(local_ptr + 8)
                result := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(result)
                @.emit_cstr(" = load ")
                @.type_to_llvm_str(type_kind)
                @.emit_cstr(", ")
                @.type_to_llvm_str(type_kind)
                @.emit_cstr("* ")
                @.emit_reg(alloca_reg)
                @.emit_cstr("\n")
                result
            } E {
                # Direct use of parameter
                result := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(result)
                @.emit_cstr(" = add ")
                @.type_to_llvm_str(type_kind)
                @.emit_cstr(" 0, %")
                @.emit_string_idx(name_idx)
                @.emit_cstr("\n")
                result
            }
        } E {
            # Unknown variable
            result := @.fresh_reg()
            @.emit_cstr("  ; unknown var: ")
            @.emit_string_idx(name_idx)
            @.emit_cstr("\n")
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0\n")
            result
        }
    }

    F generate_binary(&self, expr_ptr: i64) -> i64 {
        left_ptr := load_i64(expr_ptr + 24)
        right_ptr := load_i64(expr_ptr + 32)
        op := load_i64(expr_ptr + 40)

        left_reg := @.generate_expr(left_ptr)
        right_reg := @.generate_expr(right_ptr)
        result := @.fresh_reg()

        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ")

        I op == OP_ADD() { @.emit_cstr("add i64 ") }
        E I op == OP_SUB() { @.emit_cstr("sub i64 ") }
        E I op == OP_MUL() { @.emit_cstr("mul i64 ") }
        E I op == OP_DIV() { @.emit_cstr("sdiv i64 ") }
        E I op == OP_MOD() { @.emit_cstr("srem i64 ") }
        E I op == OP_LT() { @.emit_cstr("icmp slt i64 ") }
        E I op == OP_LTE() { @.emit_cstr("icmp sle i64 ") }
        E I op == OP_GT() { @.emit_cstr("icmp sgt i64 ") }
        E I op == OP_GTE() { @.emit_cstr("icmp sge i64 ") }
        E I op == OP_EQ() { @.emit_cstr("icmp eq i64 ") }
        E I op == OP_NEQ() { @.emit_cstr("icmp ne i64 ") }
        E I op == OP_AND() { @.emit_cstr("and i64 ") }
        E I op == OP_OR() { @.emit_cstr("or i64 ") }
        E I op == OP_BIT_AND() { @.emit_cstr("and i64 ") }
        E I op == OP_BIT_OR() { @.emit_cstr("or i64 ") }
        E I op == OP_BIT_XOR() { @.emit_cstr("xor i64 ") }
        E I op == OP_SHL() { @.emit_cstr("shl i64 ") }
        E I op == OP_SHR() { @.emit_cstr("ashr i64 ") }
        E { @.emit_cstr("add i64 ") }

        @.emit_reg(left_reg)
        @.emit_cstr(", ")
        @.emit_reg(right_reg)
        @.emit_cstr("\n")

        # For comparison ops, extend result to i64
        I op >= OP_LT() && op <= OP_NEQ() {
            ext_result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(ext_result)
            @.emit_cstr(" = zext i1 ")
            @.emit_reg(result)
            @.emit_cstr(" to i64\n")
            ext_result
        } E {
            result
        }
    }

    F generate_unary(&self, expr_ptr: i64) -> i64 {
        inner_ptr := load_i64(expr_ptr + 24)
        op := load_i64(expr_ptr + 32)

        inner_reg := @.generate_expr(inner_ptr)
        result := @.fresh_reg()

        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ")

        I op == UOP_NEG() {
            @.emit_cstr("sub i64 0, ")
            @.emit_reg(inner_reg)
        }
        E I op == UOP_NOT() {
            @.emit_cstr("xor i64 ")
            @.emit_reg(inner_reg)
            @.emit_cstr(", 1")
        }
        E I op == UOP_BITNOT() {
            @.emit_cstr("xor i64 ")
            @.emit_reg(inner_reg)
            @.emit_cstr(", -1")
        }
        E {
            @.emit_cstr("add i64 0, ")
            @.emit_reg(inner_reg)
        }

        @.emit_cstr("\n")
        result
    }

    F generate_if(&self, expr_ptr: i64) -> i64 {
        cond_ptr := load_i64(expr_ptr + 24)
        then_stmts := load_i64(expr_ptr + 32)
        then_len := load_i64(expr_ptr + 40)
        else_ptr := load_i64(expr_ptr + 48)

        label_id := @.fresh_label()

        # Generate condition
        cond_reg := @.generate_expr(cond_ptr)

        # Truncate to i1 for branch
        cond_i1 := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(cond_i1)
        @.emit_cstr(" = trunc i64 ")
        @.emit_reg(cond_reg)
        @.emit_cstr(" to i1\n")

        # Branch
        @.emit_cstr("  br i1 ")
        @.emit_reg(cond_i1)
        @.emit_cstr(", label %then")
        @.emit_i64(label_id)
        @.emit_cstr(", label %else")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Then block
        @.emit_cstr("then")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.generate_stmts(then_stmts, then_len)
        @.emit_cstr("  br label %end")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Else block
        @.emit_cstr("else")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        I else_ptr != 0 {
            @.generate_else(else_ptr)
            0
        } E { 0 }
        @.emit_cstr("  br label %end")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # End block
        @.emit_cstr("end")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        # Return unit (0)
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = add i64 0, 0\n")
        result
    }

    F generate_else(&self, else_ptr: i64) -> i64 {
        kind := load_i64(else_ptr)
        I kind == 0 {
            # else block
            stmts_ptr := load_i64(else_ptr + 16)
            stmts_len := load_i64(else_ptr + 24)
            @.generate_stmts(stmts_ptr, stmts_len)
        } E {
            # else-if
            cond_ptr := load_i64(else_ptr + 8)
            stmts_ptr := load_i64(else_ptr + 16)
            stmts_len := load_i64(else_ptr + 24)
            next_ptr := load_i64(else_ptr + 32)

            label_id := @.fresh_label()

            cond_reg := @.generate_expr(cond_ptr)
            cond_i1 := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(cond_i1)
            @.emit_cstr(" = trunc i64 ")
            @.emit_reg(cond_reg)
            @.emit_cstr(" to i1\n")

            @.emit_cstr("  br i1 ")
            @.emit_reg(cond_i1)
            @.emit_cstr(", label %elseif_then")
            @.emit_i64(label_id)
            @.emit_cstr(", label %elseif_else")
            @.emit_i64(label_id)
            @.emit_cstr("\n")

            @.emit_cstr("elseif_then")
            @.emit_i64(label_id)
            @.emit_cstr(":\n")
            @.generate_stmts(stmts_ptr, stmts_len)
            @.emit_cstr("  br label %elseif_end")
            @.emit_i64(label_id)
            @.emit_cstr("\n")

            @.emit_cstr("elseif_else")
            @.emit_i64(label_id)
            @.emit_cstr(":\n")
            I next_ptr != 0 {
                @.generate_else(next_ptr)
                0
            } E { 0 }
            @.emit_cstr("  br label %elseif_end")
            @.emit_i64(label_id)
            @.emit_cstr("\n")

            @.emit_cstr("elseif_end")
            @.emit_i64(label_id)
            @.emit_cstr(":\n")
        }
        1
    }

    F generate_loop(&self, expr_ptr: i64) -> i64 {
        body_stmts := load_i64(expr_ptr + 40)
        body_len := load_i64(expr_ptr + 48)

        label_id := @.fresh_label()

        # Push loop context
        @.push_loop(label_id, 0, label_id, 0)

        # Jump to loop condition
        @.emit_cstr("  br label %cond")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Condition (infinite loop, always branch to body)
        @.emit_cstr("cond")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.emit_cstr("  br label %body")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Body
        @.emit_cstr("body")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.generate_stmts(body_stmts, body_len)
        @.emit_cstr("  br label %cond")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # End
        @.emit_cstr("end")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        # Pop loop context
        @.pop_loop()

        # Return unit
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = add i64 0, 0\n")
        result
    }

    F generate_call(&self, expr_ptr: i64) -> i64 {
        func_ptr := load_i64(expr_ptr + 24)
        args_ptr := load_i64(expr_ptr + 32)
        args_len := load_i64(expr_ptr + 40)

        # Get function name
        func_kind := load_i64(func_ptr)
        I func_kind != 25 {
            # Not an identifier, return 0
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0 ; non-ident call\n")
            R result
        }

        func_name_idx := load_i64(func_ptr + 24)

        # Look up function
        fn_info := @.find_function(func_name_idx)
        ret_type := I fn_info != 0 {
            load_i64(fn_info + 24)
        } E {
            LLVM_I64()  # Default
        }

        # Generate arguments
        arg_regs_ptr := malloc(args_len * 8)
        i: mut i64 = 0
        L { I i >= args_len { B }
            arg_expr := load_i64(args_ptr + i * 8)
            arg_reg := @.generate_expr(arg_expr)
            store_i64(arg_regs_ptr + i * 8, arg_reg)
            i = i + 1
        }

        # Emit call
        result := @.fresh_reg()

        I ret_type == LLVM_VOID() {
            @.emit_cstr("  call void @")
        } E {
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = call ")
            @.type_to_llvm_str(ret_type)
            @.emit_cstr(" @")
        }

        @.emit_string_idx(func_name_idx)
        @.emit_cstr("(")

        i = 0
        L { I i >= args_len { B }
            I i > 0 { @.emit_cstr(", ") } E { 0 }
            @.emit_cstr("i64 ")
            arg_reg := load_i64(arg_regs_ptr + i * 8)
            @.emit_reg(arg_reg)
            i = i + 1
        }

        @.emit_cstr(")\n")

        free(arg_regs_ptr)

        I ret_type == LLVM_VOID() {
            zero := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(zero)
            @.emit_cstr(" = add i64 0, 0\n")
            zero
        } E {
            result
        }
    }

    F generate_array(&self, expr_ptr: i64) -> i64 {
        # Get elements array and length
        elements_ptr := load_i64(expr_ptr + 24)
        elements_len := load_i64(expr_ptr + 32)

        # For empty array, just return a null pointer
        I elements_len == 0 {
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = inttoptr i64 0 to i64*\n")
            R result
        }

        # Allocate array on the stack (elements_len * 8 bytes for i64)
        alloca_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(alloca_reg)
        @.emit_cstr(" = alloca i64, i64 ")
        @.emit_i64(elements_len)
        @.emit_cstr("\n")

        # Generate each element and store
        i: mut i64 = 0
        L {
            I i >= elements_len { B }

            elem_expr := load_i64(elements_ptr + i * 8)
            elem_reg := @.generate_expr(elem_expr)

            # Calculate GEP for element i
            gep_reg := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(gep_reg)
            @.emit_cstr(" = getelementptr i64, i64* ")
            @.emit_reg(alloca_reg)
            @.emit_cstr(", i64 ")
            @.emit_i64(i)
            @.emit_cstr("\n")

            # Store element
            @.emit_cstr("  store i64 ")
            @.emit_reg(elem_reg)
            @.emit_cstr(", i64* ")
            @.emit_reg(gep_reg)
            @.emit_cstr("\n")

            i = i + 1
        }

        # Return pointer to first element
        alloca_reg
    }

    F generate_index(&self, expr_ptr: i64) -> i64 {
        # Get base and index expressions
        base_expr := load_i64(expr_ptr + 24)
        index_expr := load_i64(expr_ptr + 32)

        # Generate code for base (array/pointer)
        base_reg := @.generate_expr(base_expr)

        # Generate code for index
        index_reg := @.generate_expr(index_expr)

        # Calculate element pointer using GEP
        # Assuming i64 element type for simplicity
        elem_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(elem_ptr)
        @.emit_cstr(" = getelementptr i64, i64* ")
        @.emit_reg(base_reg)
        @.emit_cstr(", i64 ")
        @.emit_reg(index_reg)
        @.emit_cstr("\n")

        # Load the value at the calculated address
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = load i64, i64* ")
        @.emit_reg(elem_ptr)
        @.emit_cstr("\n")

        result
    }

    F generate_block_expr(&self, expr_ptr: i64) -> i64 {
        stmts_ptr := load_i64(expr_ptr + 24)
        stmts_len := load_i64(expr_ptr + 32)

        @.generate_stmts(stmts_ptr, stmts_len)

        # Return unit
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = add i64 0, 0\n")
        result
    }

    F generate_assign(&self, expr_ptr: i64) -> i64 {
        target_ptr := load_i64(expr_ptr + 24)
        value_ptr := load_i64(expr_ptr + 32)

        target_kind := load_i64(target_ptr)
        I target_kind != 25 {
            # Not an identifier target, just evaluate value
            R @.generate_expr(value_ptr)
        }

        target_name_idx := load_i64(target_ptr + 24)
        local_ptr := @.find_local(target_name_idx)

        I local_ptr == 0 {
            # Unknown variable
            R @.generate_expr(value_ptr)
        }

        is_alloca := load_i64(local_ptr + 40)
        type_kind := load_i64(local_ptr + 24)

        I is_alloca != 1 {
            # Can't assign to parameter (for now)
            R @.generate_expr(value_ptr)
        }

        value_reg := @.generate_expr(value_ptr)
        alloca_reg := load_i64(local_ptr + 8)

        @.emit_cstr("  store ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr(" ")
        @.emit_reg(value_reg)
        @.emit_cstr(", ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr("* ")
        @.emit_reg(alloca_reg)
        @.emit_cstr("\n")

        value_reg
    }

    # ========== Self Call (@ operator) ==========

    F generate_self_call(&self, expr_ptr: i64) -> i64 {
        # @ = recursive call to current function
        # Self call has no explicit data; it refers to the current function
        # Emit a call to the current function with no args (caller will wrap with method_call)
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @")
        @.emit_string_idx(self.current_fn_name_idx)
        @.emit_cstr("()\n")
        result
    }

    # ========== Tuple ==========

    F generate_tuple(&self, expr_ptr: i64) -> i64 {
        # TUPLE: field0 = elements_ptr, field1 = len
        elements_ptr := load_i64(expr_ptr + 24)
        elements_len := load_i64(expr_ptr + 32)

        # Allocate memory for tuple (elements_len * 8 bytes)
        size := elements_len * 8
        I size == 0 { size = 8 } E { 0 }

        size_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(size_reg)
        @.emit_cstr(" = add i64 0, ")
        @.emit_i64(size)
        @.emit_cstr("\n")

        raw_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" = call i8* @malloc(i64 ")
        @.emit_reg(size_reg)
        @.emit_cstr(")\n")

        tuple_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(tuple_ptr)
        @.emit_cstr(" = ptrtoint i8* ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" to i64\n")

        # Store each element
        i: mut i64 = 0
        L { I i >= elements_len { B }
            elem_expr := load_i64(elements_ptr + i * 8)
            elem_reg := @.generate_expr(elem_expr)

            offset_reg := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(offset_reg)
            @.emit_cstr(" = add i64 ")
            @.emit_reg(tuple_ptr)
            @.emit_cstr(", ")
            @.emit_i64(i * 8)
            @.emit_cstr("\n")

            @.emit_cstr("  call void @store_i64(i64 ")
            @.emit_reg(offset_reg)
            @.emit_cstr(", i64 ")
            @.emit_reg(elem_reg)
            @.emit_cstr(")\n")

            i = i + 1
        }

        tuple_ptr
    }

    # ========== Range ==========

    F generate_range(&self, expr_ptr: i64) -> i64 {
        # RANGE: field0 = start_ptr, field1 = end_ptr, field2 = inclusive
        start_ptr := load_i64(expr_ptr + 24)
        end_ptr := load_i64(expr_ptr + 32)
        inclusive := load_i64(expr_ptr + 40)

        # Allocate a 3-element struct: (start, end, inclusive)
        raw_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" = call i8* @malloc(i64 24)\n")

        range_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(range_ptr)
        @.emit_cstr(" = ptrtoint i8* ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" to i64\n")

        # Store start
        start_reg := I start_ptr != 0 { @.generate_expr(start_ptr) } E {
            zero := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(zero)
            @.emit_cstr(" = add i64 0, 0\n")
            zero
        }
        @.emit_cstr("  call void @store_i64(i64 ")
        @.emit_reg(range_ptr)
        @.emit_cstr(", i64 ")
        @.emit_reg(start_reg)
        @.emit_cstr(")\n")

        # Store end
        end_offset := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(end_offset)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(range_ptr)
        @.emit_cstr(", 8\n")

        end_reg := I end_ptr != 0 { @.generate_expr(end_ptr) } E {
            max := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(max)
            @.emit_cstr(" = add i64 0, 9223372036854775807\n")
            max
        }
        @.emit_cstr("  call void @store_i64(i64 ")
        @.emit_reg(end_offset)
        @.emit_cstr(", i64 ")
        @.emit_reg(end_reg)
        @.emit_cstr(")\n")

        # Store inclusive flag
        incl_offset := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(incl_offset)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(range_ptr)
        @.emit_cstr(", 16\n")
        @.emit_cstr("  call void @store_i64(i64 ")
        @.emit_reg(incl_offset)
        @.emit_cstr(", i64 ")
        @.emit_i64(inclusive)
        @.emit_cstr(")\n")

        range_ptr
    }

    # ========== Lambda Helpers ==========

    F lambda_emit_cstr(&self, s: str) -> i64 {
        len := strlen(s)
        lb_data: mut i64 = load_i64(self.lambda_buf)
        lb_len := load_i64(self.lambda_buf + 8)
        lb_cap := load_i64(self.lambda_buf + 16)

        I lb_len + len > lb_cap {
            new_cap := (lb_cap + len) * 2
            new_data := malloc(new_cap)
            memcpy(new_data, lb_data, lb_len)
            free(lb_data)
            store_i64(self.lambda_buf, new_data)
            store_i64(self.lambda_buf + 16, new_cap)
            lb_data = new_data
            0
        } E { 0 }

        memcpy_str(lb_data + lb_len, s, len)
        store_i64(self.lambda_buf + 8, lb_len + len)
        1
    }

    F lambda_emit_i64(&self, value: i64) -> i64 {
        # Write i64 to lambda buffer using temp buf
        store_i64(self.temp_buf + 8, 0)
        tb_data := load_i64(self.temp_buf)

        I value == 0 {
            store_byte(tb_data, 48)
            @.lambda_emit_ptr(tb_data, 1)
        } E I value < 0 {
            store_byte(tb_data, 45)
            @.lambda_emit_ptr(tb_data, 1)
            @.lambda_emit_i64(0 - value)
        } E {
            @.lambda_emit_positive_i64(value)
        }
    }

    F lambda_emit_positive_i64(&self, value: i64) -> i64 {
        I value == 0 { R 1 }
        @.lambda_emit_positive_i64(value / 10)
        digit := (value % 10) + 48
        tb_data := load_i64(self.temp_buf)
        store_byte(tb_data, digit)
        @.lambda_emit_ptr(tb_data, 1)
    }

    F lambda_emit_ptr(&self, ptr: i64, len: i64) -> i64 {
        lb_data: mut i64 = load_i64(self.lambda_buf)
        lb_len := load_i64(self.lambda_buf + 8)
        lb_cap := load_i64(self.lambda_buf + 16)

        I lb_len + len > lb_cap {
            new_cap := (lb_cap + len) * 2
            new_data := malloc(new_cap)
            memcpy(new_data, lb_data, lb_len)
            free(lb_data)
            store_i64(self.lambda_buf, new_data)
            store_i64(self.lambda_buf + 16, new_cap)
            lb_data = new_data
            0
        } E { 0 }

        memcpy(lb_data + lb_len, ptr, len)
        store_i64(self.lambda_buf + 8, lb_len + len)
        1
    }

    F lambda_emit_reg(&self, n: i64) -> i64 {
        @.lambda_emit_cstr("%")
        @.lambda_emit_i64(n)
    }

    F emit_lambda_functions(&self) -> i64 {
        lb_len := load_i64(self.lambda_buf + 8)
        I lb_len == 0 { R 1 }

        @.emit_cstr("\n; Lambda functions\n")
        lb_data := load_i64(self.lambda_buf)
        @.emit_ptr(lb_data, lb_len)
        1
    }

    # ========== Lambda Codegen ==========

    F generate_lambda(&self, expr_ptr: i64) -> i64 {
        # LAMBDA: field0 = params_ptr, field1 = params_len, field2 = body_ptr
        params_ptr := load_i64(expr_ptr + 24)
        params_len := load_i64(expr_ptr + 32)
        body_ptr := load_i64(expr_ptr + 40)

        # Generate unique lambda name
        lambda_id := self.lambda_counter
        self.lambda_counter = self.lambda_counter + 1

        # Save current function context
        saved_fn_name := self.current_fn_name_idx
        saved_fn_ret := self.current_fn_ret_type
        saved_locals_len := self.locals_len
        saved_reg := self.reg_counter
        saved_label := self.label_counter

        # Reset counters for lambda function
        self.reg_counter = 0
        self.label_counter = 0

        # Emit lambda function definition to lambda buffer
        @.lambda_emit_cstr("define i64 @__lambda_")
        @.lambda_emit_i64(lambda_id)
        @.lambda_emit_cstr("(")

        # Emit parameters
        i: mut i64 = 0
        L { I i >= params_len { B }
            I i > 0 { @.lambda_emit_cstr(", ") } E { 0 }

            param_ptr := params_ptr + i * 40  # Param.size() = 40
            param_name_idx := load_i64(param_ptr)

            @.lambda_emit_cstr("i64 %")

            # Emit param name
            pname_ptr := @.get_string_ptr(param_name_idx)
            pname_len := @.get_string_len(param_name_idx)
            @.lambda_emit_ptr(pname_ptr, pname_len)

            # Register parameter as local
            @.add_local(param_name_idx, pname_ptr, pname_len, LLVM_I64(), 1)

            i = i + 1
        }

        @.lambda_emit_cstr(") {\n")
        @.lambda_emit_cstr("entry:\n")

        # Save main output and switch to lambda buffer
        # We need to temporarily redirect emit to lambda buffer
        # Strategy: generate body to main output, then copy to lambda buffer
        # This is simpler but requires saving/restoring output state

        # Actually, for simplicity, generate body expr directly to lambda buffer
        # by swapping output pointer temporarily
        saved_output := self.output
        self.output = self.lambda_buf

        self.current_fn_ret_type = LLVM_I64()

        # Generate body
        body_reg := @.generate_expr(body_ptr)

        # Emit return
        @.emit_cstr("  ret i64 ")
        @.emit_reg(body_reg)
        @.emit_cstr("\n")
        @.emit_cstr("}\n\n")

        # Restore output
        self.output = saved_output

        # Restore function context
        self.current_fn_name_idx = saved_fn_name
        self.current_fn_ret_type = saved_fn_ret
        self.locals_len = saved_locals_len
        self.reg_counter = saved_reg
        self.label_counter = saved_label

        # Return function pointer as i64
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ptrtoint i64 (")

        # Emit parameter types for function pointer type
        j: mut i64 = 0
        L { I j >= params_len { B }
            I j > 0 { @.emit_cstr(", ") } E { 0 }
            @.emit_cstr("i64")
            j = j + 1
        }

        @.emit_cstr(")* @__lambda_")
        @.emit_i64(lambda_id)
        @.emit_cstr(" to i64\n")

        result
    }

    # ========== Ref (& operator) ==========

    F generate_ref(&self, expr_ptr: i64) -> i64 {
        # REF: field0 = inner expr
        inner_ptr := load_i64(expr_ptr + 24)

        # If inner is an identifier with alloca, return the alloca pointer
        inner_kind := load_i64(inner_ptr)
        I inner_kind == 25 {
            # EXPR_IDENT
            name_idx := load_i64(inner_ptr + 24)
            local_ptr := @.find_local(name_idx)
            I local_ptr != 0 {
                is_alloca := load_i64(local_ptr + 40)
                I is_alloca == 1 {
                    # Return the alloca register as the pointer value
                    alloca_reg := load_i64(local_ptr + 8)
                    result := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(result)
                    @.emit_cstr(" = ptrtoint i64* ")
                    @.emit_reg(alloca_reg)
                    @.emit_cstr(" to i64\n")
                    R result
                } E { 0 }
            } E { 0 }
            0
        } E { 0 }

        # Fallback: generate expr and store it on stack, return pointer
        inner_reg := @.generate_expr(inner_ptr)
        alloca := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(alloca)
        @.emit_cstr(" = alloca i64\n")
        @.emit_cstr("  store i64 ")
        @.emit_reg(inner_reg)
        @.emit_cstr(", i64* ")
        @.emit_reg(alloca)
        @.emit_cstr("\n")

        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ptrtoint i64* ")
        @.emit_reg(alloca)
        @.emit_cstr(" to i64\n")
        result
    }

    # ========== Deref (* operator) ==========

    F generate_deref(&self, expr_ptr: i64) -> i64 {
        # DEREF: field0 = inner expr (pointer value)
        inner_ptr := load_i64(expr_ptr + 24)
        ptr_reg := @.generate_expr(inner_ptr)

        # Load value from pointer
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(ptr_reg)
        @.emit_cstr(")\n")
        result
    }

    # ========== Try (? operator) ==========

    F generate_try(&self, expr_ptr: i64) -> i64 {
        # TRY: field0 = inner expr (Result value)
        # Result layout: first i64 is tag (0=Ok, 1=Err), second i64 is value
        inner_ptr := load_i64(expr_ptr + 24)
        result_reg := @.generate_expr(inner_ptr)

        label_id := @.fresh_label()

        # Load tag (first field of result)
        tag_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(tag_reg)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(result_reg)
        @.emit_cstr(")\n")

        # Check if Err (tag == 1)
        is_err := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(is_err)
        @.emit_cstr(" = icmp eq i64 ")
        @.emit_reg(tag_reg)
        @.emit_cstr(", 1\n")

        @.emit_cstr("  br i1 ")
        @.emit_reg(is_err)
        @.emit_cstr(", label %try_err")
        @.emit_i64(label_id)
        @.emit_cstr(", label %try_ok")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Error path: early return with Err value
        @.emit_cstr("try_err")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.emit_cstr("  ret i64 ")
        @.emit_reg(result_reg)
        @.emit_cstr("\n")

        # Ok path: extract value (second field)
        @.emit_cstr("try_ok")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        val_offset := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(val_offset)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(result_reg)
        @.emit_cstr(", 8\n")

        val_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(val_reg)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(val_offset)
        @.emit_cstr(")\n")

        val_reg
    }

    # ========== Unwrap (! operator) ==========

    F generate_unwrap(&self, expr_ptr: i64) -> i64 {
        # UNWRAP: field0 = inner expr (Optional/Result value)
        # Simply extract the value (second field), assume it's valid
        inner_ptr := load_i64(expr_ptr + 24)
        result_reg := @.generate_expr(inner_ptr)

        # Load value from offset 8 (skip tag)
        val_offset := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(val_offset)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(result_reg)
        @.emit_cstr(", 8\n")

        val_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(val_reg)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(val_offset)
        @.emit_cstr(")\n")

        val_reg
    }

    # ========== Assign Op (+=, -=, *=, /=) ==========

    F generate_assign_op(&self, expr_ptr: i64) -> i64 {
        # ASSIGN_OP: field0 = target, field1 = value, field2 = op
        target_ptr := load_i64(expr_ptr + 24)
        value_ptr := load_i64(expr_ptr + 32)
        op := load_i64(expr_ptr + 40)

        target_kind := load_i64(target_ptr)
        I target_kind != 25 {
            # Not an identifier target
            R @.generate_expr(value_ptr)
        }

        target_name_idx := load_i64(target_ptr + 24)
        local_ptr := @.find_local(target_name_idx)

        I local_ptr == 0 {
            R @.generate_expr(value_ptr)
        }

        is_alloca := load_i64(local_ptr + 40)
        type_kind := load_i64(local_ptr + 24)

        I is_alloca != 1 {
            R @.generate_expr(value_ptr)
        }

        # Load current value
        alloca_reg := load_i64(local_ptr + 8)
        current_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(current_reg)
        @.emit_cstr(" = load ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr(", ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr("* ")
        @.emit_reg(alloca_reg)
        @.emit_cstr("\n")

        # Generate RHS
        rhs_reg := @.generate_expr(value_ptr)

        # Apply operation
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ")

        I op == OP_ADD() { @.emit_cstr("add i64 ") }
        E I op == OP_SUB() { @.emit_cstr("sub i64 ") }
        E I op == OP_MUL() { @.emit_cstr("mul i64 ") }
        E I op == OP_DIV() { @.emit_cstr("sdiv i64 ") }
        E I op == OP_MOD() { @.emit_cstr("srem i64 ") }
        E { @.emit_cstr("add i64 ") }

        @.emit_reg(current_reg)
        @.emit_cstr(", ")
        @.emit_reg(rhs_reg)
        @.emit_cstr("\n")

        # Store back
        @.emit_cstr("  store ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr(" ")
        @.emit_reg(result)
        @.emit_cstr(", ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr("* ")
        @.emit_reg(alloca_reg)
        @.emit_cstr("\n")

        result
    }

    # ========== Match Expression ==========

    F generate_match(&self, expr_ptr: i64) -> i64 {
        # MATCH: field0 = scrutinee expr, field1 = arms ptr, field2 = arms_len
        scrutinee_ptr := load_i64(expr_ptr + 24)
        arms_ptr := load_i64(expr_ptr + 32)
        arms_len := load_i64(expr_ptr + 40)

        # Generate scrutinee
        scrutinee_reg := @.generate_expr(scrutinee_ptr)

        merge_label := @.fresh_label()

        # Allocate array for (arm_label, result_reg) pairs for phi node
        arm_results_ptr := malloc(arms_len * 16)  # (label_id, result_reg) pairs

        i: mut i64 = 0
        L { I i >= arms_len { B }
            arm_ptr := arms_ptr + i * 40  # MatchArm.size() = 40
            pattern_ptr := load_i64(arm_ptr)
            body_ptr := load_i64(arm_ptr + 16)

            arm_label := @.fresh_label()
            next_label := I i + 1 < arms_len { @.fresh_label() } E { merge_label }

            # Pattern matching: compare scrutinee against pattern
            pat_kind := load_i64(pattern_ptr)

            # PAT_WILDCARD = 80, PAT_IDENT = 81
            I pat_kind == 80 || pat_kind == 81 {
                # Wildcard/ident always matches
                I pat_kind == 81 {
                    # Bind the scrutinee value to the pattern variable
                    bind_name_idx := load_i64(pattern_ptr + 24)
                    alloca_reg := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(alloca_reg)
                    @.emit_cstr(" = alloca i64\n")
                    @.emit_cstr("  store i64 ")
                    @.emit_reg(scrutinee_reg)
                    @.emit_cstr(", i64* ")
                    @.emit_reg(alloca_reg)
                    @.emit_cstr("\n")
                    name_ptr := @.get_string_ptr(bind_name_idx)
                    name_len := @.get_string_len(bind_name_idx)
                    local_idx := @.add_local(bind_name_idx, alloca_reg, 0, LLVM_I64(), 0)
                    local_ptr := self.locals_ptr + local_idx * 48  # LocalVar.size()
                    store_i64(local_ptr + 40, 1)  # is_alloca = 1
                    0
                } E { 0 }
                @.emit_cstr("  br label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr("\n")
            }
            # PAT_LITERAL = 82
            E I pat_kind == 82 {
                lit_value := load_i64(pattern_ptr + 24)
                cmp_reg := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(cmp_reg)
                @.emit_cstr(" = icmp eq i64 ")
                @.emit_reg(scrutinee_reg)
                @.emit_cstr(", ")
                @.emit_i64(lit_value)
                @.emit_cstr("\n")
                @.emit_cstr("  br i1 ")
                @.emit_reg(cmp_reg)
                @.emit_cstr(", label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr(", label %next")
                @.emit_i64(next_label)
                @.emit_cstr("\n")
            }
            # PAT_VARIANT = 85 (enum variant: compare tag)
            E I pat_kind == 85 {
                variant_name_idx := load_i64(pattern_ptr + 24)
                # Compare tag (treat variant name as tag index for now)
                cmp_reg := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(cmp_reg)
                @.emit_cstr(" = icmp eq i64 ")
                @.emit_reg(scrutinee_reg)
                @.emit_cstr(", ")
                @.emit_i64(variant_name_idx)
                @.emit_cstr("\n")
                @.emit_cstr("  br i1 ")
                @.emit_reg(cmp_reg)
                @.emit_cstr(", label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr(", label %next")
                @.emit_i64(next_label)
                @.emit_cstr("\n")
            }
            E {
                # Other patterns: default to always-match
                @.emit_cstr("  br label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr("\n")
            }

            # Arm body
            @.emit_cstr("arm")
            @.emit_i64(arm_label)
            @.emit_cstr(":\n")
            arm_result := @.generate_expr(body_ptr)

            # Store result for phi
            store_i64(arm_results_ptr + i * 16, arm_label)
            store_i64(arm_results_ptr + i * 16 + 8, arm_result)

            @.emit_cstr("  br label %merge")
            @.emit_i64(merge_label)
            @.emit_cstr("\n")

            # Next label (for non-wildcard patterns)
            I i + 1 < arms_len && pat_kind != 80 && pat_kind != 81 {
                @.emit_cstr("next")
                @.emit_i64(next_label)
                @.emit_cstr(":\n")
            } E { 0 }

            i = i + 1
        }

        # Merge block with phi
        @.emit_cstr("merge")
        @.emit_i64(merge_label)
        @.emit_cstr(":\n")

        result := @.fresh_reg()
        I arms_len > 0 {
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = phi i64 ")
            j: mut i64 = 0
            L { I j >= arms_len { B }
                I j > 0 { @.emit_cstr(", ") } E { 0 }
                arm_label := load_i64(arm_results_ptr + j * 16)
                arm_result := load_i64(arm_results_ptr + j * 16 + 8)
                @.emit_cstr("[ ")
                @.emit_reg(arm_result)
                @.emit_cstr(", %arm")
                @.emit_i64(arm_label)
                @.emit_cstr(" ]")
                j = j + 1
            }
            @.emit_cstr("\n")
        } E {
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0\n")
        }

        free(arm_results_ptr)
        result
    }

    # ========== Ternary Expression ==========

    F generate_ternary(&self, expr_ptr: i64) -> i64 {
        # TERNARY: field0 = cond, field1 = then_expr, field2 = else_expr
        cond_ptr := load_i64(expr_ptr + 24)
        then_ptr := load_i64(expr_ptr + 32)
        else_ptr := load_i64(expr_ptr + 40)

        label_id := @.fresh_label()

        # Generate condition
        cond_reg := @.generate_expr(cond_ptr)

        cond_i1 := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(cond_i1)
        @.emit_cstr(" = trunc i64 ")
        @.emit_reg(cond_reg)
        @.emit_cstr(" to i1\n")

        @.emit_cstr("  br i1 ")
        @.emit_reg(cond_i1)
        @.emit_cstr(", label %tern_then")
        @.emit_i64(label_id)
        @.emit_cstr(", label %tern_else")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Then branch
        @.emit_cstr("tern_then")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        then_reg := @.generate_expr(then_ptr)
        @.emit_cstr("  br label %tern_merge")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Else branch
        @.emit_cstr("tern_else")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        else_reg := @.generate_expr(else_ptr)
        @.emit_cstr("  br label %tern_merge")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Merge with phi
        @.emit_cstr("tern_merge")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = phi i64 [ ")
        @.emit_reg(then_reg)
        @.emit_cstr(", %tern_then")
        @.emit_i64(label_id)
        @.emit_cstr(" ], [ ")
        @.emit_reg(else_reg)
        @.emit_cstr(", %tern_else")
        @.emit_i64(label_id)
        @.emit_cstr(" ]\n")

        result
    }

    # ========== Method Call ==========

    F generate_method_call(&self, expr_ptr: i64) -> i64 {
        # METHOD_CALL: field0 = receiver, field1 = method_idx, field2 = args_ptr, field3 = args_len
        receiver_ptr := load_i64(expr_ptr + 24)
        method_idx := load_i64(expr_ptr + 32)
        args_ptr := load_i64(expr_ptr + 40)
        args_len := load_i64(expr_ptr + 48)

        # Generate receiver
        recv_reg := @.generate_expr(receiver_ptr)

        # Generate arguments
        total_args := args_len + 1  # receiver + args
        arg_regs_ptr := malloc(total_args * 8)
        store_i64(arg_regs_ptr, recv_reg)  # receiver is first arg

        i: mut i64 = 0
        L { I i >= args_len { B }
            arg_expr := load_i64(args_ptr + i * 8)
            arg_reg := @.generate_expr(arg_expr)
            store_i64(arg_regs_ptr + (i + 1) * 8, arg_reg)
            i = i + 1
        }

        # For now, emit call using method name directly
        # TODO: proper method dispatch with receiver type prefix
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @")
        @.emit_string_idx(method_idx)
        @.emit_cstr("(")

        j: mut i64 = 0
        L { I j >= total_args { B }
            I j > 0 { @.emit_cstr(", ") } E { 0 }
            @.emit_cstr("i64 ")
            arg_reg := load_i64(arg_regs_ptr + j * 8)
            @.emit_reg(arg_reg)
            j = j + 1
        }

        @.emit_cstr(")\n")
        free(arg_regs_ptr)
        result
    }

    # ========== Static Call ==========

    F generate_static_call(&self, expr_ptr: i64) -> i64 {
        # STATIC_CALL: field0 = type_idx, field1 = method_idx, field2 = args_ptr, field3 = args_len
        type_idx := load_i64(expr_ptr + 24)
        method_idx := load_i64(expr_ptr + 32)
        args_ptr := load_i64(expr_ptr + 40)
        args_len := load_i64(expr_ptr + 48)

        # Generate arguments
        arg_regs_ptr := malloc(args_len * 8)
        i: mut i64 = 0
        L { I i >= args_len { B }
            arg_expr := load_i64(args_ptr + i * 8)
            arg_reg := @.generate_expr(arg_expr)
            store_i64(arg_regs_ptr + i * 8, arg_reg)
            i = i + 1
        }

        # Emit call as TypeName.method_name
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @")
        @.emit_string_idx(type_idx)
        @.emit_cstr(".")
        @.emit_string_idx(method_idx)
        @.emit_cstr("(")

        j: mut i64 = 0
        L { I j >= args_len { B }
            I j > 0 { @.emit_cstr(", ") } E { 0 }
            @.emit_cstr("i64 ")
            arg_reg := load_i64(arg_regs_ptr + j * 8)
            @.emit_reg(arg_reg)
            j = j + 1
        }

        @.emit_cstr(")\n")
        free(arg_regs_ptr)
        result
    }

    # ========== Field Access ==========

    F generate_field_access(&self, expr_ptr: i64) -> i64 {
        # FIELD: field0 = expr_ptr, field1 = field_idx
        obj_expr := load_i64(expr_ptr + 24)
        field_idx := load_i64(expr_ptr + 32)

        # Generate object expression (should be a pointer to struct)
        obj_reg := @.generate_expr(obj_expr)

        # Look up field offset in struct info
        # For now, use field_idx as offset index (field_idx * 8)
        offset_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(offset_reg)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(obj_reg)
        @.emit_cstr(", ")
        @.emit_i64(field_idx * 8)
        @.emit_cstr("\n")

        # Load the field value
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(offset_reg)
        @.emit_cstr(")\n")

        result
    }

    # ========== Struct Literal ==========

    F generate_struct_lit(&self, expr_ptr: i64) -> i64 {
        # STRUCT_LIT: field0 = name_idx, field1 = fields_ptr, field2 = fields_len
        name_idx := load_i64(expr_ptr + 24)
        fields_ptr := load_i64(expr_ptr + 32)
        fields_len := load_i64(expr_ptr + 40)

        # Allocate memory for the struct (fields_len * 8 bytes)
        size := fields_len * 8
        I size == 0 { size = 8 } E { 0 }  # Minimum 8 bytes

        # Call malloc
        size_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(size_reg)
        @.emit_cstr(" = add i64 0, ")
        @.emit_i64(size)
        @.emit_cstr("\n")

        raw_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" = call i8* @malloc(i64 ")
        @.emit_reg(size_reg)
        @.emit_cstr(")\n")

        struct_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(struct_ptr)
        @.emit_cstr(" = ptrtoint i8* ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" to i64\n")

        # Initialize each field
        # FieldInit: name_idx (0), value_ptr (8), span_start (16), span_end (24) - size 32
        i: mut i64 = 0
        L { I i >= fields_len { B }
            field_ptr := fields_ptr + i * 32  # FieldInit.size() = 32
            value_expr := load_i64(field_ptr + 8)

            value_reg := @.generate_expr(value_expr)

            # Store at offset i * 8
            field_offset := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(field_offset)
            @.emit_cstr(" = add i64 ")
            @.emit_reg(struct_ptr)
            @.emit_cstr(", ")
            @.emit_i64(i * 8)
            @.emit_cstr("\n")

            @.emit_cstr("  call void @store_i64(i64 ")
            @.emit_reg(field_offset)
            @.emit_cstr(", i64 ")
            @.emit_reg(value_reg)
            @.emit_cstr(")\n")

            i = i + 1
        }

        struct_ptr
    }

    # ========== Output ==========

    F get_output(&self) -> i64 = load_i64(self.output)
    F get_output_len(&self) -> i64 = load_i64(self.output + 8)

    F drop(&self) -> i64 {
        # Free output buffer
        buf_data := load_i64(self.output)
        free(buf_data)
        free(self.output)

        # Free temp buffer
        temp_data := load_i64(self.temp_buf)
        free(temp_data)
        free(self.temp_buf)

        # Free lambda buffer
        lambda_data := load_i64(self.lambda_buf)
        free(lambda_data)
        free(self.lambda_buf)

        # Free other allocations
        free(self.functions_ptr)
        free(self.structs_ptr)
        free(self.locals_ptr)
        free(self.loop_stack_ptr)
        free(self.strings_ptr)

        # Free monomorphization allocations
        free(self.generic_fns_ptr)
        free(self.mono_entries_ptr)
        free(self.mono_bind_keys_ptr)
        free(self.mono_bind_values_ptr)

        1
    }
}

# ============================================================================
# Test function (renamed from main to allow module import)
# ============================================================================

F test_codegen_main() -> i64 {
    puts("Code generator module loaded")

    # Test StringBuffer
    buf := StringBuffer.new(64)
    buf.append_cstr("Hello, ")
    buf.append_cstr("World!")
    I buf.len == 13 {
        puts("StringBuffer append: OK")
    } E {
        puts("StringBuffer append: FAIL")
    }

    buf.append_i64(42)
    I buf.len == 15 {
        puts("StringBuffer append_i64: OK")
    } E {
        puts("StringBuffer append_i64: FAIL")
    }

    buf.drop()

    # Test CodeGenerator creation
    gen := CodeGenerator.new()
    I gen.functions_cap == 128 {
        puts("CodeGenerator creation: OK")
    } E {
        puts("CodeGenerator creation: FAIL")
    }

    # Test register generation
    reg1 := gen.fresh_reg()
    reg2 := gen.fresh_reg()
    I reg1 == 0 && reg2 == 1 {
        puts("Register generation: OK")
    } E {
        puts("Register generation: FAIL")
    }

    # Test label generation
    label1 := gen.fresh_label()
    label2 := gen.fresh_label()
    I label1 == 0 && label2 == 1 {
        puts("Label generation: OK")
    } E {
        puts("Label generation: FAIL")
    }

    # Test local variable management
    gen.add_local(0, 0, 0, LLVM_I64(), 1)
    found := gen.find_local(0)
    I found != 0 {
        puts("Local variable: OK")
    } E {
        puts("Local variable: FAIL")
    }

    # Test type conversion
    I gen.resolved_type_to_llvm(4) == LLVM_I64() {
        puts("Type conversion i64: OK")
    } E {
        puts("Type conversion i64: FAIL")
    }

    I gen.resolved_type_to_llvm(13) == LLVM_I1() {
        puts("Type conversion bool: OK")
    } E {
        puts("Type conversion bool: FAIL")
    }

    gen.drop()

    puts("All code generator tests passed!")
    0
}
