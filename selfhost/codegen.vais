# Vais Self-Hosting Compiler - Code Generator Module
# Generates LLVM IR from typed AST
# Note: This is a simplified code generator for bootstrapping purposes

# ============================================================================
# LLVM IR Generation Constants
# ============================================================================

# Binary operators for LLVM
F OP_ADD() -> i64 = 1
F OP_SUB() -> i64 = 2
F OP_MUL() -> i64 = 3
F OP_DIV() -> i64 = 4
F OP_MOD() -> i64 = 5
F OP_LT() -> i64 = 6
F OP_LTE() -> i64 = 7
F OP_GT() -> i64 = 8
F OP_GTE() -> i64 = 9
F OP_EQ() -> i64 = 10
F OP_NEQ() -> i64 = 11
F OP_AND() -> i64 = 12
F OP_OR() -> i64 = 13
F OP_BIT_AND() -> i64 = 14
F OP_BIT_OR() -> i64 = 15
F OP_BIT_XOR() -> i64 = 16
F OP_SHL() -> i64 = 17
F OP_SHR() -> i64 = 18

# Unary operators
F UOP_NEG() -> i64 = 1
F UOP_NOT() -> i64 = 2
F UOP_BITNOT() -> i64 = 3

# Type kinds for LLVM mapping
F LLVM_VOID() -> i64 = 0
F LLVM_I1() -> i64 = 1
F LLVM_I8() -> i64 = 2
F LLVM_I16() -> i64 = 3
F LLVM_I32() -> i64 = 4
F LLVM_I64() -> i64 = 5
F LLVM_I128() -> i64 = 6
F LLVM_FLOAT() -> i64 = 7
F LLVM_DOUBLE() -> i64 = 8
F LLVM_PTR() -> i64 = 9
F LLVM_STRUCT() -> i64 = 10

# ============================================================================
# String Buffer for IR Output
# ============================================================================

S StringBuffer {
    data: i64,       # Pointer to string data
    len: i64,        # Current length
    cap: i64         # Capacity
}

X StringBuffer {
    F new(initial_cap: i64) -> StringBuffer {
        data := malloc(initial_cap)
        StringBuffer { data: data, len: 0, cap: initial_cap }
    }

    F append_byte(&self, byte: i64) -> i64 {
        I self.len >= self.cap {
            @.grow()
            0
        } E { 0 }
        store_byte(self.data + self.len, byte)
        self.len = self.len + 1
        1
    }

    F append_ptr(&self, ptr: i64, len: i64) -> i64 {
        I self.len + len > self.cap {
            @.grow_to(self.len + len + 1024)
            0
        } E { 0 }
        memcpy(self.data + self.len, ptr, len)
        self.len = self.len + len
        1
    }

    F append_cstr(&self, s: str) -> i64 {
        len := strlen(s)
        I self.len + len > self.cap {
            @.grow_to(self.len + len + 1024)
            0
        } E { 0 }
        memcpy_str(self.data + self.len, s, len)
        self.len = self.len + len
        1
    }

    F append_i64(&self, value: i64) -> i64 {
        # Convert i64 to string and append
        I value == 0 {
            @.append_byte(48)  # '0'
            1
        } E I value < 0 {
            @.append_byte(45)  # '-'
            @.append_i64(0 - value)
        } E {
            # Recursively build digits
            I value >= 10 {
                @.append_i64(value / 10)
                0
            } E { 0 }
            digit := (value % 10) + 48
            @.append_byte(digit)
            1
        }
    }

    F append_newline(&self) -> i64 = @.append_byte(10)

    F grow(&self) -> i64 {
        @.grow_to(self.cap * 2)
    }

    F grow_to(&self, new_cap: i64) -> i64 {
        new_data := malloc(new_cap)
        memcpy(new_data, self.data, self.len)
        free(self.data)
        self.data = new_data
        self.cap = new_cap
        1
    }

    F get_ptr(&self) -> i64 = self.data
    F get_len(&self) -> i64 = self.len

    F clear(&self) -> i64 {
        self.len = 0
        1
    }

    F drop(&self) -> i64 {
        free(self.data)
        1
    }
}

# ============================================================================
# Local Variable Info
# ============================================================================

S LocalVar {
    name_idx: i64,       # String pool index
    llvm_name_ptr: i64,  # LLVM register name (e.g., "%x", "%1")
    llvm_name_len: i64,
    type_kind: i64,      # LLVM type kind
    is_param: i64,       # 1 if function parameter
    is_alloca: i64       # 1 if stack allocated (has pointer semantics)
}

X LocalVar {
    F size() -> i64 = 48

    F new(name_idx: i64, llvm_ptr: i64, llvm_len: i64, type_kind: i64, is_param: i64) -> LocalVar = LocalVar {
        name_idx: name_idx,
        llvm_name_ptr: llvm_ptr,
        llvm_name_len: llvm_len,
        type_kind: type_kind,
        is_param: is_param,
        is_alloca: 0
    }
}

# ============================================================================
# Function Info
# ============================================================================

S FunctionInfo {
    name_idx: i64,
    params_ptr: i64,      # Array of (name_idx, type_kind) pairs
    params_len: i64,
    ret_type: i64,        # LLVM type kind
    is_extern: i64
}

X FunctionInfo {
    F size() -> i64 = 40

    F new(name_idx: i64) -> FunctionInfo = FunctionInfo {
        name_idx: name_idx,
        params_ptr: 0, params_len: 0,
        ret_type: LLVM_VOID(),
        is_extern: 0
    }
}

# ============================================================================
# Struct Info
# ============================================================================

S StructFieldInfo {
    name_idx: i64,
    type_kind: i64,
    offset: i64
}

X StructFieldInfo {
    F size() -> i64 = 24
}

S StructTypeInfo {
    name_idx: i64,
    fields_ptr: i64,
    fields_len: i64,
    total_size: i64
}

X StructTypeInfo {
    F size() -> i64 = 32

    F new(name_idx: i64) -> StructTypeInfo = StructTypeInfo {
        name_idx: name_idx,
        fields_ptr: 0, fields_len: 0,
        total_size: 0
    }
}

# ============================================================================
# Loop Context (for break/continue)
# ============================================================================

S LoopContext {
    break_label_ptr: i64,
    break_label_len: i64,
    continue_label_ptr: i64,
    continue_label_len: i64
}

X LoopContext {
    F size() -> i64 = 32
}

# ============================================================================
# VTable Entry (for trait dispatch)
# ============================================================================

S VtableEntry {
    impl_type_idx: i64,     # Name index of the implementing type
    trait_name_idx: i64,    # Name index of the trait
    methods_ptr: i64,       # Array of method name_idx (in trait declaration order)
    methods_len: i64,       # Number of methods
    vtable_name_ptr: i64,   # Pointer to mangled vtable name string
    vtable_name_len: i64    # Length of vtable name string
}

X VtableEntry {
    F size() -> i64 = 48
}

# ============================================================================
# Code Generator
# ============================================================================

S CodeGenerator {
    # Output buffer
    output: i64,         # Pointer to StringBuffer

    # String pool reference
    sp_data: i64,
    sp_offsets: i64,
    sp_count: i64,

    # Registered functions
    functions_ptr: i64,
    functions_len: i64,
    functions_cap: i64,

    # Registered structs
    structs_ptr: i64,
    structs_len: i64,
    structs_cap: i64,

    # Local variables in current function
    locals_ptr: i64,
    locals_len: i64,
    locals_cap: i64,

    # Loop stack for break/continue
    loop_stack_ptr: i64,
    loop_stack_len: i64,
    loop_stack_cap: i64,

    # Counters
    reg_counter: i64,
    label_counter: i64,
    string_counter: i64,

    # String constants (for global storage)
    strings_ptr: i64,     # Array of (name_ptr, name_len, value_ptr, value_len)
    strings_len: i64,
    strings_cap: i64,

    # Current function context
    current_fn_name_idx: i64,
    current_fn_ret_type: i64,

    # Temp buffer for building strings
    temp_buf: i64,        # Pointer to StringBuffer

    # Lambda functions buffer (emitted after main functions)
    lambda_buf: i64,      # Pointer to StringBuffer for lambda function defs
    lambda_counter: i64,  # Counter for generating unique lambda names

    # Monomorphization support
    # Generic function AST pointers (saved for later specialization)
    generic_fns_ptr: i64,    # Array of fn_ptr (i64 pointers to FunctionDef AST nodes)
    generic_fns_len: i64,
    generic_fns_cap: i64,

    # Monomorphization entries from type checker
    # Each entry: (fn_name_idx: i64, type_args_ptr: i64, type_args_len: i64) = 24 bytes
    mono_entries_ptr: i64,
    mono_entries_len: i64,
    mono_entries_cap: i64,

    # Current generic bindings for monomorphized function generation
    # Each binding: (generic_name_idx: i64, concrete_type_kind: i64) = 16 bytes
    mono_bind_keys_ptr: i64,
    mono_bind_values_ptr: i64,
    mono_bind_len: i64,
    mono_bind_cap: i64,

    # VTable entries for trait dispatch
    vtables_ptr: i64,        # Array of VtableEntry
    vtables_len: i64,
    vtables_cap: i64,

    # Trait definition info (from type checker)
    # Each: (trait_name_idx, methods_ptr, methods_len) = 24 bytes
    trait_defs_ptr: i64,
    trait_defs_len: i64,
    trait_defs_cap: i64,

    # Generic struct AST pointers (saved for later specialization)
    generic_structs_ptr: i64,    # Array of struct_ptr (i64 pointers to StructDef AST nodes)
    generic_structs_len: i64,
    generic_structs_cap: i64,

    # Struct monomorphization entries
    # Each entry: (struct_name_idx: i64, type_args_ptr: i64, type_args_len: i64) = 24 bytes
    struct_mono_ptr: i64,
    struct_mono_len: i64,
    struct_mono_cap: i64,

    # Current impl block context (for method name prefixing)
    current_impl_type_idx: i64,  # -1 when not in impl block

    # Defer stack: expr_ptr values in LIFO order (per function)
    defer_stack_ptr: i64,
    defer_stack_len: i64,
    defer_stack_cap: i64
}

X CodeGenerator {
    F new() -> CodeGenerator {
        output_buf := malloc(88)  # StringBuffer size (approximated)
        temp := StringBuffer.new(8192)
        store_i64(output_buf, temp.data)
        store_i64(output_buf + 8, temp.len)
        store_i64(output_buf + 16, temp.cap)

        temp_buf := malloc(88)
        temp2 := StringBuffer.new(4096)
        store_i64(temp_buf, temp2.data)
        store_i64(temp_buf + 8, temp2.len)
        store_i64(temp_buf + 16, temp2.cap)

        lambda_buf := malloc(88)
        lambda_sb := StringBuffer.new(4096)
        store_i64(lambda_buf, lambda_sb.data)
        store_i64(lambda_buf + 8, lambda_sb.len)
        store_i64(lambda_buf + 16, lambda_sb.cap)

        CodeGenerator {
            output: output_buf,
            sp_data: 0, sp_offsets: 0, sp_count: 0,
            functions_ptr: malloc(128 * FunctionInfo.size()),
            functions_len: 0, functions_cap: 128,
            structs_ptr: malloc(64 * StructTypeInfo.size()),
            structs_len: 0, structs_cap: 64,
            locals_ptr: malloc(64 * LocalVar.size()),
            locals_len: 0, locals_cap: 64,
            loop_stack_ptr: malloc(16 * LoopContext.size()),
            loop_stack_len: 0, loop_stack_cap: 16,
            reg_counter: 0,
            label_counter: 0,
            string_counter: 0,
            strings_ptr: malloc(256 * 32),  # 256 strings, 32 bytes each
            strings_len: 0, strings_cap: 256,
            current_fn_name_idx: 0,
            current_fn_ret_type: LLVM_VOID(),
            temp_buf: temp_buf,
            lambda_buf: lambda_buf,
            lambda_counter: 0,
            generic_fns_ptr: malloc(64 * 8),
            generic_fns_len: 0, generic_fns_cap: 64,
            mono_entries_ptr: malloc(64 * 24),
            mono_entries_len: 0, mono_entries_cap: 64,
            mono_bind_keys_ptr: malloc(32 * 8),
            mono_bind_values_ptr: malloc(32 * 8),
            mono_bind_len: 0, mono_bind_cap: 32,
            vtables_ptr: malloc(32 * VtableEntry.size()),
            vtables_len: 0, vtables_cap: 32,
            trait_defs_ptr: malloc(32 * 24),
            trait_defs_len: 0, trait_defs_cap: 32,
            generic_structs_ptr: malloc(32 * 8),
            generic_structs_len: 0, generic_structs_cap: 32,
            struct_mono_ptr: malloc(32 * 24),
            struct_mono_len: 0, struct_mono_cap: 32,
            current_impl_type_idx: 0 - 1,
            defer_stack_ptr: malloc(32 * 8),
            defer_stack_len: 0, defer_stack_cap: 32
        }
    }

    # ========== String Pool Access ==========

    F set_string_pool(&self, sp_data: i64, sp_offsets: i64, sp_count: i64) -> i64 {
        self.sp_data = sp_data
        self.sp_offsets = sp_offsets
        self.sp_count = sp_count
        1
    }

    F get_string_ptr(&self, idx: i64) -> i64 {
        entry_ptr := self.sp_offsets + idx * 16
        offset := load_i64(entry_ptr)
        self.sp_data + offset
    }

    F get_string_len(&self, idx: i64) -> i64 {
        entry_ptr := self.sp_offsets + idx * 16
        load_i64(entry_ptr + 8)
    }

    # ========== Output Methods ==========

    F emit_ptr(&self, ptr: i64, len: i64) -> i64 {
        buf_data: mut i64 = load_i64(self.output)
        buf_len := load_i64(self.output + 8)
        buf_cap := load_i64(self.output + 16)

        I buf_len + len > buf_cap {
            new_cap := (buf_cap + len) * 2
            new_data := malloc(new_cap)
            memcpy(new_data, buf_data, buf_len)
            free(buf_data)
            store_i64(self.output, new_data)
            store_i64(self.output + 16, new_cap)
            buf_data = new_data
            0
        } E { 0 }

        memcpy(buf_data + buf_len, ptr, len)
        store_i64(self.output + 8, buf_len + len)
        1
    }

    F emit(&self, ptr: i64, len: i64) -> i64 = @.emit_ptr(ptr, len)

    F emit_cstr(&self, s: str) -> i64 {
        len := strlen(s)
        buf_data: mut i64 = load_i64(self.output)
        buf_len := load_i64(self.output + 8)
        buf_cap := load_i64(self.output + 16)

        I buf_len + len > buf_cap {
            new_cap := (buf_cap + len) * 2
            new_data := malloc(new_cap)
            memcpy(new_data, buf_data, buf_len)
            free(buf_data)
            store_i64(self.output, new_data)
            store_i64(self.output + 16, new_cap)
            buf_data = new_data
            0
        } E { 0 }

        memcpy_str(buf_data + buf_len, s, len)
        store_i64(self.output + 8, buf_len + len)
        1
    }

    F emit_i64(&self, value: i64) -> i64 {
        # Clear temp buffer
        store_i64(self.temp_buf + 8, 0)
        tb_data := load_i64(self.temp_buf)

        I value == 0 {
            store_byte(tb_data, 48)
            @.emit_ptr(tb_data, 1)
        } E I value < 0 {
            store_byte(tb_data, 45)
            @.emit_ptr(tb_data, 1)
            @.emit_i64(0 - value)
        } E {
            @.emit_positive_i64(value)
        }
    }

    F emit_positive_i64(&self, value: i64) -> i64 {
        I value == 0 { R 1 }
        @.emit_positive_i64(value / 10)
        digit := (value % 10) + 48
        tb_data := load_i64(self.temp_buf)
        store_byte(tb_data, digit)
        @.emit_ptr(tb_data, 1)
    }

    F emit_newline(&self) -> i64 {
        tb_data := load_i64(self.temp_buf)
        store_byte(tb_data, 10)
        @.emit_ptr(tb_data, 1)
    }

    F emit_string_idx(&self, idx: i64) -> i64 {
        ptr := @.get_string_ptr(idx)
        len := @.get_string_len(idx)
        @.emit_ptr(ptr, len)
    }

    # ========== Register/Label Generation ==========

    F fresh_reg(&self) -> i64 {
        n := self.reg_counter
        self.reg_counter = self.reg_counter + 1
        n
    }

    F fresh_label(&self) -> i64 {
        n := self.label_counter
        self.label_counter = self.label_counter + 1
        n
    }

    F emit_reg(&self, n: i64) -> i64 {
        @.emit_cstr("%")
        @.emit_i64(n)
    }

    F emit_label(&self, prefix: str, n: i64) -> i64 {
        @.emit_cstr(prefix)
        @.emit_i64(n)
    }

    # ========== Type Conversion ==========

    F type_to_llvm_str(&self, type_kind: i64) -> i64 {
        I type_kind == LLVM_VOID() { @.emit_cstr("void") }
        E I type_kind == LLVM_I1() { @.emit_cstr("i1") }
        E I type_kind == LLVM_I8() { @.emit_cstr("i8") }
        E I type_kind == LLVM_I16() { @.emit_cstr("i16") }
        E I type_kind == LLVM_I32() { @.emit_cstr("i32") }
        E I type_kind == LLVM_I64() { @.emit_cstr("i64") }
        E I type_kind == LLVM_I128() { @.emit_cstr("i128") }
        E I type_kind == LLVM_FLOAT() { @.emit_cstr("float") }
        E I type_kind == LLVM_DOUBLE() { @.emit_cstr("double") }
        E I type_kind == LLVM_PTR() { @.emit_cstr("i8*") }
        E { @.emit_cstr("i64") }  # Default
    }

    F resolved_type_to_llvm(&self, resolved_kind: i64) -> i64 {
        # Map ResolvedType kind to LLVM type kind
        # TY_I8 = 1, TY_I16 = 2, TY_I32 = 3, TY_I64 = 4, etc.
        I resolved_kind == 1 { LLVM_I8() }
        E I resolved_kind == 2 { LLVM_I16() }
        E I resolved_kind == 3 { LLVM_I32() }
        E I resolved_kind == 4 { LLVM_I64() }
        E I resolved_kind == 5 { LLVM_I128() }
        E I resolved_kind == 6 { LLVM_I8() }   # u8
        E I resolved_kind == 7 { LLVM_I16() }  # u16
        E I resolved_kind == 8 { LLVM_I32() }  # u32
        E I resolved_kind == 9 { LLVM_I64() }  # u64
        E I resolved_kind == 10 { LLVM_I128() } # u128
        E I resolved_kind == 11 { LLVM_FLOAT() }
        E I resolved_kind == 12 { LLVM_DOUBLE() }
        E I resolved_kind == 13 { LLVM_I1() }  # bool
        E I resolved_kind == 14 { LLVM_PTR() } # str
        E I resolved_kind == 15 { LLVM_VOID() } # unit
        E I resolved_kind == 21 { LLVM_PTR() } # pointer
        E I resolved_kind == 22 { LLVM_PTR() } # ref
        E I resolved_kind == 23 { LLVM_PTR() } # ref_mut
        E { LLVM_I64() }
    }

    # ========== Local Variables ==========

    F add_local(&self, name_idx: i64, llvm_ptr: i64, llvm_len: i64, type_kind: i64, is_param: i64) -> i64 {
        I self.locals_len >= self.locals_cap {
            new_cap := self.locals_cap * 2
            new_ptr := malloc(new_cap * LocalVar.size())
            memcpy(new_ptr, self.locals_ptr, self.locals_len * LocalVar.size())
            free(self.locals_ptr)
            self.locals_ptr = new_ptr
            self.locals_cap = new_cap
            0
        } E { 0 }

        ptr := self.locals_ptr + self.locals_len * LocalVar.size()
        store_i64(ptr, name_idx)
        store_i64(ptr + 8, llvm_ptr)
        store_i64(ptr + 16, llvm_len)
        store_i64(ptr + 24, type_kind)
        store_i64(ptr + 32, is_param)
        store_i64(ptr + 40, 0)  # is_alloca

        self.locals_len = self.locals_len + 1
        self.locals_len - 1
    }

    F find_local(&self, name_idx: i64) -> i64 {
        i: mut i64 = self.locals_len
        L { I i == 0 { B }
            i = i - 1
            ptr := self.locals_ptr + i * LocalVar.size()
            local_name := load_i64(ptr)
            I local_name == name_idx {
                R ptr
            } E { 0 }
        }
        0  # Not found
    }

    F clear_locals(&self) -> i64 {
        self.locals_len = 0
        1
    }

    # ========== Function Registration ==========

    F add_function(&self, name_idx: i64, ret_type: i64, is_extern: i64) -> i64 {
        I self.functions_len >= self.functions_cap {
            new_cap := self.functions_cap * 2
            new_ptr := malloc(new_cap * FunctionInfo.size())
            memcpy(new_ptr, self.functions_ptr, self.functions_len * FunctionInfo.size())
            free(self.functions_ptr)
            self.functions_ptr = new_ptr
            self.functions_cap = new_cap
            0
        } E { 0 }

        ptr := self.functions_ptr + self.functions_len * FunctionInfo.size()
        store_i64(ptr, name_idx)
        store_i64(ptr + 8, 0)    # params_ptr
        store_i64(ptr + 16, 0)   # params_len
        store_i64(ptr + 24, ret_type)
        store_i64(ptr + 32, is_extern)

        self.functions_len = self.functions_len + 1
        ptr
    }

    F find_function(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.functions_len { B }
            ptr := self.functions_ptr + i * FunctionInfo.size()
            fn_name := load_i64(ptr)
            I fn_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0
    }

    # ========== Struct Registration ==========

    F add_struct(&self, name_idx: i64) -> i64 {
        I self.structs_len >= self.structs_cap {
            new_cap := self.structs_cap * 2
            new_ptr := malloc(new_cap * StructTypeInfo.size())
            memcpy(new_ptr, self.structs_ptr, self.structs_len * StructTypeInfo.size())
            free(self.structs_ptr)
            self.structs_ptr = new_ptr
            self.structs_cap = new_cap
            0
        } E { 0 }

        ptr := self.structs_ptr + self.structs_len * StructTypeInfo.size()
        store_i64(ptr, name_idx)
        store_i64(ptr + 8, 0)   # fields_ptr
        store_i64(ptr + 16, 0)  # fields_len
        store_i64(ptr + 24, 0)  # total_size

        self.structs_len = self.structs_len + 1
        ptr
    }

    F find_struct(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.structs_len { B }
            ptr := self.structs_ptr + i * StructTypeInfo.size()
            struct_name := load_i64(ptr)
            I struct_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0
    }

    # ========== Loop Stack ==========

    F push_loop(&self, break_ptr: i64, break_len: i64, continue_ptr: i64, continue_len: i64) -> i64 {
        I self.loop_stack_len >= self.loop_stack_cap {
            new_cap := self.loop_stack_cap * 2
            new_ptr := malloc(new_cap * LoopContext.size())
            memcpy(new_ptr, self.loop_stack_ptr, self.loop_stack_len * LoopContext.size())
            free(self.loop_stack_ptr)
            self.loop_stack_ptr = new_ptr
            self.loop_stack_cap = new_cap
            0
        } E { 0 }

        ptr := self.loop_stack_ptr + self.loop_stack_len * LoopContext.size()
        store_i64(ptr, break_ptr)
        store_i64(ptr + 8, break_len)
        store_i64(ptr + 16, continue_ptr)
        store_i64(ptr + 24, continue_len)

        self.loop_stack_len = self.loop_stack_len + 1
        1
    }

    F pop_loop(&self) -> i64 {
        I self.loop_stack_len > 0 {
            self.loop_stack_len = self.loop_stack_len - 1
            1
        } E { 0 }
    }

    F current_loop(&self) -> i64 {
        I self.loop_stack_len == 0 { 0 }
        E { self.loop_stack_ptr + (self.loop_stack_len - 1) * LoopContext.size() }
    }

    # ========== Monomorphization Support ==========

    # Save a generic function's AST pointer for later specialization
    F save_generic_fn(&self, fn_ptr: i64) -> i64 {
        I self.generic_fns_len >= self.generic_fns_cap {
            new_cap := self.generic_fns_cap * 2
            new_ptr := malloc(new_cap * 8)
            memcpy(new_ptr, self.generic_fns_ptr, self.generic_fns_len * 8)
            free(self.generic_fns_ptr)
            self.generic_fns_ptr = new_ptr
            self.generic_fns_cap = new_cap
            0
        } E { 0 }

        store_i64(self.generic_fns_ptr + self.generic_fns_len * 8, fn_ptr)
        self.generic_fns_len = self.generic_fns_len + 1
        1
    }

    # Find a saved generic function by name_idx
    F find_generic_fn(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.generic_fns_len { B }
            fn_ptr := load_i64(self.generic_fns_ptr + i * 8)
            fn_name := load_i64(fn_ptr)
            I fn_name == name_idx {
                R fn_ptr
            } E { 0 }
            i = i + 1
        }
        0
    }

    # Add a monomorphization entry
    # Each entry: fn_name_idx(8) + type_args_ptr(8) + type_args_len(8) = 24 bytes
    F add_mono_entry(&self, fn_name_idx: i64, type_args_ptr: i64, type_args_len: i64) -> i64 {
        # Check for duplicate
        i: mut i64 = 0
        L { I i >= self.mono_entries_len { B }
            entry_ptr := self.mono_entries_ptr + i * 24
            entry_fn := load_i64(entry_ptr)
            entry_len := load_i64(entry_ptr + 16)

            I entry_fn == fn_name_idx && entry_len == type_args_len {
                entry_args := load_i64(entry_ptr + 8)
                same: mut i64 = 1
                j: mut i64 = 0
                L { I j >= type_args_len { B }
                    I load_i64(entry_args + j * 8) != load_i64(type_args_ptr + j * 8) {
                        same = 0
                        B
                    } E { 0 }
                    j = j + 1
                }
                I same == 1 { R 1 }  # Already exists
                E { 0 }
            } E { 0 }
            i = i + 1
        }

        # Grow if needed
        I self.mono_entries_len >= self.mono_entries_cap {
            new_cap := self.mono_entries_cap * 2
            new_ptr := malloc(new_cap * 24)
            memcpy(new_ptr, self.mono_entries_ptr, self.mono_entries_len * 24)
            free(self.mono_entries_ptr)
            self.mono_entries_ptr = new_ptr
            self.mono_entries_cap = new_cap
            0
        } E { 0 }

        entry_ptr := self.mono_entries_ptr + self.mono_entries_len * 24
        store_i64(entry_ptr, fn_name_idx)
        store_i64(entry_ptr + 8, type_args_ptr)
        store_i64(entry_ptr + 16, type_args_len)
        self.mono_entries_len = self.mono_entries_len + 1
        1
    }

    # Import monomorphization entries from type checker
    # tc_mono_ptr: pointer to type checker's mono_entries array
    # tc_mono_len: number of entries
    F import_mono_entries(&self, tc_mono_ptr: i64, tc_mono_len: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= tc_mono_len { B }
            entry_ptr := tc_mono_ptr + i * 24
            fn_name := load_i64(entry_ptr)
            type_args := load_i64(entry_ptr + 8)
            type_args_len := load_i64(entry_ptr + 16)

            # Build concrete type kind array from ResolvedType pointers
            concrete_kinds := malloc(type_args_len * 8)
            j: mut i64 = 0
            L { I j >= type_args_len { B }
                type_ptr := load_i64(type_args + j * 8)
                type_kind := load_i64(type_ptr)  # ResolvedType.kind
                llvm_kind := @.resolved_type_to_llvm(type_kind)
                store_i64(concrete_kinds + j * 8, llvm_kind)
                j = j + 1
            }

            @.add_mono_entry(fn_name, concrete_kinds, type_args_len)
            i = i + 1
        }
        1
    }

    # Import struct monomorphization entries from type checker
    F import_struct_mono_entries(&self, tc_mono_ptr: i64, tc_mono_len: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= tc_mono_len { B }
            entry_ptr := tc_mono_ptr + i * 24
            struct_name := load_i64(entry_ptr)
            type_args := load_i64(entry_ptr + 8)
            type_args_len := load_i64(entry_ptr + 16)

            # Build concrete type kind array from ResolvedType pointers
            concrete_kinds := malloc(type_args_len * 8)
            j: mut i64 = 0
            L { I j >= type_args_len { B }
                type_ptr := load_i64(type_args + j * 8)
                type_kind := load_i64(type_ptr)  # ResolvedType.kind
                llvm_kind := @.resolved_type_to_llvm(type_kind)
                store_i64(concrete_kinds + j * 8, llvm_kind)
                j = j + 1
            }

            @.add_struct_mono_entry(struct_name, concrete_kinds, type_args_len)
            i = i + 1
        }
        1
    }

    # Set generic binding for monomorphization
    F set_mono_binding(&self, name_idx: i64, llvm_type_kind: i64) -> i64 {
        I self.mono_bind_len >= self.mono_bind_cap {
            new_cap := self.mono_bind_cap * 2
            new_keys := malloc(new_cap * 8)
            new_vals := malloc(new_cap * 8)
            memcpy(new_keys, self.mono_bind_keys_ptr, self.mono_bind_len * 8)
            memcpy(new_vals, self.mono_bind_values_ptr, self.mono_bind_len * 8)
            free(self.mono_bind_keys_ptr)
            free(self.mono_bind_values_ptr)
            self.mono_bind_keys_ptr = new_keys
            self.mono_bind_values_ptr = new_vals
            self.mono_bind_cap = new_cap
            0
        } E { 0 }

        store_i64(self.mono_bind_keys_ptr + self.mono_bind_len * 8, name_idx)
        store_i64(self.mono_bind_values_ptr + self.mono_bind_len * 8, llvm_type_kind)
        self.mono_bind_len = self.mono_bind_len + 1
        1
    }

    # Get generic binding (returns LLVM type kind, or -1 if not found)
    F get_mono_binding(&self, name_idx: i64) -> i64 {
        i: mut i64 = self.mono_bind_len
        L { I i == 0 { B }
            i = i - 1
            key := load_i64(self.mono_bind_keys_ptr + i * 8)
            I key == name_idx {
                R load_i64(self.mono_bind_values_ptr + i * 8)
            } E { 0 }
        }
        0 - 1  # Not found
    }

    # Clear all generic bindings
    F clear_mono_bindings(&self) -> i64 {
        self.mono_bind_len = 0
        1
    }

    # ========== Generic Struct Monomorphization ==========

    # Save a generic struct's AST pointer for later specialization
    F save_generic_struct(&self, struct_ptr: i64) -> i64 {
        I self.generic_structs_len >= self.generic_structs_cap {
            new_cap := self.generic_structs_cap * 2
            new_ptr := malloc(new_cap * 8)
            memcpy(new_ptr, self.generic_structs_ptr, self.generic_structs_len * 8)
            free(self.generic_structs_ptr)
            self.generic_structs_ptr = new_ptr
            self.generic_structs_cap = new_cap
            0
        } E { 0 }

        store_i64(self.generic_structs_ptr + self.generic_structs_len * 8, struct_ptr)
        self.generic_structs_len = self.generic_structs_len + 1
        1
    }

    # Find a saved generic struct by name_idx
    F find_generic_struct(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.generic_structs_len { B }
            struct_ptr := load_i64(self.generic_structs_ptr + i * 8)
            struct_name := load_i64(struct_ptr)  # StructDef.name_idx at offset 0
            I struct_name == name_idx {
                R struct_ptr
            } E { 0 }
            i = i + 1
        }
        0
    }

    # Add a struct monomorphization entry
    F add_struct_mono_entry(&self, struct_name_idx: i64, type_kinds_ptr: i64, type_kinds_len: i64) -> i64 {
        # Check for duplicate
        i: mut i64 = 0
        L { I i >= self.struct_mono_len { B }
            entry_ptr := self.struct_mono_ptr + i * 24
            entry_name := load_i64(entry_ptr)
            entry_len := load_i64(entry_ptr + 16)

            I entry_name == struct_name_idx && entry_len == type_kinds_len {
                entry_args := load_i64(entry_ptr + 8)
                same: mut i64 = 1
                j: mut i64 = 0
                L { I j >= type_kinds_len { B }
                    I load_i64(entry_args + j * 8) != load_i64(type_kinds_ptr + j * 8) {
                        same = 0
                        B
                    } E { 0 }
                    j = j + 1
                }
                I same == 1 { R 1 }  # Already exists
                E { 0 }
            } E { 0 }
            i = i + 1
        }

        # Grow if needed
        I self.struct_mono_len >= self.struct_mono_cap {
            new_cap := self.struct_mono_cap * 2
            new_ptr := malloc(new_cap * 24)
            memcpy(new_ptr, self.struct_mono_ptr, self.struct_mono_len * 24)
            free(self.struct_mono_ptr)
            self.struct_mono_ptr = new_ptr
            self.struct_mono_cap = new_cap
            0
        } E { 0 }

        # Copy type args
        args_copy := malloc(type_kinds_len * 8)
        memcpy(args_copy, type_kinds_ptr, type_kinds_len * 8)

        entry_ptr := self.struct_mono_ptr + self.struct_mono_len * 24
        store_i64(entry_ptr, struct_name_idx)
        store_i64(entry_ptr + 8, args_copy)
        store_i64(entry_ptr + 16, type_kinds_len)
        self.struct_mono_len = self.struct_mono_len + 1
        1
    }

    # Generate all monomorphized struct type definitions
    F generate_mono_struct_types(&self) -> i64 {
        I self.struct_mono_len == 0 { R 1 }

        @.emit_cstr("\n; ========== Monomorphized Struct Types ==========\n")

        i: mut i64 = 0
        L { I i >= self.struct_mono_len { B }
            entry_ptr := self.struct_mono_ptr + i * 24
            struct_name_idx := load_i64(entry_ptr)
            type_kinds_ptr := load_i64(entry_ptr + 8)
            type_kinds_len := load_i64(entry_ptr + 16)

            # Find the generic struct AST
            struct_ptr := @.find_generic_struct(struct_name_idx)
            I struct_ptr != 0 {
                @.generate_mono_struct_type(struct_ptr, type_kinds_ptr, type_kinds_len)
                0
            } E { 0 }

            i = i + 1
        }
        1
    }

    # Generate a single monomorphized struct type definition
    F generate_mono_struct_type(&self, struct_ptr: i64, type_kinds_ptr: i64, type_kinds_len: i64) -> i64 {
        name_idx := load_i64(struct_ptr)
        # StructDef: name_idx(0), generics_ptr(8), generics_len(16), fields_ptr(24), fields_len(32)
        generics_ptr := load_i64(struct_ptr + 8)
        generics_len := load_i64(struct_ptr + 16)
        fields_ptr := load_i64(struct_ptr + 24)
        fields_len := load_i64(struct_ptr + 32)

        # Set up generic bindings
        @.clear_mono_bindings()
        bind_count := I generics_len < type_kinds_len { generics_len } E { type_kinds_len }
        j: mut i64 = 0
        L { I j >= bind_count { B }
            # GenericParam.name_idx is at offset 0, GenericParam.size() = 40
            gen_name := load_i64(generics_ptr + j * 40)
            concrete_kind := load_i64(type_kinds_ptr + j * 8)
            @.set_mono_binding(gen_name, concrete_kind)
            j = j + 1
        }

        # Build monomorphized struct name
        mono_name_ptr := @.build_mono_name(name_idx, type_kinds_ptr, type_kinds_len)
        mono_name_len := load_i64(self.temp_buf + 8)

        # Emit: %StructName_mono_T1_T2 = type { i64, i64, ... }
        @.emit_cstr("%")
        @.emit_ptr(mono_name_ptr, mono_name_len)
        @.emit_cstr(" = type { ")

        # Emit field types (all fields are i64 in our simplified model, but resolve generics)
        i: mut i64 = 0
        L { I i >= fields_len { B }
            I i > 0 { @.emit_cstr(", ") } E { 0 }

            # FieldDef: name_idx(0), type_ptr(8), ... - FieldDef.size() = 40
            field_ptr := fields_ptr + i * 40
            field_type_ptr := load_i64(field_ptr + 8)

            field_llvm := I field_type_ptr == 0 {
                LLVM_I64()
            } E {
                @.resolve_mono_type(field_type_ptr)
            }
            @.type_to_llvm_str(field_llvm)

            i = i + 1
        }

        @.emit_cstr(" }\n")

        # Register the specialized struct in struct table
        @.add_struct(name_idx)

        # Clean up bindings
        @.clear_mono_bindings()
        1
    }

    # ========== VTable / Trait Dispatch ==========

    # Register a trait definition (called during first pass)
    F register_trait_def(&self, trait_name_idx: i64, methods_ptr: i64, methods_len: i64) -> i64 {
        I self.trait_defs_len >= self.trait_defs_cap {
            new_cap := self.trait_defs_cap * 2
            new_ptr := malloc(new_cap * 24)
            memcpy(new_ptr, self.trait_defs_ptr, self.trait_defs_len * 24)
            free(self.trait_defs_ptr)
            self.trait_defs_ptr = new_ptr
            self.trait_defs_cap = new_cap
            0
        } E { 0 }

        ptr := self.trait_defs_ptr + self.trait_defs_len * 24
        store_i64(ptr, trait_name_idx)
        store_i64(ptr + 8, methods_ptr)
        store_i64(ptr + 16, methods_len)
        self.trait_defs_len = self.trait_defs_len + 1
        1
    }

    # Find a trait definition by name_idx
    F find_trait_def(&self, trait_name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.trait_defs_len { B }
            ptr := self.trait_defs_ptr + i * 24
            name := load_i64(ptr)
            I name == trait_name_idx { R ptr } E { 0 }
            i = i + 1
        }
        0
    }

    # Register a vtable for a (type, trait) pair
    # impl_methods_ptr: array of method name_idx in trait declaration order
    F add_vtable(&self, impl_type_idx: i64, trait_name_idx: i64,
                 impl_methods_ptr: i64, impl_methods_len: i64) -> i64 {
        I self.vtables_len >= self.vtables_cap {
            new_cap := self.vtables_cap * 2
            new_ptr := malloc(new_cap * VtableEntry.size())
            memcpy(new_ptr, self.vtables_ptr, self.vtables_len * VtableEntry.size())
            free(self.vtables_ptr)
            self.vtables_ptr = new_ptr
            self.vtables_cap = new_cap
            0
        } E { 0 }

        # Build vtable name: __vtable_TypeName_TraitName
        store_i64(self.temp_buf + 8, 0)  # Clear temp buffer
        tb_data := load_i64(self.temp_buf)
        tb_cap := load_i64(self.temp_buf + 16)

        type_ptr := @.get_string_ptr(impl_type_idx)
        type_len := @.get_string_len(impl_type_idx)
        trait_ptr := @.get_string_ptr(trait_name_idx)
        trait_len := @.get_string_len(trait_name_idx)
        needed := 10 + type_len + trait_len  # __vtable_ + TypeName + _ + TraitName
        I needed > tb_cap {
            new_data := malloc(needed * 2)
            free(tb_data)
            store_i64(self.temp_buf, new_data)
            store_i64(self.temp_buf + 16, needed * 2)
            tb_data = new_data
            0
        } E { 0 }

        # "__vtable_"
        memcpy_str(tb_data, "__vtable_", 9)
        pos: mut i64 = 9
        memcpy(tb_data + pos, type_ptr, type_len)
        pos = pos + type_len
        store_byte(tb_data + pos, 95)  # _
        pos = pos + 1
        memcpy(tb_data + pos, trait_ptr, trait_len)
        pos = pos + trait_len

        # Allocate permanent copy of vtable name
        vt_name := malloc(pos)
        memcpy(vt_name, tb_data, pos)

        ptr := self.vtables_ptr + self.vtables_len * VtableEntry.size()
        store_i64(ptr, impl_type_idx)
        store_i64(ptr + 8, trait_name_idx)
        store_i64(ptr + 16, impl_methods_ptr)
        store_i64(ptr + 24, impl_methods_len)
        store_i64(ptr + 32, vt_name)
        store_i64(ptr + 40, pos)

        self.vtables_len = self.vtables_len + 1
        1
    }

    # Find vtable for a (type, trait) pair
    F find_vtable(&self, impl_type_idx: i64, trait_name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.vtables_len { B }
            ptr := self.vtables_ptr + i * VtableEntry.size()
            vt_type := load_i64(ptr)
            vt_trait := load_i64(ptr + 8)
            I vt_type == impl_type_idx && vt_trait == trait_name_idx {
                R ptr
            } E { 0 }
            i = i + 1
        }
        0
    }

    # Emit all vtable globals as LLVM IR constants
    F emit_vtable_globals(&self) -> i64 {
        I self.vtables_len == 0 { R 1 }

        @.emit_cstr("\n; ========== VTable Globals ==========\n")

        i: mut i64 = 0
        L { I i >= self.vtables_len { B }
            ptr := self.vtables_ptr + i * VtableEntry.size()
            impl_type := load_i64(ptr)
            trait_name := load_i64(ptr + 8)
            methods_ptr := load_i64(ptr + 16)
            methods_len := load_i64(ptr + 24)
            vt_name_ptr := load_i64(ptr + 32)
            vt_name_len := load_i64(ptr + 40)

            # Emit: @__vtable_Type_Trait = constant [N x i64] [
            #   i64 ptrtoint (i64 (i64, ...)* @method1 to i64),
            #   i64 ptrtoint (i64 (i64, ...)* @method2 to i64), ...]
            @.emit_cstr("@")
            @.emit_ptr(vt_name_ptr, vt_name_len)
            @.emit_cstr(" = private constant [")
            @.emit_i64(methods_len)
            @.emit_cstr(" x i64] [\n")

            j: mut i64 = 0
            L { I j >= methods_len { B }
                I j > 0 { @.emit_cstr(",\n") } E { 0 }

                method_name_idx := load_i64(methods_ptr + j * 8)
                @.emit_cstr("  i64 ptrtoint (i64 (i64)* @")
                @.emit_string_idx(method_name_idx)
                @.emit_cstr(" to i64)")

                j = j + 1
            }

            @.emit_cstr("\n]\n\n")

            i = i + 1
        }
        1
    }

    # Generate dynamic dispatch call through vtable
    # data_reg: register holding the data pointer (receiver)
    # vtable_reg: register holding the vtable pointer
    # method_index: index of method in vtable
    # args_ptr/args_len: additional argument registers
    F generate_dyn_call(&self, data_reg: i64, vtable_reg: i64, method_index: i64,
                        args_ptr: i64, args_len: i64) -> i64 {
        # Load function pointer from vtable at method_index
        # vtable is an array of i64 function pointers
        offset_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(offset_reg)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(vtable_reg)
        @.emit_cstr(", ")
        @.emit_i64(method_index * 8)
        @.emit_cstr("\n")

        fn_ptr_val := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(fn_ptr_val)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(offset_reg)
        @.emit_cstr(")\n")

        # Cast i64 to function pointer
        fn_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(fn_ptr)
        @.emit_cstr(" = inttoptr i64 ")
        @.emit_reg(fn_ptr_val)
        @.emit_cstr(" to i64 (i64")
        # Additional parameter types
        ai: mut i64 = 0
        L { I ai >= args_len { B }
            @.emit_cstr(", i64")
            ai = ai + 1
        }
        @.emit_cstr(")*\n")

        # Emit indirect call
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 ")
        @.emit_reg(fn_ptr)
        @.emit_cstr("(i64 ")
        @.emit_reg(data_reg)

        ai = 0
        L { I ai >= args_len { B }
            @.emit_cstr(", i64 ")
            arg_reg := load_i64(args_ptr + ai * 8)
            @.emit_reg(arg_reg)
            ai = ai + 1
        }

        @.emit_cstr(")\n")
        result
    }

    # Build monomorphized function name: "fn_name_T1_T2"
    # Returns (name_ptr, name_len) via temp buffer
    F build_mono_name(&self, fn_name_idx: i64, type_kinds_ptr: i64, type_kinds_len: i64) -> i64 {
        # Clear temp buffer
        store_i64(self.temp_buf + 8, 0)  # len = 0

        # Get base function name
        base_ptr := @.get_string_ptr(fn_name_idx)
        base_len := @.get_string_len(fn_name_idx)

        # Build: base_name + "_mono_" + kind1 + "_" + kind2 + ...
        tb_data := load_i64(self.temp_buf)
        tb_cap := load_i64(self.temp_buf + 16)

        # Ensure capacity
        needed := base_len + 6 + type_kinds_len * 6  # Generous estimate
        I needed > tb_cap {
            new_cap := needed * 2
            new_data := malloc(new_cap)
            free(tb_data)
            store_i64(self.temp_buf, new_data)
            store_i64(self.temp_buf + 16, new_cap)
            tb_data = new_data
            0
        } E { 0 }

        # Copy base name
        memcpy(tb_data, base_ptr, base_len)
        pos: mut i64 = base_len

        # Add "_mono_"
        store_byte(tb_data + pos, 95)  # _
        pos = pos + 1
        store_byte(tb_data + pos, 109) # m
        pos = pos + 1
        store_byte(tb_data + pos, 111) # o
        pos = pos + 1
        store_byte(tb_data + pos, 110) # n
        pos = pos + 1
        store_byte(tb_data + pos, 111) # o
        pos = pos + 1
        store_byte(tb_data + pos, 95)  # _
        pos = pos + 1

        # Add each type kind as number separated by _
        i: mut i64 = 0
        L { I i >= type_kinds_len { B }
            I i > 0 {
                store_byte(tb_data + pos, 95)  # _
                pos = pos + 1
                0
            } E { 0 }

            kind := load_i64(type_kinds_ptr + i * 8)
            # Write kind as digits
            I kind >= 10 {
                store_byte(tb_data + pos, 48 + kind / 10)
                pos = pos + 1
                store_byte(tb_data + pos, 48 + kind % 10)
                pos = pos + 1
                0
            } E {
                store_byte(tb_data + pos, 48 + kind)
                pos = pos + 1
                0
            }

            i = i + 1
        }

        store_i64(self.temp_buf + 8, pos)  # Update length
        tb_data  # Return pointer (length is at self.temp_buf + 8)
    }

    # Generate all monomorphized function specializations
    F generate_mono_functions(&self) -> i64 {
        I self.mono_entries_len == 0 { R 1 }

        @.emit_cstr("\n; ========== Monomorphized Functions ==========\n")

        i: mut i64 = 0
        L { I i >= self.mono_entries_len { B }
            entry_ptr := self.mono_entries_ptr + i * 24
            fn_name_idx := load_i64(entry_ptr)
            type_kinds_ptr := load_i64(entry_ptr + 8)
            type_kinds_len := load_i64(entry_ptr + 16)

            # Find the generic function AST
            fn_ptr := @.find_generic_fn(fn_name_idx)
            I fn_ptr != 0 {
                @.generate_mono_function(fn_ptr, type_kinds_ptr, type_kinds_len)
                0
            } E { 0 }

            i = i + 1
        }
        1
    }

    # Generate a single monomorphized function
    F generate_mono_function(&self, fn_ptr: i64, type_kinds_ptr: i64, type_kinds_len: i64) -> i64 {
        name_idx := load_i64(fn_ptr)
        generics_ptr := load_i64(fn_ptr + 8)
        generics_len := load_i64(fn_ptr + 16)
        params_ptr := load_i64(fn_ptr + 24)
        params_len := load_i64(fn_ptr + 32)
        ret_type_ptr := load_i64(fn_ptr + 40)
        body_kind := load_i64(fn_ptr + 48)
        body_expr_ptr := load_i64(fn_ptr + 56)
        body_stmts_ptr := load_i64(fn_ptr + 64)
        body_stmts_len := load_i64(fn_ptr + 72)

        # Set up generic bindings
        @.clear_mono_bindings()
        bind_count := I generics_len < type_kinds_len { generics_len } E { type_kinds_len }
        j: mut i64 = 0
        L { I j >= bind_count { B }
            # GenericParam.name_idx is at offset 0, GenericParam.size() = 40
            gen_name := load_i64(generics_ptr + j * 40)
            concrete_kind := load_i64(type_kinds_ptr + j * 8)
            @.set_mono_binding(gen_name, concrete_kind)
            j = j + 1
        }

        # Reset state for this function
        @.clear_locals()
        self.reg_counter = 0
        self.label_counter = 0
        self.current_fn_name_idx = name_idx

        # Determine return type (resolve generics)
        ret_llvm := I ret_type_ptr == 0 {
            self.current_fn_ret_type = LLVM_VOID()
            LLVM_VOID()
        } E {
            ret_kind := load_i64(ret_type_ptr)
            llvm_kind := @.resolve_mono_type(ret_type_ptr)
            self.current_fn_ret_type = llvm_kind
            llvm_kind
        }

        # Build monomorphized name
        mono_name_ptr := @.build_mono_name(name_idx, type_kinds_ptr, type_kinds_len)
        mono_name_len := load_i64(self.temp_buf + 8)

        # Emit function signature
        @.emit_cstr("define ")
        @.type_to_llvm_str(ret_llvm)
        @.emit_cstr(" @")
        @.emit_ptr(mono_name_ptr, mono_name_len)
        @.emit_cstr("(")

        # Register the mono function in function table
        @.add_function(name_idx, ret_llvm, 0)

        # Emit parameters (resolve generic types)
        k: mut i64 = 0
        L { I k >= params_len { B }
            I k > 0 { @.emit_cstr(", ") } E { 0 }

            param_ptr := params_ptr + k * 40  # Param.size() = 40
            param_name_idx := load_i64(param_ptr)
            param_type_ptr := load_i64(param_ptr + 8)

            param_llvm := I param_type_ptr == 0 {
                LLVM_I64()
            } E {
                @.resolve_mono_type(param_type_ptr)
            }

            @.type_to_llvm_str(param_llvm)
            @.emit_cstr(" %")
            @.emit_string_idx(param_name_idx)

            # Register parameter as local
            param_name_ptr := @.get_string_ptr(param_name_idx)
            param_name_len := @.get_string_len(param_name_idx)
            @.add_local(param_name_idx, param_name_ptr, param_name_len, param_llvm, 1)

            k = k + 1
        }

        @.emit_cstr(") {\n")
        @.emit_cstr("entry:\n")

        # Generate body (same as regular function)
        I body_kind == 0 {
            result_reg := @.generate_expr(body_expr_ptr)
            I ret_llvm == LLVM_VOID() {
                @.emit_cstr("  ret void\n")
            } E {
                @.emit_cstr("  ret ")
                @.type_to_llvm_str(ret_llvm)
                @.emit_cstr(" ")
                @.emit_reg(result_reg)
                @.emit_cstr("\n")
            }
        } E {
            @.generate_stmts(body_stmts_ptr, body_stmts_len)
            # Execute deferred expressions at function end
            @.emit_defer_cleanup()
            I ret_llvm == LLVM_VOID() {
                @.emit_cstr("  ret void\n")
            } E {
                @.emit_cstr("  ret ")
                @.type_to_llvm_str(ret_llvm)
                @.emit_cstr(" 0 ; implicit return\n")
            }
        }

        @.emit_cstr("}\n\n")

        # Clear defer stack for next function
        self.defer_stack_len = 0

        # Clean up bindings
        @.clear_mono_bindings()
        1
    }

    # Resolve a type pointer considering current mono bindings
    # If the type is a generic parameter, look up the concrete type
    F resolve_mono_type(&self, type_ptr: i64) -> i64 {
        I type_ptr == 0 { R LLVM_I64() }

        type_kind := load_i64(type_ptr)

        # TY_GENERIC = 26 (from type_checker.vais)
        I type_kind == 26 {
            gen_name := load_i64(type_ptr + 8)  # ResolvedType.field0 = name_idx
            bound := @.get_mono_binding(gen_name)
            I bound != 0 - 1 {
                bound  # Return the concrete LLVM type kind
            } E {
                LLVM_I64()  # Fallback
            }
        }
        # TY_NAMED = 25 - check if it has generic args
        E I type_kind == 25 {
            LLVM_I64()  # Named types default to pointer-sized
        }
        E {
            @.resolved_type_to_llvm(type_kind)
        }
    }

    # ========== String Constants ==========

    F add_string_constant(&self, value_ptr: i64, value_len: i64) -> i64 {
        # Returns the string constant name index
        idx := self.strings_len

        I self.strings_len >= self.strings_cap {
            new_cap := self.strings_cap * 2
            new_ptr := malloc(new_cap * 32)
            memcpy(new_ptr, self.strings_ptr, self.strings_len * 32)
            free(self.strings_ptr)
            self.strings_ptr = new_ptr
            self.strings_cap = new_cap
            0
        } E { 0 }

        # Store: name will be ".str.N", value is the string content
        ptr := self.strings_ptr + self.strings_len * 32
        store_i64(ptr, idx)       # index as name
        store_i64(ptr + 8, value_ptr)
        store_i64(ptr + 16, value_len)

        self.strings_len = self.strings_len + 1
        idx
    }

    # ========== Code Generation Entry Point ==========

    F generate_module(&self, module_ptr: i64) -> i64 {
        # Get module data
        items_ptr := load_i64(module_ptr)
        items_len := load_i64(module_ptr + 8)

        # Set string pool
        sp_data := load_i64(module_ptr + 24)
        sp_offsets := load_i64(module_ptr + 32)
        sp_count := load_i64(module_ptr + 56)
        @.set_string_pool(sp_data, sp_offsets, sp_count)

        # Emit module header
        @.emit_cstr("; ModuleID = 'vais_module'\n")
        @.emit_cstr("source_filename = \"<vais>\"\n\n")

        # First pass: register all declarations
        i: mut i64 = 0
        L { I i >= items_len { B }
            item_ptr := items_ptr + i * 32
            kind := load_i64(item_ptr)
            data_ptr := load_i64(item_ptr + 8)

            # ITEM_FUNCTION = 1
            I kind == 1 {
                @.register_function_decl(data_ptr)
            }
            # ITEM_STRUCT = 2
            E I kind == 2 {
                @.register_struct_decl(data_ptr)
            }
            # ITEM_TRAIT = 6
            E I kind == 6 {
                @.register_trait_decl(data_ptr)
            }
            E { 0 }

            i = i + 1
        }

        # Emit struct type definitions
        j: mut i64 = 0
        L { I j >= self.structs_len { B }
            struct_ptr := self.structs_ptr + j * StructTypeInfo.size()
            @.emit_struct_type(struct_ptr)
            j = j + 1
        }

        # Emit monomorphized struct type definitions
        @.generate_mono_struct_types()

        # Emit extern function declarations
        @.emit_extern_declarations()

        # Second pass: generate function bodies
        i = 0
        L { I i >= items_len { B }
            item_ptr := items_ptr + i * 32
            kind := load_i64(item_ptr)
            data_ptr := load_i64(item_ptr + 8)

            # ITEM_FUNCTION = 1
            I kind == 1 {
                @.generate_function(data_ptr)
            }
            # ITEM_IMPL = 7
            E I kind == 7 {
                @.generate_impl(data_ptr)
            }
            E { 0 }

            i = i + 1
        }

        # Emit monomorphized function specializations
        @.generate_mono_functions()

        # Emit vtable globals
        @.emit_vtable_globals()

        # Emit lambda functions
        @.emit_lambda_functions()

        # Emit string constants
        @.emit_string_constants()

        # Emit helper functions
        @.emit_helper_functions()

        # Apply Dead Code Elimination optimization
        @.optimize_dce()

        # Apply basic function inlining
        @.optimize_inline()

        1
    }

    F register_function_decl(&self, fn_ptr: i64) -> i64 {
        name_idx := load_i64(fn_ptr)
        ret_type_ptr := load_i64(fn_ptr + 40)

        ret_llvm := I ret_type_ptr == 0 {
            LLVM_VOID()
        } E {
            ret_kind := load_i64(ret_type_ptr)
            @.resolved_type_to_llvm(ret_kind)
        }

        @.add_function(name_idx, ret_llvm, 0)
    }

    F register_struct_decl(&self, struct_ptr: i64) -> i64 {
        name_idx := load_i64(struct_ptr)
        # StructDef: name_idx(0), generics_ptr(8), generics_len(16)
        generics_len := load_i64(struct_ptr + 16)

        # Save generic structs for monomorphization, register non-generic normally
        I generics_len > 0 {
            @.save_generic_struct(struct_ptr)
        } E {
            @.add_struct(name_idx)
        }
    }

    F register_trait_decl(&self, trait_ptr: i64) -> i64 {
        # TraitDef: name_idx(0), generics_ptr(8), generics_len(16),
        #           super_traits_ptr(24), super_traits_len(32),
        #           methods_ptr(40), methods_len(48)
        name_idx := load_i64(trait_ptr)
        methods_ptr := load_i64(trait_ptr + 40)
        methods_len := load_i64(trait_ptr + 48)

        # Build method name_idx array from FunctionDef AST nodes
        I methods_len > 0 {
            method_names := malloc(methods_len * 8)
            mi: mut i64 = 0
            L { I mi >= methods_len { B }
                fn_ptr := load_i64(methods_ptr + mi * 8)
                fn_name_idx := load_i64(fn_ptr)  # FunctionDef.name_idx at offset 0
                store_i64(method_names + mi * 8, fn_name_idx)
                mi = mi + 1
            }
            @.register_trait_def(name_idx, method_names, methods_len)
        } E {
            @.register_trait_def(name_idx, 0, 0)
        }
    }

    F emit_struct_type(&self, struct_info_ptr: i64) -> i64 {
        name_idx := load_i64(struct_info_ptr)
        fields_ptr := load_i64(struct_info_ptr + 8)
        fields_len := load_i64(struct_info_ptr + 16)

        @.emit_cstr("%")
        @.emit_string_idx(name_idx)
        @.emit_cstr(" = type { ")

        i: mut i64 = 0
        L { I i >= fields_len { B }
            I i > 0 { @.emit_cstr(", ") } E { 0 }

            field_ptr := fields_ptr + i * StructFieldInfo.size()
            field_type := load_i64(field_ptr + 8)
            @.type_to_llvm_str(field_type)

            i = i + 1
        }

        @.emit_cstr(" }\n")
        1
    }

    F emit_extern_declarations(&self) -> i64 {
        # Emit built-in extern functions
        @.emit_cstr("\n; External declarations\n")
        @.emit_cstr("declare i8* @malloc(i64)\n")
        @.emit_cstr("declare void @free(i8*)\n")
        @.emit_cstr("declare i8* @memcpy(i8*, i8*, i64)\n")
        @.emit_cstr("declare i64 @strlen(i8*)\n")
        @.emit_cstr("declare i32 @puts(i8*)\n")
        @.emit_cstr("declare i64 @printf(i8*, ...)\n")
        @.emit_cstr("\n")
        1
    }

    F emit_string_constants(&self) -> i64 {
        I self.strings_len == 0 { R 1 }

        @.emit_cstr("\n; String constants\n")

        i: mut i64 = 0
        L { I i >= self.strings_len { B }
            ptr := self.strings_ptr + i * 32
            idx := load_i64(ptr)
            value_ptr := load_i64(ptr + 8)
            value_len := load_i64(ptr + 16)

            @.emit_cstr("@.str.")
            @.emit_i64(idx)
            @.emit_cstr(" = private unnamed_addr constant [")
            @.emit_i64(value_len + 1)
            @.emit_cstr(" x i8] c\"")

            # Emit string content with escaping
            j: mut i64 = 0
            L { I j >= value_len { B }
                c := load_byte(value_ptr + j)
                I c == 10 {
                    @.emit_cstr("\\0A")
                } E I c == 13 {
                    @.emit_cstr("\\0D")
                } E I c == 34 {
                    @.emit_cstr("\\22")
                } E I c == 92 {
                    @.emit_cstr("\\5C")
                } E I c == 0 {
                    @.emit_cstr("\\00")
                } E {
                    tb_data := load_i64(self.temp_buf)
                    store_byte(tb_data, c)
                    @.emit(tb_data, 1)
                }
                j = j + 1
            }

            @.emit_cstr("\\00\"\n")
            i = i + 1
        }
        1
    }

    F emit_helper_functions(&self) -> i64 {
        @.emit_cstr("\n; Helper functions for memory operations\n")

        # load_byte
        @.emit_cstr("define i64 @load_byte(i64 %ptr) {\n")
        @.emit_cstr("entry:\n")
        @.emit_cstr("  %0 = inttoptr i64 %ptr to i8*\n")
        @.emit_cstr("  %1 = load i8, i8* %0\n")
        @.emit_cstr("  %2 = zext i8 %1 to i64\n")
        @.emit_cstr("  ret i64 %2\n")
        @.emit_cstr("}\n\n")

        # store_byte
        @.emit_cstr("define void @store_byte(i64 %ptr, i64 %val) {\n")
        @.emit_cstr("entry:\n")
        @.emit_cstr("  %0 = inttoptr i64 %ptr to i8*\n")
        @.emit_cstr("  %1 = trunc i64 %val to i8\n")
        @.emit_cstr("  store i8 %1, i8* %0\n")
        @.emit_cstr("  ret void\n")
        @.emit_cstr("}\n\n")

        # load_i64
        @.emit_cstr("define i64 @load_i64(i64 %ptr) {\n")
        @.emit_cstr("entry:\n")
        @.emit_cstr("  %0 = inttoptr i64 %ptr to i64*\n")
        @.emit_cstr("  %1 = load i64, i64* %0\n")
        @.emit_cstr("  ret i64 %1\n")
        @.emit_cstr("}\n\n")

        # store_i64
        @.emit_cstr("define void @store_i64(i64 %ptr, i64 %val) {\n")
        @.emit_cstr("entry:\n")
        @.emit_cstr("  %0 = inttoptr i64 %ptr to i64*\n")
        @.emit_cstr("  store i64 %val, i64* %0\n")
        @.emit_cstr("  ret void\n")
        @.emit_cstr("}\n")

        1
    }

    # ========== Function Generation ==========

    F generate_function(&self, fn_ptr: i64) -> i64 {
        name_idx := load_i64(fn_ptr)
        generics_ptr := load_i64(fn_ptr + 8)
        generics_len := load_i64(fn_ptr + 16)
        params_ptr := load_i64(fn_ptr + 24)
        params_len := load_i64(fn_ptr + 32)
        ret_type_ptr := load_i64(fn_ptr + 40)
        body_kind := load_i64(fn_ptr + 48)
        body_expr_ptr := load_i64(fn_ptr + 56)
        body_stmts_ptr := load_i64(fn_ptr + 64)
        body_stmts_len := load_i64(fn_ptr + 72)

        # Clear defer stack for this function
        self.defer_stack_len = 0

        # Save generic functions for monomorphization, don't generate them directly
        I generics_len > 0 {
            @.save_generic_fn(fn_ptr)
            R 1
        }

        # Reset state
        @.clear_locals()
        self.reg_counter = 0
        self.label_counter = 0
        self.current_fn_name_idx = name_idx

        # Determine return type
        ret_llvm := I ret_type_ptr == 0 {
            self.current_fn_ret_type = LLVM_VOID()
            LLVM_VOID()
        } E {
            ret_kind := load_i64(ret_type_ptr)
            llvm_kind := @.resolved_type_to_llvm(ret_kind)
            self.current_fn_ret_type = llvm_kind
            llvm_kind
        }

        # Emit function signature
        @.emit_cstr("define ")
        @.type_to_llvm_str(ret_llvm)
        @.emit_cstr(" @")
        # If in impl block, prefix method name with TypeName_
        I self.current_impl_type_idx != 0 - 1 {
            @.emit_string_idx(self.current_impl_type_idx)
            @.emit_cstr("_")
            0
        } E { 0 }
        @.emit_string_idx(name_idx)
        @.emit_cstr("(")

        # Emit parameters
        i: mut i64 = 0
        L { I i >= params_len { B }
            I i > 0 { @.emit_cstr(", ") } E { 0 }

            param_ptr := params_ptr + i * 40  # Param.size() = 40
            param_name_idx := load_i64(param_ptr)
            param_type_ptr := load_i64(param_ptr + 8)

            param_llvm := I param_type_ptr == 0 {
                LLVM_I64()
            } E {
                type_kind := load_i64(param_type_ptr)
                @.resolved_type_to_llvm(type_kind)
            }

            @.type_to_llvm_str(param_llvm)
            @.emit_cstr(" %")
            @.emit_string_idx(param_name_idx)

            # Register parameter as local
            param_name_ptr := @.get_string_ptr(param_name_idx)
            param_name_len := @.get_string_len(param_name_idx)
            @.add_local(param_name_idx, param_name_ptr, param_name_len, param_llvm, 1)

            i = i + 1
        }

        @.emit_cstr(") {\n")
        @.emit_cstr("entry:\n")

        # Generate body
        I body_kind == 0 {
            # Expression body
            result_reg := @.generate_expr(body_expr_ptr)

            I ret_llvm == LLVM_VOID() {
                @.emit_cstr("  ret void\n")
            } E {
                @.emit_cstr("  ret ")
                @.type_to_llvm_str(ret_llvm)
                @.emit_cstr(" ")
                @.emit_reg(result_reg)
                @.emit_cstr("\n")
            }
        } E {
            # Block body
            @.generate_stmts(body_stmts_ptr, body_stmts_len)

            # Add implicit return if needed
            I ret_llvm == LLVM_VOID() {
                @.emit_cstr("  ret void\n")
            } E { 0 }
        }

        @.emit_cstr("}\n\n")
        1
    }

    F generate_impl(&self, impl_ptr: i64) -> i64 {
        # ImplDef: target_type_ptr(0), trait_name_idx(8), generics_ptr(16), generics_len(24),
        #          methods_ptr(32), methods_len(40)
        target_type_ptr := load_i64(impl_ptr)
        trait_name_idx := load_i64(impl_ptr + 8)
        methods_ptr := load_i64(impl_ptr + 32)
        methods_len := load_i64(impl_ptr + 40)

        # Set impl context for method name prefixing (TypeName_method)
        old_impl_type_idx := self.current_impl_type_idx
        I target_type_ptr != 0 {
            self.current_impl_type_idx = load_i64(target_type_ptr + 24)  # TypeNode.field0 = name_idx
            0
        } E {
            self.current_impl_type_idx = 0 - 1
            0
        }

        # Generate all methods
        i: mut i64 = 0
        L { I i >= methods_len { B }
            method_ptr := load_i64(methods_ptr + i * 8)
            @.generate_function(method_ptr)
            i = i + 1
        }

        # Restore impl context
        self.current_impl_type_idx = old_impl_type_idx

        # If this is a trait impl (trait_name_idx != -1), register vtable
        I trait_name_idx != 0 - 1 {
            # Get target type name_idx from TypeNode (kind at 0, name_idx at field0 = 24)
            impl_type_idx := I target_type_ptr != 0 {
                load_i64(target_type_ptr + 24)  # TypeNode.field0 = name_idx for NAMED type
            } E { 0 }

            I impl_type_idx != 0 {
                # Build method name_idx array for vtable (in declaration order)
                method_names := malloc(methods_len * 8)
                mi: mut i64 = 0
                L { I mi >= methods_len { B }
                    fn_ptr := load_i64(methods_ptr + mi * 8)
                    fn_name_idx := load_i64(fn_ptr)  # FunctionDef.name_idx at offset 0
                    store_i64(method_names + mi * 8, fn_name_idx)
                    mi = mi + 1
                }
                @.add_vtable(impl_type_idx, trait_name_idx, method_names, methods_len)
                0
            } E { 0 }
        } E { 0 }

        1
    }

    # ========== Statement Generation ==========

    F generate_stmts(&self, stmts_ptr: i64, stmts_len: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= stmts_len { B }
            stmt_ptr := load_i64(stmts_ptr + i * 8)
            @.generate_stmt(stmt_ptr)
            i = i + 1
        }
        1
    }

    F generate_stmt(&self, stmt_ptr: i64) -> i64 {
        kind := load_i64(stmt_ptr)

        # STMT_LET = 10
        I kind == 10 {
            @.generate_let_stmt(stmt_ptr)
        }
        # STMT_EXPR = 11
        E I kind == 11 {
            expr_ptr := load_i64(stmt_ptr + 24)
            @.generate_expr(expr_ptr)
            1
        }
        # STMT_RETURN = 12
        E I kind == 12 {
            @.generate_return_stmt(stmt_ptr)
        }
        # STMT_BREAK = 13
        E I kind == 13 {
            @.generate_break_stmt()
        }
        # STMT_CONTINUE = 14
        E I kind == 14 {
            @.generate_continue_stmt()
        }
        # STMT_DEFER = 15
        E I kind == 15 {
            @.push_defer(stmt_ptr)
        }
        E { 1 }
    }

    # Push a defer statement's expression pointer onto the defer stack
    F push_defer(&self, stmt_ptr: i64) -> i64 {
        expr_ptr := load_i64(stmt_ptr + 24)
        I self.defer_stack_len >= self.defer_stack_cap {
            new_cap := self.defer_stack_cap * 2
            new_ptr := malloc(new_cap * 8)
            memcpy(new_ptr, self.defer_stack_ptr, self.defer_stack_len * 8)
            free(self.defer_stack_ptr)
            self.defer_stack_ptr = new_ptr
            self.defer_stack_cap = new_cap
            0
        } E { 0 }
        store_i64(self.defer_stack_ptr + self.defer_stack_len * 8, expr_ptr)
        self.defer_stack_len = self.defer_stack_len + 1
        1
    }

    # Emit code for all deferred expressions in LIFO order
    F emit_defer_cleanup(&self) -> i64 {
        I self.defer_stack_len > 0 {
            i := mut self.defer_stack_len - 1
            done := mut 0
            L done == 0 {
                expr_ptr := load_i64(self.defer_stack_ptr + i * 8)
                @.generate_expr(expr_ptr)
                I i == 0 {
                    done = 1
                } E {
                    i = i - 1
                }
            }
            0
        } E { 0 }
    }

    F generate_let_stmt(&self, stmt_ptr: i64) -> i64 {
        name_idx := load_i64(stmt_ptr + 24)
        type_ptr := load_i64(stmt_ptr + 32)
        value_ptr := load_i64(stmt_ptr + 40)
        is_mut := load_i64(stmt_ptr + 48)

        # Determine type
        var_type := I type_ptr != 0 {
            type_kind := load_i64(type_ptr)
            @.resolved_type_to_llvm(type_kind)
        } E {
            LLVM_I64()  # Default
        }

        # Allocate stack space
        alloca_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(alloca_reg)
        @.emit_cstr(" = alloca ")
        @.type_to_llvm_str(var_type)
        @.emit_cstr("\n")

        # Store initial value if present
        I value_ptr != 0 {
            value_reg := @.generate_expr(value_ptr)
            @.emit_cstr("  store ")
            @.type_to_llvm_str(var_type)
            @.emit_cstr(" ")
            @.emit_reg(value_reg)
            @.emit_cstr(", ")
            @.type_to_llvm_str(var_type)
            @.emit_cstr("* ")
            @.emit_reg(alloca_reg)
            @.emit_cstr("\n")
            0
        } E { 0 }

        # Register local variable (store alloca register as name)
        name_ptr := @.get_string_ptr(name_idx)
        name_len := @.get_string_len(name_idx)

        # Store alloca reg number in local
        local_idx := @.add_local(name_idx, alloca_reg, 0, var_type, 0)
        # Mark as alloca
        local_ptr := self.locals_ptr + local_idx * LocalVar.size()
        store_i64(local_ptr + 40, 1)  # is_alloca = 1

        1
    }

    F generate_return_stmt(&self, stmt_ptr: i64) -> i64 {
        expr_ptr := load_i64(stmt_ptr + 24)

        # Execute deferred expressions before returning
        @.emit_defer_cleanup()

        I expr_ptr == 0 || self.current_fn_ret_type == LLVM_VOID() {
            @.emit_cstr("  ret void\n")
        } E {
            value_reg := @.generate_expr(expr_ptr)
            @.emit_cstr("  ret ")
            @.type_to_llvm_str(self.current_fn_ret_type)
            @.emit_cstr(" ")
            @.emit_reg(value_reg)
            @.emit_cstr("\n")
        }
        1
    }

    F generate_break_stmt(&self) -> i64 {
        loop_ctx := @.current_loop()
        I loop_ctx != 0 {
            break_label := load_i64(loop_ctx)
            @.emit_cstr("  br label %end")
            @.emit_i64(break_label)
            @.emit_cstr("\n")
            1
        } E { 0 }
    }

    F generate_continue_stmt(&self) -> i64 {
        loop_ctx := @.current_loop()
        I loop_ctx != 0 {
            continue_label := load_i64(loop_ctx + 16)
            @.emit_cstr("  br label %cond")
            @.emit_i64(continue_label)
            @.emit_cstr("\n")
            1
        } E { 0 }
    }

    # ========== Expression Generation ==========

    F generate_expr(&self, expr_ptr: i64) -> i64 {
        I expr_ptr == 0 { R 0 }

        kind := load_i64(expr_ptr)

        # EXPR_INT = 20
        I kind == 20 {
            value := load_i64(expr_ptr + 24)
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, ")
            @.emit_i64(value)
            @.emit_cstr("\n")
            result
        }
        # EXPR_FLOAT = 21
        E I kind == 21 {
            # For now, emit as i64 (float bits)
            value := load_i64(expr_ptr + 24)
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, ")
            @.emit_i64(value)
            @.emit_cstr("\n")
            result
        }
        # EXPR_BOOL = 22
        E I kind == 22 {
            value := load_i64(expr_ptr + 24)
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, ")
            I value != 0 { @.emit_cstr("1") } E { @.emit_cstr("0") }
            @.emit_cstr("\n")
            result
        }
        # EXPR_STRING = 23
        E I kind == 23 {
            str_idx := load_i64(expr_ptr + 24)
            str_ptr := @.get_string_ptr(str_idx)
            str_len := @.get_string_len(str_idx)

            # Add string constant
            const_idx := @.add_string_constant(str_ptr, str_len)

            # Get pointer to string constant
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = getelementptr [")
            @.emit_i64(str_len + 1)
            @.emit_cstr(" x i8], [")
            @.emit_i64(str_len + 1)
            @.emit_cstr(" x i8]* @.str.")
            @.emit_i64(const_idx)
            @.emit_cstr(", i64 0, i64 0\n")

            # Convert to i64
            result2 := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result2)
            @.emit_cstr(" = ptrtoint i8* ")
            @.emit_reg(result)
            @.emit_cstr(" to i64\n")

            result2
        }
        # EXPR_UNIT = 24
        E I kind == 24 {
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0 ; unit\n")
            result
        }
        # EXPR_IDENT = 25
        E I kind == 25 {
            name_idx := load_i64(expr_ptr + 24)
            @.generate_ident(name_idx)
        }
        # EXPR_SELF_CALL = 26
        E I kind == 26 {
            @.generate_self_call(expr_ptr)
        }
        # EXPR_BINARY = 27
        E I kind == 27 {
            # Try constant folding first
            left_ptr := load_i64(expr_ptr + 24)
            right_ptr := load_i64(expr_ptr + 32)
            left_kind := load_i64(left_ptr)
            right_kind := load_i64(right_ptr)

            I left_kind == 20 && right_kind == 20 {
                # Both operands are integer literals - constant fold
                left_val := load_i64(left_ptr + 24)
                right_val := load_i64(right_ptr + 24)
                op := load_i64(expr_ptr + 40)

                folded := I op == OP_ADD() { left_val + right_val }
                          E I op == OP_SUB() { left_val - right_val }
                          E I op == OP_MUL() { left_val * right_val }
                          E I op == OP_DIV() && right_val != 0 { left_val / right_val }
                          E I op == OP_MOD() && right_val != 0 { left_val % right_val }
                          E { 0 - 1 }  # sentinel: can't fold

                I folded != 0 - 1 {
                    result := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(result)
                    @.emit_cstr(" = add i64 0, ")
                    @.emit_i64(folded)
                    @.emit_cstr(" ; constant fold\n")
                    result
                } E {
                    @.generate_binary(expr_ptr)
                }
            } E {
                @.generate_binary(expr_ptr)
            }
        }
        # EXPR_UNARY = 28
        E I kind == 28 {
            # Try constant folding first
            inner_ptr := load_i64(expr_ptr + 24)
            inner_kind := load_i64(inner_ptr)

            I inner_kind == 20 {
                # Operand is integer literal - constant fold
                inner_val := load_i64(inner_ptr + 24)
                op := load_i64(expr_ptr + 32)

                folded := I op == UOP_NEG() { 0 - inner_val }
                          E I op == UOP_BITNOT() { 0 - 1 - inner_val }  # ~x = -1 - x
                          E { 0 - 1 }  # sentinel: can't fold

                I folded != 0 - 1 {
                    result := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(result)
                    @.emit_cstr(" = add i64 0, ")
                    @.emit_i64(folded)
                    @.emit_cstr(" ; constant fold\n")
                    result
                } E {
                    @.generate_unary(expr_ptr)
                }
            } E {
                @.generate_unary(expr_ptr)
            }
        }
        # EXPR_IF = 30
        E I kind == 30 {
            @.generate_if(expr_ptr)
        }
        # EXPR_LOOP = 31
        E I kind == 31 {
            @.generate_loop(expr_ptr)
        }
        # EXPR_WHILE = 52
        E I kind == 52 {
            @.generate_while(expr_ptr)
        }
        # EXPR_CALL = 33
        E I kind == 33 {
            @.generate_call(expr_ptr)
        }
        # EXPR_INDEX = 37
        E I kind == 37 {
            @.generate_index(expr_ptr)
        }
        # EXPR_ARRAY = 38
        E I kind == 38 {
            @.generate_array(expr_ptr)
        }
        # EXPR_BLOCK = 42
        E I kind == 42 {
            @.generate_block_expr(expr_ptr)
        }
        # EXPR_TERNARY = 29
        E I kind == 29 {
            @.generate_ternary(expr_ptr)
        }
        # EXPR_MATCH = 32
        E I kind == 32 {
            @.generate_match(expr_ptr)
        }
        # EXPR_METHOD_CALL = 34
        E I kind == 34 {
            @.generate_method_call(expr_ptr)
        }
        # EXPR_STATIC_CALL = 35
        E I kind == 35 {
            @.generate_static_call(expr_ptr)
        }
        # EXPR_FIELD = 36
        E I kind == 36 {
            @.generate_field_access(expr_ptr)
        }
        # EXPR_TUPLE = 39
        E I kind == 39 {
            @.generate_tuple(expr_ptr)
        }
        # EXPR_STRUCT_LIT = 40
        E I kind == 40 {
            @.generate_struct_lit(expr_ptr)
        }
        # EXPR_RANGE = 41
        E I kind == 41 {
            @.generate_range(expr_ptr)
        }
        # EXPR_TRY = 44
        E I kind == 44 {
            @.generate_try(expr_ptr)
        }
        # EXPR_UNWRAP = 45
        E I kind == 45 {
            @.generate_unwrap(expr_ptr)
        }
        # EXPR_REF = 46
        E I kind == 46 {
            @.generate_ref(expr_ptr)
        }
        # EXPR_DEREF = 47
        E I kind == 47 {
            @.generate_deref(expr_ptr)
        }
        # EXPR_ASSIGN = 48
        E I kind == 48 {
            @.generate_assign(expr_ptr)
        }
        # EXPR_ASSIGN_OP = 49
        E I kind == 49 {
            @.generate_assign_op(expr_ptr)
        }
        # EXPR_LAMBDA = 50
        E I kind == 50 {
            @.generate_lambda(expr_ptr)
        }
        # EXPR_AWAIT = 43
        E I kind == 43 {
            inner_ptr := load_i64(expr_ptr + 24)  # field0: Future expression
            inner_reg := @.generate_expr(inner_ptr)

            # Await: poll the future and extract the result value
            # For now, treat as identity (synchronous await) - extract value from Result/Option tag+value pair
            # The inner register holds a tagged union: tag(i64) + value(i64)
            # We load the value part (offset +8 from the pointer)
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, ")
            @.emit_reg(inner_reg)
            @.emit_cstr(" ; await\n")
            result
        }
        # EXPR_SPAWN = 51
        E I kind == 51 {
            inner_ptr := load_i64(expr_ptr + 24)  # field0: expression to spawn
            inner_reg := @.generate_expr(inner_ptr)

            # Spawn: create a task/future from the expression
            # For now, treat as identity - wrap value as a Future handle
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, ")
            @.emit_reg(inner_reg)
            @.emit_cstr(" ; spawn\n")
            result
        }
        E {
            # Unknown expression, return 0
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0 ; unknown expr kind ")
            @.emit_i64(kind)
            @.emit_cstr("\n")
            result
        }
    }

    F generate_ident(&self, name_idx: i64) -> i64 {
        local_ptr := @.find_local(name_idx)
        I local_ptr != 0 {
            is_alloca := load_i64(local_ptr + 40)
            type_kind := load_i64(local_ptr + 24)

            I is_alloca == 1 {
                # Load from alloca
                alloca_reg := load_i64(local_ptr + 8)
                result := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(result)
                @.emit_cstr(" = load ")
                @.type_to_llvm_str(type_kind)
                @.emit_cstr(", ")
                @.type_to_llvm_str(type_kind)
                @.emit_cstr("* ")
                @.emit_reg(alloca_reg)
                @.emit_cstr("\n")
                result
            } E {
                # Direct use of parameter
                result := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(result)
                @.emit_cstr(" = add ")
                @.type_to_llvm_str(type_kind)
                @.emit_cstr(" 0, %")
                @.emit_string_idx(name_idx)
                @.emit_cstr("\n")
                result
            }
        } E {
            # Unknown variable
            result := @.fresh_reg()
            @.emit_cstr("  ; unknown var: ")
            @.emit_string_idx(name_idx)
            @.emit_cstr("\n")
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0\n")
            result
        }
    }

    F generate_binary(&self, expr_ptr: i64) -> i64 {
        left_ptr := load_i64(expr_ptr + 24)
        right_ptr := load_i64(expr_ptr + 32)
        op := load_i64(expr_ptr + 40)

        left_reg := @.generate_expr(left_ptr)
        right_reg := @.generate_expr(right_ptr)
        result := @.fresh_reg()

        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ")

        I op == OP_ADD() { @.emit_cstr("add i64 ") }
        E I op == OP_SUB() { @.emit_cstr("sub i64 ") }
        E I op == OP_MUL() { @.emit_cstr("mul i64 ") }
        E I op == OP_DIV() { @.emit_cstr("sdiv i64 ") }
        E I op == OP_MOD() { @.emit_cstr("srem i64 ") }
        E I op == OP_LT() { @.emit_cstr("icmp slt i64 ") }
        E I op == OP_LTE() { @.emit_cstr("icmp sle i64 ") }
        E I op == OP_GT() { @.emit_cstr("icmp sgt i64 ") }
        E I op == OP_GTE() { @.emit_cstr("icmp sge i64 ") }
        E I op == OP_EQ() { @.emit_cstr("icmp eq i64 ") }
        E I op == OP_NEQ() { @.emit_cstr("icmp ne i64 ") }
        E I op == OP_AND() { @.emit_cstr("and i64 ") }
        E I op == OP_OR() { @.emit_cstr("or i64 ") }
        E I op == OP_BIT_AND() { @.emit_cstr("and i64 ") }
        E I op == OP_BIT_OR() { @.emit_cstr("or i64 ") }
        E I op == OP_BIT_XOR() { @.emit_cstr("xor i64 ") }
        E I op == OP_SHL() { @.emit_cstr("shl i64 ") }
        E I op == OP_SHR() { @.emit_cstr("ashr i64 ") }
        E { @.emit_cstr("add i64 ") }

        @.emit_reg(left_reg)
        @.emit_cstr(", ")
        @.emit_reg(right_reg)
        @.emit_cstr("\n")

        # For comparison ops, extend result to i64
        I op >= OP_LT() && op <= OP_NEQ() {
            ext_result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(ext_result)
            @.emit_cstr(" = zext i1 ")
            @.emit_reg(result)
            @.emit_cstr(" to i64\n")
            ext_result
        } E {
            result
        }
    }

    F generate_unary(&self, expr_ptr: i64) -> i64 {
        inner_ptr := load_i64(expr_ptr + 24)
        op := load_i64(expr_ptr + 32)

        inner_reg := @.generate_expr(inner_ptr)
        result := @.fresh_reg()

        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ")

        I op == UOP_NEG() {
            @.emit_cstr("sub i64 0, ")
            @.emit_reg(inner_reg)
        }
        E I op == UOP_NOT() {
            @.emit_cstr("xor i64 ")
            @.emit_reg(inner_reg)
            @.emit_cstr(", 1")
        }
        E I op == UOP_BITNOT() {
            @.emit_cstr("xor i64 ")
            @.emit_reg(inner_reg)
            @.emit_cstr(", -1")
        }
        E {
            @.emit_cstr("add i64 0, ")
            @.emit_reg(inner_reg)
        }

        @.emit_cstr("\n")
        result
    }

    F generate_if(&self, expr_ptr: i64) -> i64 {
        cond_ptr := load_i64(expr_ptr + 24)
        then_stmts := load_i64(expr_ptr + 32)
        then_len := load_i64(expr_ptr + 40)
        else_ptr := load_i64(expr_ptr + 48)

        label_id := @.fresh_label()

        # Generate condition
        cond_reg := @.generate_expr(cond_ptr)

        # Truncate to i1 for branch
        cond_i1 := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(cond_i1)
        @.emit_cstr(" = trunc i64 ")
        @.emit_reg(cond_reg)
        @.emit_cstr(" to i1\n")

        # Branch
        @.emit_cstr("  br i1 ")
        @.emit_reg(cond_i1)
        @.emit_cstr(", label %then")
        @.emit_i64(label_id)
        @.emit_cstr(", label %else")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Then block
        @.emit_cstr("then")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.generate_stmts(then_stmts, then_len)
        @.emit_cstr("  br label %end")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Else block
        @.emit_cstr("else")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        I else_ptr != 0 {
            @.generate_else(else_ptr)
            0
        } E { 0 }
        @.emit_cstr("  br label %end")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # End block
        @.emit_cstr("end")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        # Return unit (0)
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = add i64 0, 0\n")
        result
    }

    F generate_else(&self, else_ptr: i64) -> i64 {
        kind := load_i64(else_ptr)
        I kind == 0 {
            # else block
            stmts_ptr := load_i64(else_ptr + 16)
            stmts_len := load_i64(else_ptr + 24)
            @.generate_stmts(stmts_ptr, stmts_len)
        } E {
            # else-if
            cond_ptr := load_i64(else_ptr + 8)
            stmts_ptr := load_i64(else_ptr + 16)
            stmts_len := load_i64(else_ptr + 24)
            next_ptr := load_i64(else_ptr + 32)

            label_id := @.fresh_label()

            cond_reg := @.generate_expr(cond_ptr)
            cond_i1 := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(cond_i1)
            @.emit_cstr(" = trunc i64 ")
            @.emit_reg(cond_reg)
            @.emit_cstr(" to i1\n")

            @.emit_cstr("  br i1 ")
            @.emit_reg(cond_i1)
            @.emit_cstr(", label %elseif_then")
            @.emit_i64(label_id)
            @.emit_cstr(", label %elseif_else")
            @.emit_i64(label_id)
            @.emit_cstr("\n")

            @.emit_cstr("elseif_then")
            @.emit_i64(label_id)
            @.emit_cstr(":\n")
            @.generate_stmts(stmts_ptr, stmts_len)
            @.emit_cstr("  br label %elseif_end")
            @.emit_i64(label_id)
            @.emit_cstr("\n")

            @.emit_cstr("elseif_else")
            @.emit_i64(label_id)
            @.emit_cstr(":\n")
            I next_ptr != 0 {
                @.generate_else(next_ptr)
                0
            } E { 0 }
            @.emit_cstr("  br label %elseif_end")
            @.emit_i64(label_id)
            @.emit_cstr("\n")

            @.emit_cstr("elseif_end")
            @.emit_i64(label_id)
            @.emit_cstr(":\n")
        }
        1
    }

    F generate_loop(&self, expr_ptr: i64) -> i64 {
        body_stmts := load_i64(expr_ptr + 40)
        body_len := load_i64(expr_ptr + 48)

        label_id := @.fresh_label()

        # Push loop context
        @.push_loop(label_id, 0, label_id, 0)

        # Jump to loop condition
        @.emit_cstr("  br label %cond")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Condition (infinite loop, always branch to body)
        @.emit_cstr("cond")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.emit_cstr("  br label %body")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Body
        @.emit_cstr("body")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.generate_stmts(body_stmts, body_len)
        @.emit_cstr("  br label %cond")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # End
        @.emit_cstr("end")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        # Pop loop context
        @.pop_loop()

        # Return unit
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = add i64 0, 0\n")
        result
    }

    F generate_while(&self, expr_ptr: i64) -> i64 {
        cond_ptr := load_i64(expr_ptr + 24)   # field0: condition
        body_stmts := load_i64(expr_ptr + 32) # field1: body stmts
        body_len := load_i64(expr_ptr + 40)   # field2: body len

        label_id := @.fresh_label()

        # Push loop context (continue  cond, break  end)
        @.push_loop(label_id, 0, label_id, 0)

        # Jump to condition check
        @.emit_cstr("  br label %while_cond")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Condition block
        @.emit_cstr("while_cond")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        cond_reg := @.generate_expr(cond_ptr)
        cond_bool := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(cond_bool)
        @.emit_cstr(" = icmp ne i64 ")
        @.emit_reg(cond_reg)
        @.emit_cstr(", 0\n")
        @.emit_cstr("  br i1 ")
        @.emit_reg(cond_bool)
        @.emit_cstr(", label %while_body")
        @.emit_i64(label_id)
        @.emit_cstr(", label %end")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Body block
        @.emit_cstr("while_body")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.generate_stmts(body_stmts, body_len)
        @.emit_cstr("  br label %while_cond")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # End block
        @.emit_cstr("end")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        # Pop loop context
        @.pop_loop()

        # Return unit
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = add i64 0, 0\n")
        result
    }

    F generate_call(&self, expr_ptr: i64) -> i64 {
        func_ptr := load_i64(expr_ptr + 24)
        args_ptr := load_i64(expr_ptr + 32)
        args_len := load_i64(expr_ptr + 40)

        # Get function name
        func_kind := load_i64(func_ptr)
        I func_kind != 25 {
            # Not an identifier, return 0
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0 ; non-ident call\n")
            R result
        }

        func_name_idx := load_i64(func_ptr + 24)

        # Look up function
        fn_info := @.find_function(func_name_idx)
        ret_type := I fn_info != 0 {
            load_i64(fn_info + 24)
        } E {
            LLVM_I64()  # Default
        }

        # Generate arguments
        arg_regs_ptr := malloc(args_len * 8)
        i: mut i64 = 0
        L { I i >= args_len { B }
            arg_expr := load_i64(args_ptr + i * 8)
            arg_reg := @.generate_expr(arg_expr)
            store_i64(arg_regs_ptr + i * 8, arg_reg)
            i = i + 1
        }

        # Emit call
        result := @.fresh_reg()

        I ret_type == LLVM_VOID() {
            @.emit_cstr("  call void @")
        } E {
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = call ")
            @.type_to_llvm_str(ret_type)
            @.emit_cstr(" @")
        }

        @.emit_string_idx(func_name_idx)
        @.emit_cstr("(")

        i = 0
        L { I i >= args_len { B }
            I i > 0 { @.emit_cstr(", ") } E { 0 }
            @.emit_cstr("i64 ")
            arg_reg := load_i64(arg_regs_ptr + i * 8)
            @.emit_reg(arg_reg)
            i = i + 1
        }

        @.emit_cstr(")\n")

        free(arg_regs_ptr)

        I ret_type == LLVM_VOID() {
            zero := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(zero)
            @.emit_cstr(" = add i64 0, 0\n")
            zero
        } E {
            result
        }
    }

    F generate_array(&self, expr_ptr: i64) -> i64 {
        # Get elements array and length
        elements_ptr := load_i64(expr_ptr + 24)
        elements_len := load_i64(expr_ptr + 32)

        # For empty array, just return a null pointer
        I elements_len == 0 {
            result := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = inttoptr i64 0 to i64*\n")
            R result
        }

        # Allocate array on the stack (elements_len * 8 bytes for i64)
        alloca_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(alloca_reg)
        @.emit_cstr(" = alloca i64, i64 ")
        @.emit_i64(elements_len)
        @.emit_cstr("\n")

        # Generate each element and store
        i: mut i64 = 0
        L {
            I i >= elements_len { B }

            elem_expr := load_i64(elements_ptr + i * 8)
            elem_reg := @.generate_expr(elem_expr)

            # Calculate GEP for element i
            gep_reg := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(gep_reg)
            @.emit_cstr(" = getelementptr i64, i64* ")
            @.emit_reg(alloca_reg)
            @.emit_cstr(", i64 ")
            @.emit_i64(i)
            @.emit_cstr("\n")

            # Store element
            @.emit_cstr("  store i64 ")
            @.emit_reg(elem_reg)
            @.emit_cstr(", i64* ")
            @.emit_reg(gep_reg)
            @.emit_cstr("\n")

            i = i + 1
        }

        # Return pointer to first element
        alloca_reg
    }

    F generate_index(&self, expr_ptr: i64) -> i64 {
        # Get base and index expressions
        base_expr := load_i64(expr_ptr + 24)
        index_expr := load_i64(expr_ptr + 32)

        # Generate code for base (array/pointer)
        base_reg := @.generate_expr(base_expr)

        # Generate code for index
        index_reg := @.generate_expr(index_expr)

        # Calculate element pointer using GEP
        # Assuming i64 element type for simplicity
        elem_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(elem_ptr)
        @.emit_cstr(" = getelementptr i64, i64* ")
        @.emit_reg(base_reg)
        @.emit_cstr(", i64 ")
        @.emit_reg(index_reg)
        @.emit_cstr("\n")

        # Load the value at the calculated address
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = load i64, i64* ")
        @.emit_reg(elem_ptr)
        @.emit_cstr("\n")

        result
    }

    F generate_block_expr(&self, expr_ptr: i64) -> i64 {
        stmts_ptr := load_i64(expr_ptr + 24)
        stmts_len := load_i64(expr_ptr + 32)

        @.generate_stmts(stmts_ptr, stmts_len)

        # Return unit
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = add i64 0, 0\n")
        result
    }

    F generate_assign(&self, expr_ptr: i64) -> i64 {
        target_ptr := load_i64(expr_ptr + 24)
        value_ptr := load_i64(expr_ptr + 32)

        target_kind := load_i64(target_ptr)
        I target_kind != 25 {
            # Not an identifier target, just evaluate value
            R @.generate_expr(value_ptr)
        }

        target_name_idx := load_i64(target_ptr + 24)
        local_ptr := @.find_local(target_name_idx)

        I local_ptr == 0 {
            # Unknown variable
            R @.generate_expr(value_ptr)
        }

        is_alloca := load_i64(local_ptr + 40)
        type_kind := load_i64(local_ptr + 24)

        I is_alloca != 1 {
            # Can't assign to parameter (for now)
            R @.generate_expr(value_ptr)
        }

        value_reg := @.generate_expr(value_ptr)
        alloca_reg := load_i64(local_ptr + 8)

        @.emit_cstr("  store ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr(" ")
        @.emit_reg(value_reg)
        @.emit_cstr(", ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr("* ")
        @.emit_reg(alloca_reg)
        @.emit_cstr("\n")

        value_reg
    }

    # ========== Self Call (@ operator) ==========

    F generate_self_call(&self, expr_ptr: i64) -> i64 {
        # @ = recursive call to current function
        # Self call has no explicit data; it refers to the current function
        # Emit a call to the current function with no args (caller will wrap with method_call)
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @")
        @.emit_string_idx(self.current_fn_name_idx)
        @.emit_cstr("()\n")
        result
    }

    # ========== Tuple ==========

    F generate_tuple(&self, expr_ptr: i64) -> i64 {
        # TUPLE: field0 = elements_ptr, field1 = len
        elements_ptr := load_i64(expr_ptr + 24)
        elements_len := load_i64(expr_ptr + 32)

        # Allocate memory for tuple (elements_len * 8 bytes)
        size := elements_len * 8
        I size == 0 { size = 8 } E { 0 }

        size_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(size_reg)
        @.emit_cstr(" = add i64 0, ")
        @.emit_i64(size)
        @.emit_cstr("\n")

        raw_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" = call i8* @malloc(i64 ")
        @.emit_reg(size_reg)
        @.emit_cstr(")\n")

        tuple_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(tuple_ptr)
        @.emit_cstr(" = ptrtoint i8* ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" to i64\n")

        # Store each element
        i: mut i64 = 0
        L { I i >= elements_len { B }
            elem_expr := load_i64(elements_ptr + i * 8)
            elem_reg := @.generate_expr(elem_expr)

            offset_reg := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(offset_reg)
            @.emit_cstr(" = add i64 ")
            @.emit_reg(tuple_ptr)
            @.emit_cstr(", ")
            @.emit_i64(i * 8)
            @.emit_cstr("\n")

            @.emit_cstr("  call void @store_i64(i64 ")
            @.emit_reg(offset_reg)
            @.emit_cstr(", i64 ")
            @.emit_reg(elem_reg)
            @.emit_cstr(")\n")

            i = i + 1
        }

        tuple_ptr
    }

    # ========== Range ==========

    F generate_range(&self, expr_ptr: i64) -> i64 {
        # RANGE: field0 = start_ptr, field1 = end_ptr, field2 = inclusive
        start_ptr := load_i64(expr_ptr + 24)
        end_ptr := load_i64(expr_ptr + 32)
        inclusive := load_i64(expr_ptr + 40)

        # Allocate a 3-element struct: (start, end, inclusive)
        raw_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" = call i8* @malloc(i64 24)\n")

        range_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(range_ptr)
        @.emit_cstr(" = ptrtoint i8* ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" to i64\n")

        # Store start
        start_reg := I start_ptr != 0 { @.generate_expr(start_ptr) } E {
            zero := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(zero)
            @.emit_cstr(" = add i64 0, 0\n")
            zero
        }
        @.emit_cstr("  call void @store_i64(i64 ")
        @.emit_reg(range_ptr)
        @.emit_cstr(", i64 ")
        @.emit_reg(start_reg)
        @.emit_cstr(")\n")

        # Store end
        end_offset := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(end_offset)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(range_ptr)
        @.emit_cstr(", 8\n")

        end_reg := I end_ptr != 0 { @.generate_expr(end_ptr) } E {
            max := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(max)
            @.emit_cstr(" = add i64 0, 9223372036854775807\n")
            max
        }
        @.emit_cstr("  call void @store_i64(i64 ")
        @.emit_reg(end_offset)
        @.emit_cstr(", i64 ")
        @.emit_reg(end_reg)
        @.emit_cstr(")\n")

        # Store inclusive flag
        incl_offset := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(incl_offset)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(range_ptr)
        @.emit_cstr(", 16\n")
        @.emit_cstr("  call void @store_i64(i64 ")
        @.emit_reg(incl_offset)
        @.emit_cstr(", i64 ")
        @.emit_i64(inclusive)
        @.emit_cstr(")\n")

        range_ptr
    }

    # ========== Lambda Helpers ==========

    F lambda_emit_cstr(&self, s: str) -> i64 {
        len := strlen(s)
        lb_data: mut i64 = load_i64(self.lambda_buf)
        lb_len := load_i64(self.lambda_buf + 8)
        lb_cap := load_i64(self.lambda_buf + 16)

        I lb_len + len > lb_cap {
            new_cap := (lb_cap + len) * 2
            new_data := malloc(new_cap)
            memcpy(new_data, lb_data, lb_len)
            free(lb_data)
            store_i64(self.lambda_buf, new_data)
            store_i64(self.lambda_buf + 16, new_cap)
            lb_data = new_data
            0
        } E { 0 }

        memcpy_str(lb_data + lb_len, s, len)
        store_i64(self.lambda_buf + 8, lb_len + len)
        1
    }

    F lambda_emit_i64(&self, value: i64) -> i64 {
        # Write i64 to lambda buffer using temp buf
        store_i64(self.temp_buf + 8, 0)
        tb_data := load_i64(self.temp_buf)

        I value == 0 {
            store_byte(tb_data, 48)
            @.lambda_emit_ptr(tb_data, 1)
        } E I value < 0 {
            store_byte(tb_data, 45)
            @.lambda_emit_ptr(tb_data, 1)
            @.lambda_emit_i64(0 - value)
        } E {
            @.lambda_emit_positive_i64(value)
        }
    }

    F lambda_emit_positive_i64(&self, value: i64) -> i64 {
        I value == 0 { R 1 }
        @.lambda_emit_positive_i64(value / 10)
        digit := (value % 10) + 48
        tb_data := load_i64(self.temp_buf)
        store_byte(tb_data, digit)
        @.lambda_emit_ptr(tb_data, 1)
    }

    F lambda_emit_ptr(&self, ptr: i64, len: i64) -> i64 {
        lb_data: mut i64 = load_i64(self.lambda_buf)
        lb_len := load_i64(self.lambda_buf + 8)
        lb_cap := load_i64(self.lambda_buf + 16)

        I lb_len + len > lb_cap {
            new_cap := (lb_cap + len) * 2
            new_data := malloc(new_cap)
            memcpy(new_data, lb_data, lb_len)
            free(lb_data)
            store_i64(self.lambda_buf, new_data)
            store_i64(self.lambda_buf + 16, new_cap)
            lb_data = new_data
            0
        } E { 0 }

        memcpy(lb_data + lb_len, ptr, len)
        store_i64(self.lambda_buf + 8, lb_len + len)
        1
    }

    F lambda_emit_reg(&self, n: i64) -> i64 {
        @.lambda_emit_cstr("%")
        @.lambda_emit_i64(n)
    }

    F emit_lambda_functions(&self) -> i64 {
        lb_len := load_i64(self.lambda_buf + 8)
        I lb_len == 0 { R 1 }

        @.emit_cstr("\n; Lambda functions\n")
        lb_data := load_i64(self.lambda_buf)
        @.emit_ptr(lb_data, lb_len)
        1
    }

    # ========== Lambda Capture Analysis ==========

    # Collect free variables (captured from outer scope) in an expression
    # params_ptr/params_len: lambda parameter names to exclude
    # captures_ptr: output buffer to store captured variable info (preallocated)
    #   Each entry is 16 bytes: (name_idx: i64, capture_mode: i64)
    #   capture_mode: 0 = Move (value copy), 1 = Ref (pointer pass)
    # Returns the number of captured variables found
    F collect_captures(&self, body_ptr: i64, params_ptr: i64, params_len: i64,
                       captures_ptr: i64, captures_len: i64, captures_cap: i64) -> i64 {
        body_kind := load_i64(body_ptr)

        # EXPR_IDENT = 25 - check if this ident is a capture
        I body_kind == 25 {
            name_idx := load_i64(body_ptr + 24)

            # Check if it's a lambda parameter - skip if so
            is_lambda_param: mut i64 = 0
            pi: mut i64 = 0
            L { I pi >= params_len { B }
                param_ptr := params_ptr + pi * 40
                param_name := load_i64(param_ptr)
                I param_name == name_idx {
                    is_lambda_param = 1
                    B
                } E { 0 }
                pi = pi + 1
            }
            I is_lambda_param == 1 { R captures_len }

            # Check if it exists in outer locals (is a capture candidate)
            local_ptr := @.find_local(name_idx)
            I local_ptr == 0 { R captures_len }  # Not in scope, skip

            # Check for duplicate
            ci: mut i64 = 0
            L { I ci >= captures_len { B }
                I load_i64(captures_ptr + ci * 16) == name_idx {
                    R captures_len  # Already captured
                } E { 0 }
                ci = ci + 1
            }

            # Determine capture mode: Ref for mutable locals (alloca), Move for params
            is_alloca := load_i64(local_ptr + 40)
            cap_mode := I is_alloca == 1 { 1 } E { 0 }  # 1=Ref, 0=Move

            # Add capture with mode
            I captures_len < captures_cap {
                store_i64(captures_ptr + captures_len * 16, name_idx)
                store_i64(captures_ptr + captures_len * 16 + 8, cap_mode)
                R captures_len + 1
            } E { R captures_len }
        }

        # EXPR_BINARY = 27: recurse into left and right
        E I body_kind == 27 {
            left_ptr := load_i64(body_ptr + 24)
            right_ptr := load_i64(body_ptr + 32)
            len1 := @.collect_captures(left_ptr, params_ptr, params_len, captures_ptr, captures_len, captures_cap)
            @.collect_captures(right_ptr, params_ptr, params_len, captures_ptr, len1, captures_cap)
        }
        # EXPR_UNARY = 28: recurse into operand
        E I body_kind == 28 {
            inner_ptr := load_i64(body_ptr + 24)
            @.collect_captures(inner_ptr, params_ptr, params_len, captures_ptr, captures_len, captures_cap)
        }
        # EXPR_CALL = 33: recurse into func and args
        E I body_kind == 33 {
            func_ptr := load_i64(body_ptr + 24)
            args_ptr := load_i64(body_ptr + 32)
            args_len := load_i64(body_ptr + 40)
            cur_len: mut i64 = @.collect_captures(func_ptr, params_ptr, params_len, captures_ptr, captures_len, captures_cap)
            ai: mut i64 = 0
            L { I ai >= args_len { B }
                arg_expr := load_i64(args_ptr + ai * 8)
                cur_len = @.collect_captures(arg_expr, params_ptr, params_len, captures_ptr, cur_len, captures_cap)
                ai = ai + 1
            }
            cur_len
        }
        # EXPR_IF = 30: cond, then stmts, else ptr
        E I body_kind == 30 {
            cond_ptr := load_i64(body_ptr + 24)
            cur_len: mut i64 = @.collect_captures(cond_ptr, params_ptr, params_len, captures_ptr, captures_len, captures_cap)
            # then block stmts
            then_stmts := load_i64(body_ptr + 32)
            then_len := load_i64(body_ptr + 40)
            si: mut i64 = 0
            L { I si >= then_len { B }
                stmt_ptr := then_stmts + si * 32
                stmt_kind := load_i64(stmt_ptr)
                # STMT_EXPR = 4 or others - try to extract expr
                stmt_expr := load_i64(stmt_ptr + 8)
                I stmt_expr != 0 {
                    cur_len = @.collect_captures(stmt_expr, params_ptr, params_len, captures_ptr, cur_len, captures_cap)
                    0
                } E { 0 }
                si = si + 1
            }
            # else branch
            else_ptr := load_i64(body_ptr + 48)
            I else_ptr != 0 {
                cur_len = @.collect_captures(else_ptr, params_ptr, params_len, captures_ptr, cur_len, captures_cap)
                0
            } E { 0 }
            cur_len
        }
        # EXPR_BLOCK = 42: stmts
        E I body_kind == 42 {
            stmts_ptr := load_i64(body_ptr + 24)
            stmts_len := load_i64(body_ptr + 32)
            cur_len: mut i64 = captures_len
            si: mut i64 = 0
            L { I si >= stmts_len { B }
                stmt_ptr := stmts_ptr + si * 32
                stmt_expr := load_i64(stmt_ptr + 8)
                I stmt_expr != 0 {
                    cur_len = @.collect_captures(stmt_expr, params_ptr, params_len, captures_ptr, cur_len, captures_cap)
                    0
                } E { 0 }
                si = si + 1
            }
            cur_len
        }
        # EXPR_METHOD_CALL = 34: receiver + args
        E I body_kind == 34 {
            recv_ptr := load_i64(body_ptr + 24)
            args_ptr := load_i64(body_ptr + 40)
            args_len := load_i64(body_ptr + 48)
            cur_len: mut i64 = @.collect_captures(recv_ptr, params_ptr, params_len, captures_ptr, captures_len, captures_cap)
            ai: mut i64 = 0
            L { I ai >= args_len { B }
                arg_expr := load_i64(args_ptr + ai * 8)
                cur_len = @.collect_captures(arg_expr, params_ptr, params_len, captures_ptr, cur_len, captures_cap)
                ai = ai + 1
            }
            cur_len
        }
        # EXPR_FIELD = 36: inner expr
        E I body_kind == 36 {
            inner_ptr := load_i64(body_ptr + 24)
            @.collect_captures(inner_ptr, params_ptr, params_len, captures_ptr, captures_len, captures_cap)
        }
        # EXPR_INDEX = 37: expr + index
        E I body_kind == 37 {
            base_ptr := load_i64(body_ptr + 24)
            idx_ptr := load_i64(body_ptr + 32)
            len1 := @.collect_captures(base_ptr, params_ptr, params_len, captures_ptr, captures_len, captures_cap)
            @.collect_captures(idx_ptr, params_ptr, params_len, captures_ptr, len1, captures_cap)
        }
        # EXPR_TERNARY = 29: cond, then, else
        E I body_kind == 29 {
            cond_ptr := load_i64(body_ptr + 24)
            then_ptr := load_i64(body_ptr + 32)
            else_ptr := load_i64(body_ptr + 40)
            len1 := @.collect_captures(cond_ptr, params_ptr, params_len, captures_ptr, captures_len, captures_cap)
            len2 := @.collect_captures(then_ptr, params_ptr, params_len, captures_ptr, len1, captures_cap)
            @.collect_captures(else_ptr, params_ptr, params_len, captures_ptr, len2, captures_cap)
        }
        E {
            # For literal types (INT, FLOAT, BOOL, STRING, UNIT) - no captures
            captures_len
        }
    }

    # ========== Lambda Codegen ==========

    F generate_lambda(&self, expr_ptr: i64) -> i64 {
        # LAMBDA: field0 = params_ptr, field1 = params_len, field2 = body_ptr
        params_ptr := load_i64(expr_ptr + 24)
        params_len := load_i64(expr_ptr + 32)
        body_ptr := load_i64(expr_ptr + 40)

        # Analyze captures (free variables from outer scope)
        # Each entry: 16 bytes (name_idx, capture_mode: 0=Move, 1=Ref)
        capture_buf := malloc(32 * 16)  # Max 32 captures
        num_captures := @.collect_captures(body_ptr, params_ptr, params_len, capture_buf, 0, 32)

        # Generate values for captured variables (before switching context)
        capture_regs := malloc(num_captures * 8)
        ci: mut i64 = 0
        L { I ci >= num_captures { B }
            cap_name_idx := load_i64(capture_buf + ci * 16)
            cap_mode := load_i64(capture_buf + ci * 16 + 8)
            local_ptr := @.find_local(cap_name_idx)
            I local_ptr != 0 {
                is_param := load_i64(local_ptr + 32)  # LocalVar.is_param
                I cap_mode == 1 {
                    # Ref capture: pass the alloca pointer itself
                    alloca_reg := load_i64(local_ptr + 8)
                    cap_reg := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(cap_reg)
                    @.emit_cstr(" = ptrtoint i64* ")
                    @.emit_reg(alloca_reg)
                    @.emit_cstr(" to i64 ; ref capture\n")
                    store_i64(capture_regs + ci * 8, cap_reg)
                } E I is_param == 1 {
                    # Move capture of parameter: copy value
                    cap_reg := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(cap_reg)
                    @.emit_cstr(" = add i64 %")
                    cap_name_ptr := @.get_string_ptr(cap_name_idx)
                    cap_name_len := @.get_string_len(cap_name_idx)
                    @.emit_ptr(cap_name_ptr, cap_name_len)
                    @.emit_cstr(", 0 ; move capture\n")
                    store_i64(capture_regs + ci * 8, cap_reg)
                } E {
                    # Move capture of local: load value from alloca
                    alloca_reg := load_i64(local_ptr + 8)
                    cap_reg := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(cap_reg)
                    @.emit_cstr(" = load i64, i64* ")
                    @.emit_reg(alloca_reg)
                    @.emit_cstr(" ; move capture\n")
                    store_i64(capture_regs + ci * 8, cap_reg)
                }
            } E {
                store_i64(capture_regs + ci * 8, 0)
            }
            ci = ci + 1
        }

        # Generate unique lambda name
        lambda_id := self.lambda_counter
        self.lambda_counter = self.lambda_counter + 1

        # Save current function context
        saved_fn_name := self.current_fn_name_idx
        saved_fn_ret := self.current_fn_ret_type
        saved_locals_len := self.locals_len
        saved_reg := self.reg_counter
        saved_label := self.label_counter

        # Reset counters for lambda function
        self.reg_counter = 0
        self.label_counter = 0

        # Emit lambda function definition to lambda buffer
        @.lambda_emit_cstr("define i64 @__lambda_")
        @.lambda_emit_i64(lambda_id)
        @.lambda_emit_cstr("(")

        # Emit captured variable parameters first
        total_params: mut i64 = 0
        ci = 0
        L { I ci >= num_captures { B }
            I total_params > 0 { @.lambda_emit_cstr(", ") } E { 0 }

            cap_name_idx := load_i64(capture_buf + ci * 16)
            cap_mode := load_i64(capture_buf + ci * 16 + 8)
            @.lambda_emit_cstr("i64 %")
            pname_ptr := @.get_string_ptr(cap_name_idx)
            pname_len := @.get_string_len(cap_name_idx)
            @.lambda_emit_ptr(pname_ptr, pname_len)

            I cap_mode == 1 {
                # Ref capture: register as alloca (pointer semantics)
                # The parameter holds a pointer, needs alloca-like treatment
                # We create an alloca and store the pointer into it, or
                # directly register with alloca flag so reads/writes go through it
                @.lambda_emit_cstr("_ptr")
                # We'll create an alloca in the lambda body for ref captures
            } E { 0 }

            # Register capture as local parameter (Move captures are direct params)
            I cap_mode == 0 {
                @.add_local(cap_name_idx, pname_ptr, pname_len, LLVM_I64(), 1)
            } E { 0 }

            total_params = total_params + 1
            ci = ci + 1
        }

        # Emit regular parameters
        i: mut i64 = 0
        L { I i >= params_len { B }
            I total_params > 0 { @.lambda_emit_cstr(", ") } E { 0 }

            param_ptr := params_ptr + i * 40  # Param.size() = 40
            param_name_idx := load_i64(param_ptr)

            @.lambda_emit_cstr("i64 %")

            # Emit param name
            pname_ptr := @.get_string_ptr(param_name_idx)
            pname_len := @.get_string_len(param_name_idx)
            @.lambda_emit_ptr(pname_ptr, pname_len)

            # Register parameter as local
            @.add_local(param_name_idx, pname_ptr, pname_len, LLVM_I64(), 1)

            total_params = total_params + 1
            i = i + 1
        }

        @.lambda_emit_cstr(") {\n")
        @.lambda_emit_cstr("entry:\n")

        # Swap output to lambda buffer for body generation
        saved_output := self.output
        self.output = self.lambda_buf

        self.current_fn_ret_type = LLVM_I64()

        # For ref captures: create alloca and inttoptr the parameter
        # The parameter was named %varname_ptr and holds a pointer as i64
        # We need to make the variable accessible as if it's an alloca
        ci = 0
        L { I ci >= num_captures { B }
            cap_mode := load_i64(capture_buf + ci * 16 + 8)
            I cap_mode == 1 {
                cap_name_idx := load_i64(capture_buf + ci * 16)
                pname_ptr := @.get_string_ptr(cap_name_idx)
                pname_len := @.get_string_len(cap_name_idx)

                # Convert param (i64 holding pointer) to i64* via inttoptr
                ptr_reg := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(ptr_reg)
                @.emit_cstr(" = inttoptr i64 %")
                @.emit_ptr(pname_ptr, pname_len)
                @.emit_cstr("_ptr to i64* ; ref capture unwrap\n")

                # Register as alloca-like local (reads/writes go through pointer)
                local_idx := @.add_local(cap_name_idx, ptr_reg, 0, LLVM_I64(), 0)
                local_ptr := self.locals_ptr + local_idx * LocalVar.size()
                store_i64(local_ptr + 8, ptr_reg)  # llvm_name_ptr = reg number
                store_i64(local_ptr + 40, 1)  # is_alloca = 1 (pointer semantics)
            } E { 0 }
            ci = ci + 1
        }

        # Generate body
        body_reg := @.generate_expr(body_ptr)

        # Emit return
        @.emit_cstr("  ret i64 ")
        @.emit_reg(body_reg)
        @.emit_cstr("\n")
        @.emit_cstr("}\n\n")

        # Restore output
        self.output = saved_output

        # Restore function context
        self.current_fn_name_idx = saved_fn_name
        self.current_fn_ret_type = saved_fn_ret
        self.locals_len = saved_locals_len
        self.reg_counter = saved_reg
        self.label_counter = saved_label

        # Return function pointer as i64
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ptrtoint i64 (")

        # Emit parameter types for function pointer type (captures + params)
        j: mut i64 = 0
        L { I j >= num_captures + params_len { B }
            I j > 0 { @.emit_cstr(", ") } E { 0 }
            @.emit_cstr("i64")
            j = j + 1
        }

        @.emit_cstr(")* @__lambda_")
        @.emit_i64(lambda_id)
        @.emit_cstr(" to i64\n")

        free(capture_buf)
        free(capture_regs)

        result
    }

    # ========== Ref (& operator) ==========

    F generate_ref(&self, expr_ptr: i64) -> i64 {
        # REF: field0 = inner expr
        inner_ptr := load_i64(expr_ptr + 24)

        # If inner is an identifier with alloca, return the alloca pointer
        inner_kind := load_i64(inner_ptr)
        I inner_kind == 25 {
            # EXPR_IDENT
            name_idx := load_i64(inner_ptr + 24)
            local_ptr := @.find_local(name_idx)
            I local_ptr != 0 {
                is_alloca := load_i64(local_ptr + 40)
                I is_alloca == 1 {
                    # Return the alloca register as the pointer value
                    alloca_reg := load_i64(local_ptr + 8)
                    result := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(result)
                    @.emit_cstr(" = ptrtoint i64* ")
                    @.emit_reg(alloca_reg)
                    @.emit_cstr(" to i64\n")
                    R result
                } E { 0 }
            } E { 0 }
            0
        } E { 0 }

        # Fallback: generate expr and store it on stack, return pointer
        inner_reg := @.generate_expr(inner_ptr)
        alloca := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(alloca)
        @.emit_cstr(" = alloca i64\n")
        @.emit_cstr("  store i64 ")
        @.emit_reg(inner_reg)
        @.emit_cstr(", i64* ")
        @.emit_reg(alloca)
        @.emit_cstr("\n")

        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ptrtoint i64* ")
        @.emit_reg(alloca)
        @.emit_cstr(" to i64\n")
        result
    }

    # ========== Deref (* operator) ==========

    F generate_deref(&self, expr_ptr: i64) -> i64 {
        # DEREF: field0 = inner expr (pointer value)
        inner_ptr := load_i64(expr_ptr + 24)
        ptr_reg := @.generate_expr(inner_ptr)

        # Load value from pointer
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(ptr_reg)
        @.emit_cstr(")\n")
        result
    }

    # ========== Try (? operator) ==========

    F generate_try(&self, expr_ptr: i64) -> i64 {
        # TRY: field0 = inner expr (Result value)
        # Result layout: first i64 is tag (0=Ok, 1=Err), second i64 is value
        inner_ptr := load_i64(expr_ptr + 24)
        result_reg := @.generate_expr(inner_ptr)

        label_id := @.fresh_label()

        # Load tag (first field of result)
        tag_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(tag_reg)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(result_reg)
        @.emit_cstr(")\n")

        # Check if Err (tag == 1)
        is_err := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(is_err)
        @.emit_cstr(" = icmp eq i64 ")
        @.emit_reg(tag_reg)
        @.emit_cstr(", 1\n")

        @.emit_cstr("  br i1 ")
        @.emit_reg(is_err)
        @.emit_cstr(", label %try_err")
        @.emit_i64(label_id)
        @.emit_cstr(", label %try_ok")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Error path: early return with Err value
        @.emit_cstr("try_err")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        @.emit_cstr("  ret i64 ")
        @.emit_reg(result_reg)
        @.emit_cstr("\n")

        # Ok path: extract value (second field)
        @.emit_cstr("try_ok")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        val_offset := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(val_offset)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(result_reg)
        @.emit_cstr(", 8\n")

        val_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(val_reg)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(val_offset)
        @.emit_cstr(")\n")

        val_reg
    }

    # ========== Unwrap (! operator) ==========

    F generate_unwrap(&self, expr_ptr: i64) -> i64 {
        # UNWRAP: field0 = inner expr (Optional/Result value)
        # Simply extract the value (second field), assume it's valid
        inner_ptr := load_i64(expr_ptr + 24)
        result_reg := @.generate_expr(inner_ptr)

        # Load value from offset 8 (skip tag)
        val_offset := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(val_offset)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(result_reg)
        @.emit_cstr(", 8\n")

        val_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(val_reg)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(val_offset)
        @.emit_cstr(")\n")

        val_reg
    }

    # ========== Assign Op (+=, -=, *=, /=) ==========

    F generate_assign_op(&self, expr_ptr: i64) -> i64 {
        # ASSIGN_OP: field0 = target, field1 = value, field2 = op
        target_ptr := load_i64(expr_ptr + 24)
        value_ptr := load_i64(expr_ptr + 32)
        op := load_i64(expr_ptr + 40)

        target_kind := load_i64(target_ptr)
        I target_kind != 25 {
            # Not an identifier target
            R @.generate_expr(value_ptr)
        }

        target_name_idx := load_i64(target_ptr + 24)
        local_ptr := @.find_local(target_name_idx)

        I local_ptr == 0 {
            R @.generate_expr(value_ptr)
        }

        is_alloca := load_i64(local_ptr + 40)
        type_kind := load_i64(local_ptr + 24)

        I is_alloca != 1 {
            R @.generate_expr(value_ptr)
        }

        # Load current value
        alloca_reg := load_i64(local_ptr + 8)
        current_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(current_reg)
        @.emit_cstr(" = load ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr(", ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr("* ")
        @.emit_reg(alloca_reg)
        @.emit_cstr("\n")

        # Generate RHS
        rhs_reg := @.generate_expr(value_ptr)

        # Apply operation
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = ")

        I op == OP_ADD() { @.emit_cstr("add i64 ") }
        E I op == OP_SUB() { @.emit_cstr("sub i64 ") }
        E I op == OP_MUL() { @.emit_cstr("mul i64 ") }
        E I op == OP_DIV() { @.emit_cstr("sdiv i64 ") }
        E I op == OP_MOD() { @.emit_cstr("srem i64 ") }
        E { @.emit_cstr("add i64 ") }

        @.emit_reg(current_reg)
        @.emit_cstr(", ")
        @.emit_reg(rhs_reg)
        @.emit_cstr("\n")

        # Store back
        @.emit_cstr("  store ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr(" ")
        @.emit_reg(result)
        @.emit_cstr(", ")
        @.type_to_llvm_str(type_kind)
        @.emit_cstr("* ")
        @.emit_reg(alloca_reg)
        @.emit_cstr("\n")

        result
    }

    # ========== Match Expression ==========

    F generate_match(&self, expr_ptr: i64) -> i64 {
        # MATCH: field0 = scrutinee expr, field1 = arms ptr, field2 = arms_len
        scrutinee_ptr := load_i64(expr_ptr + 24)
        arms_ptr := load_i64(expr_ptr + 32)
        arms_len := load_i64(expr_ptr + 40)

        # Generate scrutinee
        scrutinee_reg := @.generate_expr(scrutinee_ptr)

        merge_label := @.fresh_label()

        # Allocate array for (arm_label, result_reg) pairs for phi node
        arm_results_ptr := malloc(arms_len * 16)  # (label_id, result_reg) pairs

        i: mut i64 = 0
        L { I i >= arms_len { B }
            arm_ptr := arms_ptr + i * 40  # MatchArm.size() = 40
            pattern_ptr := load_i64(arm_ptr)
            guard_ptr := load_i64(arm_ptr + 8)
            body_ptr := load_i64(arm_ptr + 16)

            arm_label := @.fresh_label()
            next_label := I i + 1 < arms_len { @.fresh_label() } E { merge_label }

            # Pattern matching: compare scrutinee against pattern
            pat_kind := load_i64(pattern_ptr)

            # PAT_WILDCARD = 80, PAT_IDENT = 81
            I pat_kind == 80 || pat_kind == 81 {
                # Wildcard/ident always matches
                I pat_kind == 81 {
                    # Bind the scrutinee value to the pattern variable
                    bind_name_idx := load_i64(pattern_ptr + 24)
                    alloca_reg := @.fresh_reg()
                    @.emit_cstr("  ")
                    @.emit_reg(alloca_reg)
                    @.emit_cstr(" = alloca i64\n")
                    @.emit_cstr("  store i64 ")
                    @.emit_reg(scrutinee_reg)
                    @.emit_cstr(", i64* ")
                    @.emit_reg(alloca_reg)
                    @.emit_cstr("\n")
                    name_ptr := @.get_string_ptr(bind_name_idx)
                    name_len := @.get_string_len(bind_name_idx)
                    local_idx := @.add_local(bind_name_idx, alloca_reg, 0, LLVM_I64(), 0)
                    local_ptr := self.locals_ptr + local_idx * 48  # LocalVar.size()
                    store_i64(local_ptr + 40, 1)  # is_alloca = 1
                    0
                } E { 0 }
                @.emit_cstr("  br label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr("\n")
            }
            # PAT_LITERAL = 82
            E I pat_kind == 82 {
                lit_value := load_i64(pattern_ptr + 24)
                cmp_reg := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(cmp_reg)
                @.emit_cstr(" = icmp eq i64 ")
                @.emit_reg(scrutinee_reg)
                @.emit_cstr(", ")
                @.emit_i64(lit_value)
                @.emit_cstr("\n")
                @.emit_cstr("  br i1 ")
                @.emit_reg(cmp_reg)
                @.emit_cstr(", label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr(", label %next")
                @.emit_i64(next_label)
                @.emit_cstr("\n")
            }
            # PAT_VARIANT = 85 (enum variant: compare tag)
            E I pat_kind == 85 {
                variant_name_idx := load_i64(pattern_ptr + 24)
                # Compare tag (treat variant name as tag index for now)
                cmp_reg := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(cmp_reg)
                @.emit_cstr(" = icmp eq i64 ")
                @.emit_reg(scrutinee_reg)
                @.emit_cstr(", ")
                @.emit_i64(variant_name_idx)
                @.emit_cstr("\n")
                @.emit_cstr("  br i1 ")
                @.emit_reg(cmp_reg)
                @.emit_cstr(", label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr(", label %next")
                @.emit_i64(next_label)
                @.emit_cstr("\n")
            }
            # PAT_RANGE = 86
            E I pat_kind == 86 {
                range_start_pat := load_i64(pattern_ptr + 24)
                range_end_pat := load_i64(pattern_ptr + 32)
                range_inclusive := load_i64(pattern_ptr + 40)
                start_val := load_i64(range_start_pat + 24)
                end_val := load_i64(range_end_pat + 24)

                # scrutinee >= start
                ge_reg := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(ge_reg)
                @.emit_cstr(" = icmp sge i64 ")
                @.emit_reg(scrutinee_reg)
                @.emit_cstr(", ")
                @.emit_i64(start_val)
                @.emit_cstr("\n")

                # scrutinee <= end (inclusive) or scrutinee < end (exclusive)
                le_reg := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(le_reg)
                I range_inclusive == 1 {
                    @.emit_cstr(" = icmp sle i64 ")
                } E {
                    @.emit_cstr(" = icmp slt i64 ")
                }
                @.emit_reg(scrutinee_reg)
                @.emit_cstr(", ")
                @.emit_i64(end_val)
                @.emit_cstr("\n")

                # Both conditions must be true
                and_reg := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(and_reg)
                @.emit_cstr(" = and i1 ")
                @.emit_reg(ge_reg)
                @.emit_cstr(", ")
                @.emit_reg(le_reg)
                @.emit_cstr("\n")

                @.emit_cstr("  br i1 ")
                @.emit_reg(and_reg)
                @.emit_cstr(", label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr(", label %next")
                @.emit_i64(next_label)
                @.emit_cstr("\n")
            }
            # PAT_OR = 87
            E I pat_kind == 87 {
                or_pats_ptr := load_i64(pattern_ptr + 24)
                or_pats_len := load_i64(pattern_ptr + 32)

                # Try each sub-pattern; if any matches, go to arm
                k: mut i64 = 0
                L { I k >= or_pats_len { B }
                    sub_pat := load_i64(or_pats_ptr + k * 8)
                    sub_kind := load_i64(sub_pat)
                    or_next := I k + 1 < or_pats_len { @.fresh_label() } E { next_label }

                    I sub_kind == 82 {
                        # Literal sub-pattern
                        sub_val := load_i64(sub_pat + 24)
                        cmp_or := @.fresh_reg()
                        @.emit_cstr("  ")
                        @.emit_reg(cmp_or)
                        @.emit_cstr(" = icmp eq i64 ")
                        @.emit_reg(scrutinee_reg)
                        @.emit_cstr(", ")
                        @.emit_i64(sub_val)
                        @.emit_cstr("\n")
                        @.emit_cstr("  br i1 ")
                        @.emit_reg(cmp_or)
                        @.emit_cstr(", label %arm")
                        @.emit_i64(arm_label)
                        @.emit_cstr(", label %or_next")
                        @.emit_i64(or_next)
                        @.emit_cstr("\n")
                        I k + 1 < or_pats_len {
                            @.emit_cstr("or_next")
                            @.emit_i64(or_next)
                            @.emit_cstr(":\n")
                        } E { 0 }
                    } E {
                        # Wildcard/ident in or-pattern: always matches
                        @.emit_cstr("  br label %arm")
                        @.emit_i64(arm_label)
                        @.emit_cstr("\n")
                        0
                    }
                    k = k + 1
                }
                0
            }
            E {
                # Other patterns: default to always-match
                @.emit_cstr("  br label %arm")
                @.emit_i64(arm_label)
                @.emit_cstr("\n")
            }

            # Arm body
            @.emit_cstr("arm")
            @.emit_i64(arm_label)
            @.emit_cstr(":\n")

            # Guard check: if guard fails, jump to next arm
            I guard_ptr != 0 {
                guard_result := @.generate_expr(guard_ptr)
                guard_cmp := @.fresh_reg()
                @.emit_cstr("  ")
                @.emit_reg(guard_cmp)
                @.emit_cstr(" = icmp ne i64 ")
                @.emit_reg(guard_result)
                @.emit_cstr(", 0\n")
                guard_pass_label := @.fresh_label()
                @.emit_cstr("  br i1 ")
                @.emit_reg(guard_cmp)
                @.emit_cstr(", label %guard_pass")
                @.emit_i64(guard_pass_label)
                @.emit_cstr(", label %next")
                @.emit_i64(next_label)
                @.emit_cstr("\n")
                @.emit_cstr("guard_pass")
                @.emit_i64(guard_pass_label)
                @.emit_cstr(":\n")
                0
            } E { 0 }

            arm_result := @.generate_expr(body_ptr)

            # Store result for phi
            store_i64(arm_results_ptr + i * 16, arm_label)
            store_i64(arm_results_ptr + i * 16 + 8, arm_result)

            @.emit_cstr("  br label %merge")
            @.emit_i64(merge_label)
            @.emit_cstr("\n")

            # Next label (for non-wildcard patterns, or patterns with guards)
            I i + 1 < arms_len && (pat_kind != 80 && pat_kind != 81 || guard_ptr != 0) {
                @.emit_cstr("next")
                @.emit_i64(next_label)
                @.emit_cstr(":\n")
            } E { 0 }

            i = i + 1
        }

        # Merge block with phi
        @.emit_cstr("merge")
        @.emit_i64(merge_label)
        @.emit_cstr(":\n")

        result := @.fresh_reg()
        I arms_len > 0 {
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = phi i64 ")
            j: mut i64 = 0
            L { I j >= arms_len { B }
                I j > 0 { @.emit_cstr(", ") } E { 0 }
                arm_label := load_i64(arm_results_ptr + j * 16)
                arm_result := load_i64(arm_results_ptr + j * 16 + 8)
                @.emit_cstr("[ ")
                @.emit_reg(arm_result)
                @.emit_cstr(", %arm")
                @.emit_i64(arm_label)
                @.emit_cstr(" ]")
                j = j + 1
            }
            @.emit_cstr("\n")
        } E {
            @.emit_cstr("  ")
            @.emit_reg(result)
            @.emit_cstr(" = add i64 0, 0\n")
        }

        free(arm_results_ptr)
        result
    }

    # ========== Ternary Expression ==========

    F generate_ternary(&self, expr_ptr: i64) -> i64 {
        # TERNARY: field0 = cond, field1 = then_expr, field2 = else_expr
        cond_ptr := load_i64(expr_ptr + 24)
        then_ptr := load_i64(expr_ptr + 32)
        else_ptr := load_i64(expr_ptr + 40)

        label_id := @.fresh_label()

        # Generate condition
        cond_reg := @.generate_expr(cond_ptr)

        cond_i1 := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(cond_i1)
        @.emit_cstr(" = trunc i64 ")
        @.emit_reg(cond_reg)
        @.emit_cstr(" to i1\n")

        @.emit_cstr("  br i1 ")
        @.emit_reg(cond_i1)
        @.emit_cstr(", label %tern_then")
        @.emit_i64(label_id)
        @.emit_cstr(", label %tern_else")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Then branch
        @.emit_cstr("tern_then")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        then_reg := @.generate_expr(then_ptr)
        @.emit_cstr("  br label %tern_merge")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Else branch
        @.emit_cstr("tern_else")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")
        else_reg := @.generate_expr(else_ptr)
        @.emit_cstr("  br label %tern_merge")
        @.emit_i64(label_id)
        @.emit_cstr("\n")

        # Merge with phi
        @.emit_cstr("tern_merge")
        @.emit_i64(label_id)
        @.emit_cstr(":\n")

        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = phi i64 [ ")
        @.emit_reg(then_reg)
        @.emit_cstr(", %tern_then")
        @.emit_i64(label_id)
        @.emit_cstr(" ], [ ")
        @.emit_reg(else_reg)
        @.emit_cstr(", %tern_else")
        @.emit_i64(label_id)
        @.emit_cstr(" ]\n")

        result
    }

    # ========== Method Call ==========

    # Infer the struct name_idx from a receiver expression
    # Returns -1 if cannot determine
    F infer_receiver_type(&self, expr_ptr: i64) -> i64 {
        I expr_ptr == 0 { R 0 - 1 }
        kind := load_i64(expr_ptr)

        # EXPR_IDENT = 25: look up variable's struct type
        I kind == 25 {
            name_idx := load_i64(expr_ptr + 24)
            # Check registered structs for a constructor pattern
            local_ptr := @.find_local(name_idx)
            I local_ptr != 0 {
                type_kind := load_i64(local_ptr + 24)
                # type_kind stores LLVM type, but we need struct name
                # If the variable was initialized from a struct literal or static call,
                # we can't easily determine the struct name from LLVM type alone
                0 - 1
            } E { 0 - 1 }
        }
        # EXPR_STRUCT_LIT = 40: struct name is directly available
        E I kind == 40 {
            load_i64(expr_ptr + 24)  # field0 = name_idx
        }
        # EXPR_STATIC_CALL = 35: type_idx is the struct name
        E I kind == 35 {
            load_i64(expr_ptr + 24)  # field0 = type_idx
        }
        # EXPR_SELF_CALL = 26: use current impl type
        E I kind == 26 {
            self.current_impl_type_idx
        }
        E {
            0 - 1
        }
    }

    F generate_method_call(&self, expr_ptr: i64) -> i64 {
        # METHOD_CALL: field0 = receiver, field1 = method_idx, field2 = args_ptr, field3 = args_len
        receiver_ptr := load_i64(expr_ptr + 24)
        method_idx := load_i64(expr_ptr + 32)
        args_ptr := load_i64(expr_ptr + 40)
        args_len := load_i64(expr_ptr + 48)

        # Generate receiver
        recv_reg := @.generate_expr(receiver_ptr)

        # Generate arguments
        total_args := args_len + 1  # receiver + args
        arg_regs_ptr := malloc(total_args * 8)
        store_i64(arg_regs_ptr, recv_reg)  # receiver is first arg

        i: mut i64 = 0
        L { I i >= args_len { B }
            arg_expr := load_i64(args_ptr + i * 8)
            arg_reg := @.generate_expr(arg_expr)
            store_i64(arg_regs_ptr + (i + 1) * 8, arg_reg)
            i = i + 1
        }

        # Emit call with receiver type prefix (TypeName_method)
        recv_type_idx := @.infer_receiver_type(receiver_ptr)
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @")
        I recv_type_idx != 0 - 1 {
            @.emit_string_idx(recv_type_idx)
            @.emit_cstr("_")
            0
        } E { 0 }
        @.emit_string_idx(method_idx)
        @.emit_cstr("(")

        j: mut i64 = 0
        L { I j >= total_args { B }
            I j > 0 { @.emit_cstr(", ") } E { 0 }
            @.emit_cstr("i64 ")
            arg_reg := load_i64(arg_regs_ptr + j * 8)
            @.emit_reg(arg_reg)
            j = j + 1
        }

        @.emit_cstr(")\n")
        free(arg_regs_ptr)
        result
    }

    # ========== Static Call ==========

    F generate_static_call(&self, expr_ptr: i64) -> i64 {
        # STATIC_CALL: field0 = type_idx, field1 = method_idx, field2 = args_ptr, field3 = args_len
        type_idx := load_i64(expr_ptr + 24)
        method_idx := load_i64(expr_ptr + 32)
        args_ptr := load_i64(expr_ptr + 40)
        args_len := load_i64(expr_ptr + 48)

        # Generate arguments
        arg_regs_ptr := malloc(args_len * 8)
        i: mut i64 = 0
        L { I i >= args_len { B }
            arg_expr := load_i64(args_ptr + i * 8)
            arg_reg := @.generate_expr(arg_expr)
            store_i64(arg_regs_ptr + i * 8, arg_reg)
            i = i + 1
        }

        # Emit call as TypeName_method_name (matching Rust codegen convention)
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @")
        @.emit_string_idx(type_idx)
        @.emit_cstr("_")
        @.emit_string_idx(method_idx)
        @.emit_cstr("(")

        j: mut i64 = 0
        L { I j >= args_len { B }
            I j > 0 { @.emit_cstr(", ") } E { 0 }
            @.emit_cstr("i64 ")
            arg_reg := load_i64(arg_regs_ptr + j * 8)
            @.emit_reg(arg_reg)
            j = j + 1
        }

        @.emit_cstr(")\n")
        free(arg_regs_ptr)
        result
    }

    # ========== Field Access ==========

    F generate_field_access(&self, expr_ptr: i64) -> i64 {
        # FIELD: field0 = expr_ptr, field1 = field_idx
        obj_expr := load_i64(expr_ptr + 24)
        field_idx := load_i64(expr_ptr + 32)

        # Generate object expression (should be a pointer to struct)
        obj_reg := @.generate_expr(obj_expr)

        # Look up field offset in struct info
        # For now, use field_idx as offset index (field_idx * 8)
        offset_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(offset_reg)
        @.emit_cstr(" = add i64 ")
        @.emit_reg(obj_reg)
        @.emit_cstr(", ")
        @.emit_i64(field_idx * 8)
        @.emit_cstr("\n")

        # Load the field value
        result := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(result)
        @.emit_cstr(" = call i64 @load_i64(i64 ")
        @.emit_reg(offset_reg)
        @.emit_cstr(")\n")

        result
    }

    # ========== Struct Literal ==========

    F generate_struct_lit(&self, expr_ptr: i64) -> i64 {
        # STRUCT_LIT: field0 = name_idx, field1 = fields_ptr, field2 = fields_len
        name_idx := load_i64(expr_ptr + 24)
        fields_ptr := load_i64(expr_ptr + 32)
        fields_len := load_i64(expr_ptr + 40)

        # Allocate memory for the struct (fields_len * 8 bytes)
        size := fields_len * 8
        I size == 0 { size = 8 } E { 0 }  # Minimum 8 bytes

        # Call malloc
        size_reg := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(size_reg)
        @.emit_cstr(" = add i64 0, ")
        @.emit_i64(size)
        @.emit_cstr("\n")

        raw_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" = call i8* @malloc(i64 ")
        @.emit_reg(size_reg)
        @.emit_cstr(")\n")

        struct_ptr := @.fresh_reg()
        @.emit_cstr("  ")
        @.emit_reg(struct_ptr)
        @.emit_cstr(" = ptrtoint i8* ")
        @.emit_reg(raw_ptr)
        @.emit_cstr(" to i64\n")

        # Initialize each field
        # FieldInit: name_idx (0), value_ptr (8), span_start (16), span_end (24) - size 32
        i: mut i64 = 0
        L { I i >= fields_len { B }
            field_ptr := fields_ptr + i * 32  # FieldInit.size() = 32
            value_expr := load_i64(field_ptr + 8)

            value_reg := @.generate_expr(value_expr)

            # Store at offset i * 8
            field_offset := @.fresh_reg()
            @.emit_cstr("  ")
            @.emit_reg(field_offset)
            @.emit_cstr(" = add i64 ")
            @.emit_reg(struct_ptr)
            @.emit_cstr(", ")
            @.emit_i64(i * 8)
            @.emit_cstr("\n")

            @.emit_cstr("  call void @store_i64(i64 ")
            @.emit_reg(field_offset)
            @.emit_cstr(", i64 ")
            @.emit_reg(value_reg)
            @.emit_cstr(")\n")

            i = i + 1
        }

        struct_ptr
    }

    # ========== Dead Code Elimination ==========

    # DCE optimization pass on generated LLVM IR text.
    # Removes unused variable definitions that have no side effects.
    # Two-pass algorithm:
    #   Pass 1: Collect all %N definitions and %N uses
    #   Pass 2: Remove definitions where %N is never used (side-effect-free only)
    F optimize_dce(&self) -> i64 {
        ir_data := load_i64(self.output)
        ir_len := load_i64(self.output + 8)

        I ir_len == 0 { R 1 }

        # Allocate usage tracking arrays
        # We track registers %0 .. %(reg_counter_max-1)
        # For simplicity, use a fixed max of 65536 registers
        max_regs := 65536

        # defined[i] = 1 if %i appears as definition (%i = ...)
        defined := malloc(max_regs)
        # used[i] = 1 if %i appears as a use (not as the definition target)
        used := malloc(max_regs)
        # side_effect[i] = 1 if %i = ... has side effects (call, store, etc.)
        side_effect := malloc(max_regs)

        # Zero-initialize
        i: mut i64 = 0
        L { I i >= max_regs { B }
            store_byte(defined + i, 0)
            store_byte(used + i, 0)
            store_byte(side_effect + i, 0)
            i = i + 1
        }

        # Pass 1: Scan IR line by line
        pos: mut i64 = 0
        L { I pos >= ir_len { B }
            # Find end of current line
            line_start := pos
            L { I pos >= ir_len { B }
                ch := load_byte(ir_data + pos)
                I ch == 10 { B }  # newline
                E { pos = pos + 1 }
            }
            line_len := pos - line_start

            # Skip newline
            I pos < ir_len { pos = pos + 1 } E { 0 }

            # Skip empty lines, comments, labels
            I line_len == 0 { 0 }
            E {
                @.dce_scan_line(ir_data + line_start, line_len, defined, used, side_effect, max_regs)
            }
        }

        # Pass 2: Rebuild output, removing dead definitions
        new_buf := malloc(ir_len + 1024)  # Extra space for DCE comments
        new_len: mut i64 = 0

        pos = 0
        L { I pos >= ir_len { B }
            # Find end of current line
            line_start := pos
            L { I pos >= ir_len { B }
                ch := load_byte(ir_data + pos)
                I ch == 10 { B }
                E { pos = pos + 1 }
            }
            line_len := pos - line_start

            # Skip newline
            I pos < ir_len { pos = pos + 1 } E { 0 }

            # Check if this line defines an unused register
            should_remove := @.dce_should_remove(ir_data + line_start, line_len, defined, used, side_effect, max_regs)

            I should_remove == 1 {
                # Replace with DCE comment
                dce_comment := "  ; DCE removed"
                dce_len := 15
                memcpy_str(new_buf + new_len, dce_comment, dce_len)
                new_len = new_len + dce_len
                store_byte(new_buf + new_len, 10)
                new_len = new_len + 1
            } E {
                # Copy line as-is
                I line_len > 0 {
                    memcpy(new_buf + new_len, ir_data + line_start, line_len)
                    new_len = new_len + line_len
                } E { 0 }
                store_byte(new_buf + new_len, 10)
                new_len = new_len + 1
            }
        }

        # Replace output buffer with DCE'd output
        free(ir_data)
        store_i64(self.output, new_buf)
        store_i64(self.output + 8, new_len)
        store_i64(self.output + 16, ir_len + 1024)

        # Free tracking arrays
        free(defined)
        free(used)
        free(side_effect)

        1
    }

    # Scan a single IR line to collect definitions, uses, and side effects
    F dce_scan_line(&self, line_ptr: i64, line_len: i64, defined: i64, used: i64, side_effect: i64, max_regs: i64) -> i64 {
        # Skip leading whitespace
        start: mut i64 = 0
        L { I start >= line_len { B }
            ch := load_byte(line_ptr + start)
            I ch == 32 || ch == 9 { start = start + 1 } E { B }
        }
        I start >= line_len { R 0 }

        first_ch := load_byte(line_ptr + start)

        # Skip comments (;) and labels (line ending with :)
        I first_ch == 59 { R 0 }  # ';'
        last_ch := load_byte(line_ptr + line_len - 1)
        I last_ch == 58 { R 0 }  # ':'

        # Check if line is a definition: %N = ...
        # Find the pattern: %<digits> = or %<name> =
        def_reg := @.dce_extract_def_reg(line_ptr, line_len, start)

        I def_reg >= 0 && def_reg < max_regs {
            store_byte(defined + def_reg, 1)

            # Check for side effects in the definition RHS
            has_side := @.dce_has_side_effect(line_ptr, line_len)
            I has_side == 1 {
                store_byte(side_effect + def_reg, 1)
            } E { 0 }

            # Scan for used registers in the RHS (after " = ")
            eq_pos := @.dce_find_equals(line_ptr, line_len)
            I eq_pos > 0 {
                @.dce_scan_uses(line_ptr + eq_pos, line_len - eq_pos, used, max_regs)
            } E { 0 }
        } E {
            # Not a definition line - all %N references are uses
            # This covers: ret, br, store, call without result, etc.
            @.dce_scan_uses(line_ptr, line_len, used, max_regs)
        }

        1
    }

    # Extract definition register number from a line like "  %5 = add i64 ..."
    # Returns register number or -1 if not a definition
    F dce_extract_def_reg(&self, line_ptr: i64, line_len: i64, start: i64) -> i64 {
        I start >= line_len { R 0 - 1 }

        ch := load_byte(line_ptr + start)
        I ch != 37 { R 0 - 1 }  # Not '%'

        # Read digits after %
        pos: mut i64 = start + 1
        num: mut i64 = 0
        has_digit: mut i64 = 0

        L { I pos >= line_len { B }
            d := load_byte(line_ptr + pos)
            I d >= 48 && d <= 57 {
                num = num * 10 + (d - 48)
                has_digit = 1
                pos = pos + 1
            } E { B }
        }

        I has_digit == 0 { R 0 - 1 }

        # Check that next chars are " = "
        I pos + 3 <= line_len {
            c1 := load_byte(line_ptr + pos)
            c2 := load_byte(line_ptr + pos + 1)
            c3 := load_byte(line_ptr + pos + 2)
            I c1 == 32 && c2 == 61 && c3 == 32 {
                num
            } E { 0 - 1 }
        } E { 0 - 1 }
    }

    # Find the position of " = " in a line, returns position after " = " or -1
    F dce_find_equals(&self, line_ptr: i64, line_len: i64) -> i64 {
        i: mut i64 = 0
        L { I i + 2 >= line_len { B }
            c1 := load_byte(line_ptr + i)
            c2 := load_byte(line_ptr + i + 1)
            c3 := load_byte(line_ptr + i + 2)
            I c1 == 32 && c2 == 61 && c3 == 32 {
                R i + 3
            }
            i = i + 1
        }
        0 - 1
    }

    # Check if line contains a side-effectful instruction
    # Side effects: call, invoke (function calls have side effects)
    F dce_has_side_effect(&self, line_ptr: i64, line_len: i64) -> i64 {
        # Find the RHS after " = "
        eq_pos := @.dce_find_equals(line_ptr, line_len)
        rhs_start := I eq_pos > 0 { eq_pos } E { 0 }
        rhs_ptr := line_ptr + rhs_start
        rhs_len := line_len - rhs_start

        # Check for "call " (bytes: 99 97 108 108 32)
        I @.dce_contains_5bytes(rhs_ptr, rhs_len, 99, 97, 108, 108, 32) == 1 { R 1 }
        # Check for "invoke " - just check "invok" (105 110 118 111 107)
        I @.dce_contains_5bytes(rhs_ptr, rhs_len, 105, 110, 118, 111, 107) == 1 { R 1 }
        0
    }

    # Check if a region contains 5 consecutive bytes matching the given values
    F dce_contains_5bytes(&self, data: i64, data_len: i64, b0: i64, b1: i64, b2: i64, b3: i64, b4: i64) -> i64 {
        I data_len < 5 { R 0 }
        i: mut i64 = 0
        L { I i + 5 > data_len { B }
            c0 := load_byte(data + i)
            I c0 == b0 {
                c1 := load_byte(data + i + 1)
                c2 := load_byte(data + i + 2)
                c3 := load_byte(data + i + 3)
                c4 := load_byte(data + i + 4)
                I c1 == b1 && c2 == b2 && c3 == b3 && c4 == b4 { R 1 }
            }
            i = i + 1
        }
        0
    }

    # Scan a region for %N register uses and mark them
    F dce_scan_uses(&self, data: i64, data_len: i64, used: i64, max_regs: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= data_len { B }
            ch := load_byte(data + i)
            I ch == 37 {
                # Found '%', try to read register number
                j: mut i64 = i + 1
                num: mut i64 = 0
                has_digit: mut i64 = 0
                L { I j >= data_len { B }
                    d := load_byte(data + j)
                    I d >= 48 && d <= 57 {
                        num = num * 10 + (d - 48)
                        has_digit = 1
                        j = j + 1
                    } E { B }
                }
                I has_digit == 1 && num < max_regs {
                    store_byte(used + num, 1)
                } E { 0 }
                i = j
            } E {
                i = i + 1
            }
        }
        1
    }

    # Determine if a line should be removed by DCE
    F dce_should_remove(&self, line_ptr: i64, line_len: i64, defined: i64, used: i64, side_effect: i64, max_regs: i64) -> i64 {
        # Skip leading whitespace
        start: mut i64 = 0
        L { I start >= line_len { B }
            ch := load_byte(line_ptr + start)
            I ch == 32 || ch == 9 { start = start + 1 } E { B }
        }
        I start >= line_len { R 0 }

        # Extract definition register
        def_reg := @.dce_extract_def_reg(line_ptr, line_len, start)
        I def_reg < 0 || def_reg >= max_regs { R 0 }

        # Check: is it defined but not used, and has no side effects?
        is_defined := load_byte(defined + def_reg)
        is_used := load_byte(used + def_reg)
        has_side := load_byte(side_effect + def_reg)

        I is_defined == 1 && is_used == 0 && has_side == 0 { 1 }
        E { 0 }
    }

    # ========== Basic Inlining ==========

    # Simple inlining pass: inline small, pure functions (10 instructions, no calls)
    # Works on the generated LLVM IR text after DCE.
    # Strategy:
    #   1. Scan for small function definitions (define ... { ... })
    #   2. Record candidates: name, param count, body lines, return value pattern
    #   3. Replace call sites with inlined body
    #
    # For bootstrapping simplicity, only handles:
    #   - Functions with all i64 params/return (the common case in selfhost)
    #   - Numeric register names (%0, %1, etc.)
    #   - Single-return functions
    #
    # InlineCandidate storage (per candidate, 56 bytes):
    #   offset 0:  name_ptr (i64)       - pointer to function name string
    #   offset 8:  name_len (i64)       - length of function name
    #   offset 16: param_count (i64)    - number of parameters
    #   offset 24: body_ptr (i64)       - pointer to body text
    #   offset 32: body_len (i64)       - length of body text
    #   offset 40: ret_type (i64)       - 0=void, 1=i64
    #   offset 48: max_reg (i64)        - highest register number used in body

    F optimize_inline(&self) -> i64 {
        ir_data := load_i64(self.output)
        ir_len := load_i64(self.output + 8)
        I ir_len == 0 { R 1 }

        # Find inline candidates
        max_candidates := 256
        candidates := malloc(max_candidates * 56)
        num_candidates: mut i64 = 0

        @.inline_find_candidates(ir_data, ir_len, candidates, &num_candidates, max_candidates)

        I num_candidates == 0 {
            free(candidates)
            R 1
        }

        # Apply inlining for each candidate
        cur_data: mut i64 = ir_data
        cur_len: mut i64 = ir_len
        inline_counter: mut i64 = 0

        ci: mut i64 = 0
        L { I ci >= num_candidates { B }
            cand_ptr := candidates + ci * 56
            new_data := @.inline_apply_candidate(cur_data, cur_len, cand_ptr, &inline_counter)

            I new_data != 0 {
                new_len := load_i64(new_data + 8)  # stored at offset 8 by inline_apply
                new_buf := load_i64(new_data)       # stored at offset 0
                I cur_data != ir_data {
                    free(cur_data)
                } E { 0 }
                cur_data = new_buf
                cur_len = new_len
                free(new_data)
            } E { 0 }

            ci = ci + 1
        }

        # Update output if any inlining happened
        I cur_data != ir_data {
            free(ir_data)
            store_i64(self.output, cur_data)
            store_i64(self.output + 8, cur_len)
        } E { 0 }

        # Free candidate body buffers
        ci = 0
        L { I ci >= num_candidates { B }
            cand_ptr := candidates + ci * 56
            body_ptr := load_i64(cand_ptr + 24)
            I body_ptr != 0 { free(body_ptr) } E { 0 }
            name_ptr := load_i64(cand_ptr)
            I name_ptr != 0 { free(name_ptr) } E { 0 }
            ci = ci + 1
        }
        free(candidates)

        1
    }

    # Find small functions that are candidates for inlining
    F inline_find_candidates(&self, ir_data: i64, ir_len: i64, candidates: i64, num_ptr: i64, max_cand: i64) -> i64 {
        pos: mut i64 = 0

        L { I pos >= ir_len { B }
            # Find line start/end
            line_start := pos
            L { I pos >= ir_len { B }
                ch := load_byte(ir_data + pos)
                I ch == 10 { B } E { pos = pos + 1 }
            }
            line_len := pos - line_start
            I pos < ir_len { pos = pos + 1 } E { 0 }

            # Check if line starts with "define " (100 101 102 105 110 101 32)
            I line_len > 8 {
                I @.dce_contains_5bytes(ir_data + line_start, line_len, 100, 101, 102, 105, 110) == 1 {
                    # This is a "defin..." line, verify "define "
                    c5 := load_byte(ir_data + line_start + 5)
                    c6 := load_byte(ir_data + line_start + 6)
                    I c5 == 101 && c6 == 32 {
                        # "define " found - try to parse as inline candidate
                        num := load_i64(num_ptr)
                        I num < max_cand {
                            cand_ptr := candidates + num * 56
                            result := @.inline_parse_function(ir_data, ir_len, line_start, cand_ptr)
                            I result == 1 {
                                store_i64(num_ptr, num + 1)
                            } E { 0 }
                        } E { 0 }
                    } E { 0 }
                } E { 0 }
            } E { 0 }
        }
        1
    }

    # Parse a function definition and decide if it's an inline candidate
    # Returns 1 if candidate was stored, 0 if not eligible
    F inline_parse_function(&self, ir_data: i64, ir_len: i64, def_start: i64, cand_ptr: i64) -> i64 {
        # Find the function name: look for '@' then read until '('
        pos: mut i64 = def_start
        L { I pos >= ir_len { B }
            ch := load_byte(ir_data + pos)
            I ch == 64 { B }  # '@'
            E { pos = pos + 1 }
        }
        I pos >= ir_len { R 0 }

        name_start := pos + 1  # skip '@'
        L { I pos >= ir_len { B }
            ch := load_byte(ir_data + pos)
            I ch == 40 { B }  # '('
            E { pos = pos + 1 }
        }
        I pos >= ir_len { R 0 }
        name_end := pos
        name_len := name_end - name_start

        # Skip main, __internal, __lambda functions
        I name_len >= 4 {
            c0 := load_byte(ir_data + name_start)
            c1 := load_byte(ir_data + name_start + 1)
            # Skip "main"
            I c0 == 109 && c1 == 97 && name_len == 4 { R 0 }
            # Skip "__" prefix (internal/lambda)
            I c0 == 95 && c1 == 95 { R 0 }
        } E { 0 }

        # Count parameters (count commas + 1 if non-empty, 0 if empty)
        paren_start := pos  # position of '('
        paren_depth: mut i64 = 1
        pos = pos + 1
        param_count: mut i64 = 0
        has_params: mut i64 = 0

        L { I pos >= ir_len || paren_depth == 0 { B }
            ch := load_byte(ir_data + pos)
            I ch == 40 { paren_depth = paren_depth + 1 }
            E I ch == 41 { paren_depth = paren_depth - 1 }
            E I ch == 44 && paren_depth == 1 { param_count = param_count + 1 }
            E I ch != 32 && ch != 41 && paren_depth == 1 { has_params = 1 }
            pos = pos + 1
        }
        I has_params == 1 { param_count = param_count + 1 } E { 0 }

        # Find opening '{' and then scan body lines until '}'
        L { I pos >= ir_len { B }
            ch := load_byte(ir_data + pos)
            I ch == 123 { B }  # '{'
            E { pos = pos + 1 }
        }
        I pos >= ir_len { R 0 }
        pos = pos + 1  # skip '{'

        # Skip to next line
        L { I pos >= ir_len { B }
            ch := load_byte(ir_data + pos)
            I ch == 10 { pos = pos + 1; B } E { pos = pos + 1 }
        }

        # Collect body lines and count instructions
        body_start := pos
        instruction_count: mut i64 = 0
        has_call: mut i64 = 0
        is_recursive: mut i64 = 0
        max_reg: mut i64 = 0
        ret_type: mut i64 = 0  # 0=void, 1=i64

        L { I pos >= ir_len { B }
            ls := pos
            L { I pos >= ir_len { B }
                ch := load_byte(ir_data + pos)
                I ch == 10 { B } E { pos = pos + 1 }
            }
            ll := pos - ls
            I pos < ir_len { pos = pos + 1 } E { 0 }

            # Check for closing '}'
            I ll >= 1 {
                fc := load_byte(ir_data + ls)
                I fc == 125 { B }  # '}'
            } E { 0 }

            # Skip labels and empty lines
            I ll == 0 { 0 }
            E {
                # Skip leading whitespace
                ws: mut i64 = 0
                L { I ws >= ll { B }
                    wc := load_byte(ir_data + ls + ws)
                    I wc == 32 || wc == 9 { ws = ws + 1 } E { B }
                }

                I ws < ll {
                    tc := load_byte(ir_data + ls + ws)
                    lc := load_byte(ir_data + ls + ll - 1)

                    # Skip comments and labels
                    I tc == 59 || lc == 58 { 0 }
                    E {
                        instruction_count = instruction_count + 1

                        # Check for call instructions
                        I @.dce_contains_5bytes(ir_data + ls + ws, ll - ws, 99, 97, 108, 108, 32) == 1 {
                            has_call = 1
                            # Check if recursive (calls own function name)
                            I @.inline_contains_name(ir_data + ls, ll, ir_data + name_start, name_len) == 1 {
                                is_recursive = 1
                            } E { 0 }
                        } E { 0 }

                        # Track max register number
                        @.inline_scan_max_reg(ir_data + ls, ll, &max_reg)

                        # Check for non-void return
                        # "ret i64"  bytes 114 101 116 32 105 54 52
                        I @.dce_contains_5bytes(ir_data + ls + ws, ll - ws, 114, 101, 116, 32, 105) == 1 {
                            ret_type = 1
                        } E { 0 }
                    }
                } E { 0 }
            }
        }

        body_end := pos
        # Adjust body_end to exclude the '}' line
        body_len := body_end - body_start

        # Filter: only inline small, non-recursive, call-free functions
        I instruction_count > 10 || instruction_count == 0 { R 0 }
        I is_recursive == 1 { R 0 }
        I has_call == 1 { R 0 }

        # Store candidate
        name_copy := malloc(name_len)
        memcpy(name_copy, ir_data + name_start, name_len)
        store_i64(cand_ptr, name_copy)
        store_i64(cand_ptr + 8, name_len)
        store_i64(cand_ptr + 16, param_count)

        body_copy := malloc(body_len)
        memcpy(body_copy, ir_data + body_start, body_len)
        store_i64(cand_ptr + 24, body_copy)
        store_i64(cand_ptr + 32, body_len)
        store_i64(cand_ptr + 40, ret_type)
        store_i64(cand_ptr + 48, max_reg)

        1
    }

    # Check if a region contains a function name (after '@')
    F inline_contains_name(&self, data: i64, data_len: i64, name_ptr: i64, name_len: i64) -> i64 {
        I data_len < name_len + 1 { R 0 }
        i: mut i64 = 0
        L { I i + name_len + 1 > data_len { B }
            ch := load_byte(data + i)
            I ch == 64 {
                # Found '@', compare name
                match_ok: mut i64 = 1
                j: mut i64 = 0
                L { I j >= name_len { B }
                    c1 := load_byte(data + i + 1 + j)
                    c2 := load_byte(name_ptr + j)
                    I c1 != c2 { match_ok = 0; B }
                    j = j + 1
                }
                I match_ok == 1 {
                    # Verify name ends (next char is '(' or non-alphanumeric)
                    I i + 1 + name_len < data_len {
                        nc := load_byte(data + i + 1 + name_len)
                        I nc == 40 { R 1 }  # '('
                    } E { R 1 }
                } E { 0 }
            } E { 0 }
            i = i + 1
        }
        0
    }

    # Scan a line for register numbers and track the maximum
    F inline_scan_max_reg(&self, data: i64, data_len: i64, max_ptr: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= data_len { B }
            ch := load_byte(data + i)
            I ch == 37 {
                j: mut i64 = i + 1
                num: mut i64 = 0
                has_digit: mut i64 = 0
                L { I j >= data_len { B }
                    d := load_byte(data + j)
                    I d >= 48 && d <= 57 {
                        num = num * 10 + (d - 48)
                        has_digit = 1
                        j = j + 1
                    } E { B }
                }
                I has_digit == 1 {
                    cur_max := load_i64(max_ptr)
                    I num > cur_max { store_i64(max_ptr, num) } E { 0 }
                } E { 0 }
                i = j
            } E {
                i = i + 1
            }
        }
        1
    }

    # Apply inlining for one candidate across the IR
    # Returns pointer to (buf_ptr, buf_len) struct or 0 if no changes
    F inline_apply_candidate(&self, ir_data: i64, ir_len: i64, cand_ptr: i64, counter_ptr: i64) -> i64 {
        cand_name := load_i64(cand_ptr)
        cand_name_len := load_i64(cand_ptr + 8)
        cand_params := load_i64(cand_ptr + 16)
        cand_body := load_i64(cand_ptr + 24)
        cand_body_len := load_i64(cand_ptr + 32)
        cand_ret := load_i64(cand_ptr + 40)
        cand_max_reg := load_i64(cand_ptr + 48)

        # Build the call pattern: "call i64 @funcname("
        # We only handle i64 return for now
        I cand_ret != 1 { R 0 }

        # Scan for call sites
        new_buf := malloc(ir_len * 2)  # Generous allocation
        new_len: mut i64 = 0
        did_inline: mut i64 = 0

        pos: mut i64 = 0
        L { I pos >= ir_len { B }
            line_start := pos
            L { I pos >= ir_len { B }
                ch := load_byte(ir_data + pos)
                I ch == 10 { B } E { pos = pos + 1 }
            }
            line_len := pos - line_start
            I pos < ir_len { pos = pos + 1 } E { 0 }

            # Check if this line calls our candidate
            # Pattern: "call i64 @name("
            call_pos := @.inline_find_call(ir_data + line_start, line_len, cand_name, cand_name_len)

            I call_pos >= 0 {
                # Found a call site - inline it
                counter := load_i64(counter_ptr)
                store_i64(counter_ptr, counter + 1)

                # Extract destination register (before " = call")
                dest_reg := @.dce_extract_def_reg(ir_data + line_start, line_len, 0)

                # Skip whitespace at beginning
                ws: mut i64 = 0
                L { I ws >= line_len { B }
                    wc := load_byte(ir_data + line_start + ws)
                    I wc == 32 || wc == 9 { ws = ws + 1 } E { B }
                }

                # Extract call arguments
                # Find '(' after function name
                arg_start: mut i64 = call_pos + cand_name_len + 1  # +1 for '@' skipped
                L { I arg_start >= line_len { B }
                    ac := load_byte(ir_data + line_start + arg_start)
                    I ac == 40 { arg_start = arg_start + 1; B }  # '('
                    E { arg_start = arg_start + 1 }
                }

                # Parse argument values (comma-separated, each has "i64 %N" or "i64 N")
                arg_values := malloc(cand_params * 8)
                @.inline_parse_args(ir_data + line_start + arg_start, line_len - arg_start, arg_values, cand_params)

                # Emit inlined body
                # Comment
                memcpy_str(new_buf + new_len, "  ; BEGIN INLINE\n", 17)
                new_len = new_len + 17

                # Inline body with register offset
                reg_offset := counter * (cand_max_reg + 1) + 100000
                @.inline_emit_body(new_buf, &new_len, cand_body, cand_body_len, arg_values, cand_params, reg_offset, dest_reg, cand_ret)

                # End comment
                memcpy_str(new_buf + new_len, "  ; END INLINE\n", 15)
                new_len = new_len + 15

                free(arg_values)
                did_inline = 1
            } E {
                # Copy line as-is
                I line_len > 0 {
                    memcpy(new_buf + new_len, ir_data + line_start, line_len)
                    new_len = new_len + line_len
                } E { 0 }
                store_byte(new_buf + new_len, 10)
                new_len = new_len + 1
            }
        }

        I did_inline == 1 {
            result := malloc(16)
            store_i64(result, new_buf)
            store_i64(result + 8, new_len)
            result
        } E {
            free(new_buf)
            0
        }
    }

    # Find "call i64 @name(" in a line, returns position of "call" or -1
    F inline_find_call(&self, line: i64, line_len: i64, name: i64, name_len: i64) -> i64 {
        # Look for "call i64 @" (99 97 108 108 32 105 54 52 32 64)
        I line_len < 10 + name_len { R 0 - 1 }
        i: mut i64 = 0
        L { I i + 10 + name_len > line_len { B }
            # Check "call " prefix
            I @.dce_contains_5bytes(line + i, line_len - i, 99, 97, 108, 108, 32) == 1 {
                # Check "i64 @" after "call "
                c5 := load_byte(line + i + 5)
                c6 := load_byte(line + i + 6)
                c7 := load_byte(line + i + 7)
                c8 := load_byte(line + i + 8)
                c9 := load_byte(line + i + 9)
                I c5 == 105 && c6 == 54 && c7 == 52 && c8 == 32 && c9 == 64 {
                    # Verify function name matches
                    match_ok: mut i64 = 1
                    j: mut i64 = 0
                    L { I j >= name_len { B }
                        nc := load_byte(line + i + 10 + j)
                        ec := load_byte(name + j)
                        I nc != ec { match_ok = 0; B }
                        j = j + 1
                    }
                    I match_ok == 1 {
                        # Verify followed by '('
                        I i + 10 + name_len < line_len {
                            pc := load_byte(line + i + 10 + name_len)
                            I pc == 40 { R i }
                        } E { 0 }
                    } E { 0 }
                } E { 0 }
            } E { 0 }
            i = i + 1
        }
        0 - 1
    }

    # Parse call arguments into an array of register numbers
    # Each arg is "i64 %N" or "i64 N" format
    F inline_parse_args(&self, data: i64, data_len: i64, arg_values: i64, max_args: i64) -> i64 {
        arg_idx: mut i64 = 0
        i: mut i64 = 0

        L { I i >= data_len || arg_idx >= max_args { B }
            ch := load_byte(data + i)

            # Find '%' to read register number
            I ch == 37 {
                j: mut i64 = i + 1
                num: mut i64 = 0
                has_digit: mut i64 = 0
                L { I j >= data_len { B }
                    d := load_byte(data + j)
                    I d >= 48 && d <= 57 {
                        num = num * 10 + (d - 48)
                        has_digit = 1
                        j = j + 1
                    } E { B }
                }
                I has_digit == 1 {
                    store_i64(arg_values + arg_idx * 8, num)
                    arg_idx = arg_idx + 1
                } E { 0 }
                i = j
            }
            # Handle named parameters (%name) - skip for now, only numeric
            E I ch == 41 { B }  # ')' end of args
            E { i = i + 1 }
        }
        arg_idx
    }

    # Emit inlined function body with register renaming
    F inline_emit_body(&self, out: i64, out_len_ptr: i64, body: i64, body_len: i64, arg_values: i64, param_count: i64, reg_offset: i64, dest_reg: i64, ret_type: i64) -> i64 {
        out_len: mut i64 = load_i64(out_len_ptr)
        pos: mut i64 = 0

        L { I pos >= body_len { B }
            line_start := pos
            L { I pos >= body_len { B }
                ch := load_byte(body + pos)
                I ch == 10 { B } E { pos = pos + 1 }
            }
            line_len := pos - line_start
            I pos < body_len { pos = pos + 1 } E { 0 }

            # Skip empty lines and labels
            I line_len == 0 { 0 }
            E {
                # Skip whitespace
                ws: mut i64 = 0
                L { I ws >= line_len { B }
                    wc := load_byte(body + line_start + ws)
                    I wc == 32 || wc == 9 { ws = ws + 1 } E { B }
                }

                I ws >= line_len { 0 }
                E {
                    fc := load_byte(body + line_start + ws)
                    lc := load_byte(body + line_start + line_len - 1)

                    # Skip comments and labels
                    I fc == 59 || lc == 58 { 0 }
                    # Handle return: "ret i64 %N"  "%dest = add i64 0, %N_renamed"
                    E I @.dce_contains_5bytes(body + line_start + ws, line_len - ws, 114, 101, 116, 32, 105) == 1 {
                        # Extract return value register
                        ret_val := @.inline_extract_ret_value(body + line_start + ws, line_len - ws)
                        I dest_reg >= 0 && ret_type == 1 {
                            # Map the return value (apply register offset)
                            mapped_val := I ret_val >= 0 && ret_val < param_count {
                                load_i64(arg_values + ret_val * 8)
                            } E I ret_val >= 0 {
                                ret_val + reg_offset
                            } E { ret_val }

                            memcpy_str(out + out_len, "  %", 3)
                            out_len = out_len + 3
                            out_len = out_len + @.inline_write_i64(out + out_len, dest_reg)
                            memcpy_str(out + out_len, " = add i64 0, %", 15)
                            out_len = out_len + 15
                            out_len = out_len + @.inline_write_i64(out + out_len, mapped_val)
                            memcpy_str(out + out_len, " ; inlined ret\n", 15)
                            out_len = out_len + 15
                        } E { 0 }
                    }
                    # Regular instruction: copy with register renaming
                    E {
                        memcpy_str(out + out_len, "  ", 2)
                        out_len = out_len + 2
                        # Copy line byte by byte, renaming %N to %(N+offset) or to arg value
                        bi: mut i64 = ws
                        L { I bi >= line_len { B }
                            bc := load_byte(body + line_start + bi)
                            I bc == 37 {
                                # Read register number
                                bj: mut i64 = bi + 1
                                rnum: mut i64 = 0
                                rdig: mut i64 = 0
                                L { I bj >= line_len { B }
                                    rd := load_byte(body + line_start + bj)
                                    I rd >= 48 && rd <= 57 {
                                        rnum = rnum * 10 + (rd - 48)
                                        rdig = 1
                                        bj = bj + 1
                                    } E { B }
                                }
                                I rdig == 1 {
                                    # Map register: param regs  arg values, others  offset
                                    mapped := I rnum < param_count {
                                        load_i64(arg_values + rnum * 8)
                                    } E {
                                        rnum + reg_offset
                                    }
                                    store_byte(out + out_len, 37)  # '%'
                                    out_len = out_len + 1
                                    out_len = out_len + @.inline_write_i64(out + out_len, mapped)
                                } E {
                                    # Not a numeric reg, copy '%' and continue
                                    store_byte(out + out_len, 37)
                                    out_len = out_len + 1
                                }
                                bi = bj
                            } E {
                                store_byte(out + out_len, bc)
                                out_len = out_len + 1
                                bi = bi + 1
                            }
                        }
                        store_byte(out + out_len, 10)
                        out_len = out_len + 1
                    }
                }
            }
        }

        store_i64(out_len_ptr, out_len)
        1
    }

    # Extract return value register number from "ret i64 %N"
    F inline_extract_ret_value(&self, data: i64, data_len: i64) -> i64 {
        # Find '%'
        i: mut i64 = 0
        L { I i >= data_len { B }
            ch := load_byte(data + i)
            I ch == 37 {
                j: mut i64 = i + 1
                num: mut i64 = 0
                has_digit: mut i64 = 0
                L { I j >= data_len { B }
                    d := load_byte(data + j)
                    I d >= 48 && d <= 57 {
                        num = num * 10 + (d - 48)
                        has_digit = 1
                        j = j + 1
                    } E { B }
                }
                I has_digit == 1 { R num }
            }
            i = i + 1
        }
        0 - 1  # No register found (might be a literal)
    }

    # Write i64 as decimal to buffer, return bytes written
    F inline_write_i64(&self, out: i64, value: i64) -> i64 {
        I value < 0 {
            store_byte(out, 45)  # '-'
            1 + @.inline_write_i64(out + 1, 0 - value)
        } E I value == 0 {
            store_byte(out, 48)  # '0'
            1
        } E {
            # Count digits
            len := @.inline_write_positive(out, value, 0)
            len
        }
    }

    F inline_write_positive(&self, out: i64, value: i64, depth: i64) -> i64 {
        I value == 0 { R depth }
        written := @.inline_write_positive(out, value / 10, depth + 1)
        digit := (value % 10) + 48
        pos := written - depth - 1
        store_byte(out + pos, digit)
        written
    }

    # ========== Output ==========

    F get_output(&self) -> i64 = load_i64(self.output)
    F get_output_len(&self) -> i64 = load_i64(self.output + 8)

    F drop(&self) -> i64 {
        # Free output buffer
        buf_data := load_i64(self.output)
        free(buf_data)
        free(self.output)

        # Free temp buffer
        temp_data := load_i64(self.temp_buf)
        free(temp_data)
        free(self.temp_buf)

        # Free lambda buffer
        lambda_data := load_i64(self.lambda_buf)
        free(lambda_data)
        free(self.lambda_buf)

        # Free other allocations
        free(self.functions_ptr)
        free(self.structs_ptr)
        free(self.locals_ptr)
        free(self.loop_stack_ptr)
        free(self.strings_ptr)

        # Free monomorphization allocations
        free(self.generic_fns_ptr)
        free(self.mono_entries_ptr)
        free(self.mono_bind_keys_ptr)
        free(self.mono_bind_values_ptr)

        1
    }
}

# ============================================================================
# Test function (renamed from main to allow module import)
# ============================================================================

F test_codegen_main() -> i64 {
    puts("Code generator module loaded")

    # Test StringBuffer
    buf := StringBuffer.new(64)
    buf.append_cstr("Hello, ")
    buf.append_cstr("World!")
    I buf.len == 13 {
        puts("StringBuffer append: OK")
    } E {
        puts("StringBuffer append: FAIL")
    }

    buf.append_i64(42)
    I buf.len == 15 {
        puts("StringBuffer append_i64: OK")
    } E {
        puts("StringBuffer append_i64: FAIL")
    }

    buf.drop()

    # Test CodeGenerator creation
    gen := CodeGenerator.new()
    I gen.functions_cap == 128 {
        puts("CodeGenerator creation: OK")
    } E {
        puts("CodeGenerator creation: FAIL")
    }

    # Test register generation
    reg1 := gen.fresh_reg()
    reg2 := gen.fresh_reg()
    I reg1 == 0 && reg2 == 1 {
        puts("Register generation: OK")
    } E {
        puts("Register generation: FAIL")
    }

    # Test label generation
    label1 := gen.fresh_label()
    label2 := gen.fresh_label()
    I label1 == 0 && label2 == 1 {
        puts("Label generation: OK")
    } E {
        puts("Label generation: FAIL")
    }

    # Test local variable management
    gen.add_local(0, 0, 0, LLVM_I64(), 1)
    found := gen.find_local(0)
    I found != 0 {
        puts("Local variable: OK")
    } E {
        puts("Local variable: FAIL")
    }

    # Test type conversion
    I gen.resolved_type_to_llvm(4) == LLVM_I64() {
        puts("Type conversion i64: OK")
    } E {
        puts("Type conversion i64: FAIL")
    }

    I gen.resolved_type_to_llvm(13) == LLVM_I1() {
        puts("Type conversion bool: OK")
    } E {
        puts("Type conversion bool: FAIL")
    }

    gen.drop()

    puts("All code generator tests passed!")
    0
}
