# Vais Self-Hosting Compiler - MIR Vectorization & Layout Tests
# Tests for mir_vectorize.vais and mir_layout.vais modules.
#
# Test coverage:
#   - VectorizeContext creation and configuration
#   - Dependence analysis (vectorization blockers)
#   - MemoryAccess structure creation
#   - StructLayout calculation (offsets, padding, alignment)
#   - Field reordering suggestions
#   - Alignment helper functions

U mir
U mir_vectorize
U mir_layout
U mir_analysis

# ============================================================================
# Vectorization Tests
# ============================================================================

# Test 1: VectorizeContext creation
F test_vec_ctx_creation() -> i64 {
    print_str("Test 1: VectorizeContext creation... ")

    # Create context with AVX2 width (256 bits)
    ctx := vectorize_ctx_new(VEC_WIDTH_AVX2())

    # Verify target_width field (offset 16)
    target_width := load_i64(ctx + 16)
    I target_width != 256 {
        print_str("FAIL: target_width is ")
        print_i64(target_width)
        print_str(", expected 256\n")
        vectorize_ctx_free(ctx)
        R 0
    } E { 0 }

    # Verify candidates_len field (offset 8) is initially 0
    candidates_len := load_i64(ctx + 8)
    I candidates_len != 0 {
        print_str("FAIL: candidates_len is ")
        print_i64(candidates_len)
        print_str(", expected 0\n")
        vectorize_ctx_free(ctx)
        R 0
    } E { 0 }

    # Verify loop_id_counter field (offset 24) is initially 0
    loop_id_counter := load_i64(ctx + 24)
    I loop_id_counter != 0 {
        print_str("FAIL: loop_id_counter is ")
        print_i64(loop_id_counter)
        print_str(", expected 0\n")
        vectorize_ctx_free(ctx)
        R 0
    } E { 0 }

    vectorize_ctx_free(ctx)
    print_str("PASS\n")
    R 1
}

# Test 2: Dependence prevents vectorization
F test_dep_prevents_vectorization() -> i64 {
    print_str("Test 2: Dependence prevents vectorization... ")

    # DEP_NONE should not prevent vectorization
    vector_lanes := 4
    prevents := vec_dep_prevents_vectorization(DEP_NONE(), vector_lanes)
    I prevents != 0 {
        print_str("FAIL: DEP_NONE should not prevent vectorization\n")
        R 0
    } E { 0 }

    # DEP_UNKNOWN should prevent vectorization
    prevents = vec_dep_prevents_vectorization(DEP_UNKNOWN(), vector_lanes)
    I prevents != 1 {
        print_str("FAIL: DEP_UNKNOWN should prevent vectorization\n")
        R 0
    } E { 0 }

    # DEP_FLOW should prevent vectorization (conservative)
    prevents = vec_dep_prevents_vectorization(DEP_FLOW(), vector_lanes)
    I prevents != 1 {
        print_str("FAIL: DEP_FLOW should prevent vectorization\n")
        R 0
    } E { 0 }

    # DEP_ANTI should prevent vectorization
    prevents = vec_dep_prevents_vectorization(DEP_ANTI(), vector_lanes)
    I prevents != 1 {
        print_str("FAIL: DEP_ANTI should prevent vectorization\n")
        R 0
    } E { 0 }

    # DEP_OUTPUT should prevent vectorization
    prevents = vec_dep_prevents_vectorization(DEP_OUTPUT(), vector_lanes)
    I prevents != 1 {
        print_str("FAIL: DEP_OUTPUT should prevent vectorization\n")
        R 0
    } E { 0 }

    print_str("PASS\n")
    R 1
}

# Test 3: MemoryAccess creation
F test_mem_access_creation() -> i64 {
    print_str("Test 3: MemoryAccess creation... ")

    # Create memory access: base_local=2, index_local=3, stride=1, is_write=0, element_size=8, block_idx=5
    base_local := 2
    index_local := 3
    stride := 1
    is_write := 0
    element_size := 8
    block_idx := 5

    access := mem_access_new(base_local, index_local, stride, is_write, element_size, block_idx)

    # Verify all fields (MemoryAccess: 48 bytes)
    # base_local(0): i64
    actual_base := load_i64(access)
    I actual_base != base_local {
        print_str("FAIL: base_local is ")
        print_i64(actual_base)
        print_str(", expected ")
        print_i64(base_local)
        print_str("\n")
        mem_access_free(access)
        R 0
    } E { 0 }

    # index_local(8): i64
    actual_index := load_i64(access + 8)
    I actual_index != index_local {
        print_str("FAIL: index_local is ")
        print_i64(actual_index)
        print_str(", expected ")
        print_i64(index_local)
        print_str("\n")
        mem_access_free(access)
        R 0
    } E { 0 }

    # stride(16): i64
    actual_stride := load_i64(access + 16)
    I actual_stride != stride {
        print_str("FAIL: stride is ")
        print_i64(actual_stride)
        print_str(", expected ")
        print_i64(stride)
        print_str("\n")
        mem_access_free(access)
        R 0
    } E { 0 }

    # is_write(24): i64
    actual_is_write := load_i64(access + 24)
    I actual_is_write != is_write {
        print_str("FAIL: is_write is ")
        print_i64(actual_is_write)
        print_str(", expected ")
        print_i64(is_write)
        print_str("\n")
        mem_access_free(access)
        R 0
    } E { 0 }

    # element_size(32): i64
    actual_elem_size := load_i64(access + 32)
    I actual_elem_size != element_size {
        print_str("FAIL: element_size is ")
        print_i64(actual_elem_size)
        print_str(", expected ")
        print_i64(element_size)
        print_str("\n")
        mem_access_free(access)
        R 0
    } E { 0 }

    # block_idx(40): i64
    actual_block_idx := load_i64(access + 40)
    I actual_block_idx != block_idx {
        print_str("FAIL: block_idx is ")
        print_i64(actual_block_idx)
        print_str(", expected ")
        print_i64(block_idx)
        print_str("\n")
        mem_access_free(access)
        R 0
    } E { 0 }

    mem_access_free(access)
    print_str("PASS\n")
    R 1
}

# ============================================================================
# Layout Tests
# ============================================================================

# Test 4: StructLayout calculation
F test_struct_layout_calculate() -> i64 {
    print_str("Test 4: StructLayout calculation... ")

    # Create a struct layout with 3 fields:
    # Field 0: size=1, align=1 (i8)
    # Field 1: size=8, align=8 (i64)
    # Field 2: size=4, align=4 (i32)

    layout := struct_layout_new(0)  # name_idx=0 (dummy)

    # Add field 0: i8
    field0 := field_info_new(0, 0, 1, 1)
    struct_layout_add_field(layout, field0)

    # Add field 1: i64
    field1 := field_info_new(1, 0, 8, 8)
    struct_layout_add_field(layout, field1)

    # Add field 2: i32
    field2 := field_info_new(2, 0, 4, 4)
    struct_layout_add_field(layout, field2)

    # Calculate layout
    struct_layout_calculate(layout)

    # Expected layout:
    # Field 0 (i8): offset=0, size=1
    # Padding: 7 bytes to align field 1 to 8
    # Field 1 (i64): offset=8, size=8
    # Field 2 (i32): offset=16, size=4
    # Padding: 4 bytes to align struct to 8
    # Total size: 24 bytes
    # Total padding: 7 + 4 = 11 bytes

    # Verify field offsets
    offset0 := load_i64(field0 + 32)
    I offset0 != 0 {
        print_str("FAIL: field0 offset is ")
        print_i64(offset0)
        print_str(", expected 0\n")
        struct_layout_free(layout)
        R 0
    } E { 0 }

    offset1 := load_i64(field1 + 32)
    I offset1 != 8 {
        print_str("FAIL: field1 offset is ")
        print_i64(offset1)
        print_str(", expected 8\n")
        struct_layout_free(layout)
        R 0
    } E { 0 }

    offset2 := load_i64(field2 + 32)
    I offset2 != 16 {
        print_str("FAIL: field2 offset is ")
        print_i64(offset2)
        print_str(", expected 16\n")
        struct_layout_free(layout)
        R 0
    } E { 0 }

    # Verify total size (offset 24)
    total_size := load_i64(layout + 24)
    I total_size != 24 {
        print_str("FAIL: total_size is ")
        print_i64(total_size)
        print_str(", expected 24\n")
        struct_layout_free(layout)
        R 0
    } E { 0 }

    # Verify padding (offset 40)
    padding := load_i64(layout + 40)
    I padding != 11 {
        print_str("FAIL: padding is ")
        print_i64(padding)
        print_str(", expected 11\n")
        struct_layout_free(layout)
        R 0
    } E { 0 }

    # Verify alignment (offset 32)
    alignment := load_i64(layout + 32)
    I alignment != 8 {
        print_str("FAIL: alignment is ")
        print_i64(alignment)
        print_str(", expected 8\n")
        struct_layout_free(layout)
        R 0
    } E { 0 }

    struct_layout_free(layout)
    print_str("PASS\n")
    R 1
}

# Test 5: Field reorder suggestion
F test_field_reorder_suggestion() -> i64 {
    print_str("Test 5: Field reorder suggestion... ")

    # Create unoptimal layout: i8, i64, i32 (same as test 4)
    # Optimal layout would be: i64, i32, i8

    layout := struct_layout_new(0)

    # Add fields in suboptimal order
    field0 := field_info_new(0, 0, 1, 1)   # i8
    field1 := field_info_new(1, 0, 8, 8)   # i64
    field2 := field_info_new(2, 0, 4, 4)   # i32

    struct_layout_add_field(layout, field0)
    struct_layout_add_field(layout, field1)
    struct_layout_add_field(layout, field2)

    # Calculate original layout
    struct_layout_calculate(layout)
    orig_padding := load_i64(layout + 40)

    # Request field reorder suggestion
    sugg := suggest_field_reorder(layout)

    I sugg == 0 {
        print_str("FAIL: expected reorder suggestion, got null\n")
        struct_layout_free(layout)
        R 0
    } E { 0 }

    # Verify suggestion kind is LAYOUT_REORDER
    kind := load_i64(sugg)
    I kind != LAYOUT_REORDER() {
        print_str("FAIL: suggestion kind is ")
        print_i64(kind)
        print_str(", expected LAYOUT_REORDER (")
        print_i64(LAYOUT_REORDER())
        print_str(")\n")
        layout_suggestion_free(sugg)
        struct_layout_free(layout)
        R 0
    } E { 0 }

    # Verify padding_saved (offset 48) is > 0
    padding_saved := load_i64(sugg + 48)
    I padding_saved <= 0 {
        print_str("FAIL: padding_saved is ")
        print_i64(padding_saved)
        print_str(", expected > 0\n")
        layout_suggestion_free(sugg)
        struct_layout_free(layout)
        R 0
    } E { 0 }

    # Verify size_after (offset 40) < size_before (offset 32)
    size_before := load_i64(sugg + 32)
    size_after := load_i64(sugg + 40)
    I size_after >= size_before {
        print_str("FAIL: size_after (")
        print_i64(size_after)
        print_str(") >= size_before (")
        print_i64(size_before)
        print_str(")\n")
        layout_suggestion_free(sugg)
        struct_layout_free(layout)
        R 0
    } E { 0 }

    # Verify new_order has 3 fields
    new_order_len := load_i64(sugg + 24)
    I new_order_len != 3 {
        print_str("FAIL: new_order_len is ")
        print_i64(new_order_len)
        print_str(", expected 3\n")
        layout_suggestion_free(sugg)
        struct_layout_free(layout)
        R 0
    } E { 0 }

    # Verify new_order sorts by alignment descending (i64[1], i32[2], i8[0])
    new_order_ptr := load_i64(sugg + 16)
    idx0 := load_i64(new_order_ptr)
    idx1 := load_i64(new_order_ptr + 8)
    idx2 := load_i64(new_order_ptr + 16)

    I idx0 != 1 {
        print_str("FAIL: new_order[0] is ")
        print_i64(idx0)
        print_str(", expected 1 (i64)\n")
        layout_suggestion_free(sugg)
        struct_layout_free(layout)
        R 0
    } E { 0 }

    I idx1 != 2 {
        print_str("FAIL: new_order[1] is ")
        print_i64(idx1)
        print_str(", expected 2 (i32)\n")
        layout_suggestion_free(sugg)
        struct_layout_free(layout)
        R 0
    } E { 0 }

    I idx2 != 0 {
        print_str("FAIL: new_order[2] is ")
        print_i64(idx2)
        print_str(", expected 0 (i8)\n")
        layout_suggestion_free(sugg)
        struct_layout_free(layout)
        R 0
    } E { 0 }

    layout_suggestion_free(sugg)
    struct_layout_free(layout)
    print_str("PASS\n")
    R 1
}

# Test 6: align_to helper
F test_align_to() -> i64 {
    print_str("Test 6: align_to helper... ")

    # Test align_to(5, 8) should give 8
    result := align_to(5, 8)
    I result != 8 {
        print_str("FAIL: align_to(5, 8) = ")
        print_i64(result)
        print_str(", expected 8\n")
        R 0
    } E { 0 }

    # Test align_to(8, 8) should give 8
    result = align_to(8, 8)
    I result != 8 {
        print_str("FAIL: align_to(8, 8) = ")
        print_i64(result)
        print_str(", expected 8\n")
        R 0
    } E { 0 }

    # Test align_to(9, 8) should give 16
    result = align_to(9, 8)
    I result != 16 {
        print_str("FAIL: align_to(9, 8) = ")
        print_i64(result)
        print_str(", expected 16\n")
        R 0
    } E { 0 }

    # Test align_to(0, 4) should give 0
    result = align_to(0, 4)
    I result != 0 {
        print_str("FAIL: align_to(0, 4) = ")
        print_i64(result)
        print_str(", expected 0\n")
        R 0
    } E { 0 }

    # Test align_to(7, 4) should give 8
    result = align_to(7, 4)
    I result != 8 {
        print_str("FAIL: align_to(7, 4) = ")
        print_i64(result)
        print_str(", expected 8\n")
        R 0
    } E { 0 }

    print_str("PASS\n")
    R 1
}

# ============================================================================
# Main Test Runner
# ============================================================================

F main() -> i64 {
    print_str("=== MIR Vectorization & Layout Tests ===\n\n")

    passed := mut 0
    failed := mut 0

    # Run vectorization tests
    print_str("--- Vectorization Tests ---\n")
    I test_vec_ctx_creation() == 1 {
        passed = passed + 1
        0
    } E {
        failed = failed + 1
        0
    }

    I test_dep_prevents_vectorization() == 1 {
        passed = passed + 1
        0
    } E {
        failed = failed + 1
        0
    }

    I test_mem_access_creation() == 1 {
        passed = passed + 1
        0
    } E {
        failed = failed + 1
        0
    }

    # Run layout tests
    print_str("\n--- Layout Tests ---\n")
    I test_struct_layout_calculate() == 1 {
        passed = passed + 1
        0
    } E {
        failed = failed + 1
        0
    }

    I test_field_reorder_suggestion() == 1 {
        passed = passed + 1
        0
    } E {
        failed = failed + 1
        0
    }

    I test_align_to() == 1 {
        passed = passed + 1
        0
    } E {
        failed = failed + 1
        0
    }

    # Print summary
    print_str("\n=== Test Summary ===\n")
    print_str("Passed: ")
    print_i64(passed)
    print_str("\n")
    print_str("Failed: ")
    print_i64(failed)
    print_str("\n")

    I failed == 0 {
        print_str("\nAll tests PASSED!\n")
        R 0
    } E {
        print_str("\nSome tests FAILED.\n")
        R 1
    }
}
