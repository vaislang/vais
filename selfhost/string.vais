# ============================================================================
# String - Owned String Type for Selfhost
# ============================================================================
# Layout: [data_ptr: i64, len: i64, cap: i64] = 24 bytes
# UTF-8 byte buffer with length tracking. Null-terminated for C interop.
# Based on StringBuffer pattern but with immutable-first API.
# ============================================================================

# ============================================================================
# Constructors
# ============================================================================

# Create an empty string with default capacity
F string_new() -> i64 {
    s := malloc(24)
    data := malloc(32)
    store_byte(data, 0)    # null terminator
    store_i64(s, data)
    store_i64(s + 8, 0)   # len = 0
    store_i64(s + 16, 32) # cap = 32
    s
}

# Create an empty string with specified capacity
F string_with_cap(cap: i64) -> i64 {
    s := malloc(24)
    data := malloc(cap)
    store_byte(data, 0)
    store_i64(s, data)
    store_i64(s + 8, 0)
    store_i64(s + 16, cap)
    s
}

# Create string from str literal (copies bytes)
F string_from(src: str) -> i64 {
    slen := strlen(src)
    cap := slen + 16
    s := malloc(24)
    data := malloc(cap)
    memcpy_str(data, src, slen)
    store_byte(data + slen, 0)  # null terminator
    store_i64(s, data)
    store_i64(s + 8, slen)
    store_i64(s + 16, cap)
    s
}

# Create string from raw pointer + length (copies bytes)
F string_from_ptr(src: i64, slen: i64) -> i64 {
    cap := slen + 16
    s := malloc(24)
    data := malloc(cap)
    memcpy(data, src, slen)
    store_byte(data + slen, 0)
    store_i64(s, data)
    store_i64(s + 8, slen)
    store_i64(s + 16, cap)
    s
}

# ============================================================================
# Accessors
# ============================================================================

F string_data(s: i64) -> i64 = load_i64(s)
F string_len(s: i64) -> i64 = load_i64(s + 8)
F string_cap(s: i64) -> i64 = load_i64(s + 16)

F string_is_empty(s: i64) -> i64 {
    I string_len(s) == 0 { 1 } E { 0 }
}

# Get byte at index
F string_byte_at(s: i64, idx: i64) -> i64 {
    data := load_i64(s)
    load_byte(data + idx)
}

# ============================================================================
# Growth (internal)
# ============================================================================

F string_grow_to(s: i64, new_cap: i64) -> i64 {
    old_data := load_i64(s)
    old_len := load_i64(s + 8)
    new_data := malloc(new_cap)
    memcpy(new_data, old_data, old_len)
    store_byte(new_data + old_len, 0)
    free(old_data)
    store_i64(s, new_data)
    store_i64(s + 16, new_cap)
    0
}

F string_ensure_cap(s: i64, needed: i64) -> i64 {
    cap := load_i64(s + 16)
    I needed + 1 > cap {
        string_grow_to(s, needed * 2 + 1)
    } E { 0 }
}

# ============================================================================
# Mutation
# ============================================================================

# Append a single byte
F string_push_byte(s: i64, byte: i64) -> i64 {
    len := load_i64(s + 8)
    string_ensure_cap(s, len + 1)
    data := load_i64(s)
    store_byte(data + len, byte)
    store_byte(data + len + 1, 0)
    store_i64(s + 8, len + 1)
    0
}

# Append a str literal
F string_push_str(s: i64, src: str) -> i64 {
    slen := strlen(src)
    len := load_i64(s + 8)
    string_ensure_cap(s, len + slen)
    data := load_i64(s)
    memcpy_str(data + len, src, slen)
    new_len := len + slen
    store_byte(data + new_len, 0)
    store_i64(s + 8, new_len)
    0
}

# Append bytes from pointer
F string_push_ptr(s: i64, src: i64, slen: i64) -> i64 {
    len := load_i64(s + 8)
    string_ensure_cap(s, len + slen)
    data := load_i64(s)
    memcpy(data + len, src, slen)
    new_len := len + slen
    store_byte(data + new_len, 0)
    store_i64(s + 8, new_len)
    0
}

# Append another string
F string_push_string(dst: i64, src: i64) -> i64 {
    src_data := load_i64(src)
    src_len := load_i64(src + 8)
    string_push_ptr(dst, src_data, src_len)
}

# Append integer as decimal string
F string_push_i64(s: i64, value: i64) -> i64 {
    I value == 0 {
        string_push_byte(s, 48)
    } E I value < 0 {
        string_push_byte(s, 45)
        string_push_i64(s, 0 - value)
    } E {
        I value >= 10 {
            string_push_i64(s, value / 10)
            0
        } E { 0 }
        string_push_byte(s, (value % 10) + 48)
    }
}

# Clear string contents (does not free memory)
F string_clear(s: i64) -> i64 {
    data := load_i64(s)
    store_byte(data, 0)
    store_i64(s + 8, 0)
    0
}

# ============================================================================
# Internal: byte-by-byte comparison (avoids memcmp i32/i64 mismatch)
# ============================================================================

F bytes_equal(a_ptr: i64, b_ptr: i64, len: i64) -> i64 {
    i := mut 0
    equal := mut 1
    L i < len {
        ab := load_byte(a_ptr + i)
        bb := load_byte(b_ptr + i)
        I ab != bb {
            equal = 0
            i = len  # break
        } E {
            i = i + 1
        }
    }
    equal
}

F bytes_cmp(a_ptr: i64, b_ptr: i64, len: i64) -> i64 {
    i := mut 0
    result := mut 0
    found := mut 0
    L i < len {
        I found == 0 {
            ab := load_byte(a_ptr + i)
            bb := load_byte(b_ptr + i)
            I ab < bb {
                result = 0 - 1
                found = 1
            } E I ab > bb {
                result = 1
                found = 1
            } E {
                i = i + 1
            }
        } E {
            i = len  # break
        }
    }
    result
}

# ============================================================================
# Comparison
# ============================================================================

# Compare two strings for equality
F string_eq(a: i64, b: i64) -> i64 {
    a_len := load_i64(a + 8)
    b_len := load_i64(b + 8)
    I a_len != b_len {
        0
    } E {
        a_data := load_i64(a)
        b_data := load_i64(b)
        bytes_equal(a_data, b_data, a_len)
    }
}

# Compare string with str literal
F string_eq_str(s: i64, lit: str) -> i64 {
    lit_ptr := str_to_ptr(lit)
    lit_len := mut 0
    L load_byte(lit_ptr + lit_len) != 0 {
        lit_len = lit_len + 1
    }
    s_len := load_i64(s + 8)
    I s_len != lit_len {
        0
    } E {
        s_data := load_i64(s)
        bytes_equal(s_data, lit_ptr, s_len)
    }
}

# Lexicographic comparison: -1, 0, +1
F string_cmp(a: i64, b: i64) -> i64 {
    a_len := load_i64(a + 8)
    b_len := load_i64(b + 8)
    a_data := load_i64(a)
    b_data := load_i64(b)
    min_len := mut a_len
    I b_len < min_len {
        min_len = b_len
        0
    } E { 0 }
    result := bytes_cmp(a_data, b_data, min_len)
    I result != 0 {
        result
    } E I a_len < b_len {
        0 - 1
    } E I a_len > b_len {
        1
    } E {
        0
    }
}

# ============================================================================
# Slicing & Substring
# ============================================================================

# Create new string from slice [start..end)
F string_slice(s: i64, start: i64, end: i64) -> i64 {
    data := load_i64(s)
    slen := end - start
    string_from_ptr(data + start, slen)
}

# ============================================================================
# Search
# ============================================================================

# Find first occurrence of byte, returns index or -1
F string_find_byte(s: i64, byte: i64) -> i64 {
    len := load_i64(s + 8)
    data := load_i64(s)
    i := mut 0
    result := mut 0 - 1
    L i < len {
        b := load_byte(data + i)
        I b == byte {
            result = i
            i = len  # break
        } E {
            i = i + 1
        }
    }
    result
}

# Find last occurrence of byte, returns index or -1
F string_rfind_byte(s: i64, byte: i64) -> i64 {
    len := load_i64(s + 8)
    data := load_i64(s)
    i := mut len - 1
    result := mut 0 - 1
    L i >= 0 {
        b := load_byte(data + i)
        I b == byte {
            result = i
            i = 0 - 1  # break
        } E {
            i = i - 1
        }
    }
    result
}

# Check if string starts with str literal
F string_starts_with(s: i64, prefix: str) -> i64 {
    p_ptr := str_to_ptr(prefix)
    p_len := mut 0
    L load_byte(p_ptr + p_len) != 0 {
        p_len = p_len + 1
    }
    s_len := load_i64(s + 8)
    I p_len > s_len {
        0
    } E {
        s_data := load_i64(s)
        bytes_equal(s_data, p_ptr, p_len)
    }
}

# Check if string ends with str literal
F string_ends_with(s: i64, suffix: str) -> i64 {
    sf_ptr := str_to_ptr(suffix)
    # Compute suffix length via load_byte (str_to_ptr already consumed suffix)
    sf_len := mut 0
    L load_byte(sf_ptr + sf_len) != 0 {
        sf_len = sf_len + 1
    }
    s_len := load_i64(s + 8)
    I sf_len > s_len {
        0
    } E {
        s_data := load_i64(s)
        offset := s_len - sf_len
        bytes_equal(s_data + offset, sf_ptr, sf_len)
    }
}

# ============================================================================
# Transformation
# ============================================================================

# Clone string (deep copy)
F string_clone(s: i64) -> i64 {
    len := load_i64(s + 8)
    data := load_i64(s)
    string_from_ptr(data, len)
}

# Concatenate two strings, returns new string
F string_concat(a: i64, b: i64) -> i64 {
    a_len := load_i64(a + 8)
    b_len := load_i64(b + 8)
    a_data := load_i64(a)
    b_data := load_i64(b)
    total := a_len + b_len
    result := string_with_cap(total + 1)
    r_data := load_i64(result)
    memcpy(r_data, a_data, a_len)
    memcpy(r_data + a_len, b_data, b_len)
    store_byte(r_data + total, 0)
    store_i64(result + 8, total)
    result
}

# Helper: check if byte is whitespace (space, tab, newline, cr)
F is_whitespace(b: i64) -> i64 {
    I b == 32 { 1 }
    E I b == 9 { 1 }
    E I b == 10 { 1 }
    E I b == 13 { 1 }
    E { 0 }
}

# Trim leading and trailing whitespace, returns new string
F string_trim(s: i64) -> i64 {
    len := load_i64(s + 8)
    data := load_i64(s)
    # Find first non-whitespace
    start := mut 0
    found_start := mut 0
    L found_start == 0 {
        I start >= len {
            found_start = 1
        } E {
            b := load_byte(data + start)
            I is_whitespace(b) == 1 {
                start = start + 1
            } E {
                found_start = 1
            }
        }
    }
    # Find last non-whitespace
    end := mut len
    found_end := mut 0
    L found_end == 0 {
        I end <= start {
            found_end = 1
        } E {
            b := load_byte(data + end - 1)
            I is_whitespace(b) == 1 {
                end = end - 1
            } E {
                found_end = 1
            }
        }
    }
    string_from_ptr(data + start, end - start)
}

# ============================================================================
# Cleanup
# ============================================================================

# Free string and its data buffer
F string_drop(s: i64) -> i64 {
    data := load_i64(s)
    free(data)
    free(s)
    0
}

# ============================================================================
# Debug
# ============================================================================

# Print string contents to stdout
F string_print(s: i64) -> i64 {
    data := load_i64(s)
    len := load_i64(s + 8)
    i := mut 0
    L i < len {
        b := load_byte(data + i)
        putchar(b)
        i = i + 1
    }
    0
}

# Print string with newline
F string_println(s: i64) -> i64 {
    string_print(s)
    putchar(10)
    0
}
