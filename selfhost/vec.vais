# ============================================================================
# Vec - Dynamic Array for Selfhost
# ============================================================================
# Layout: [data_ptr: i64, len: i64, cap: i64] = 24 bytes
# Elements are i64 (8 bytes each). All values stored as i64.
# ============================================================================

# ============================================================================
# Constructors
# ============================================================================

# Create a new empty Vec with default capacity 8
F vec_new() -> i64 {
    v := malloc(24)
    data := malloc(64)    # 8 * 8 bytes
    store_i64(v, data)
    store_i64(v + 8, 0)   # len = 0
    store_i64(v + 16, 8)  # cap = 8
    v
}

# Create a new Vec with specified initial capacity
F vec_with_cap(cap: i64) -> i64 {
    v := malloc(24)
    data := malloc(cap * 8)
    store_i64(v, data)
    store_i64(v + 8, 0)
    store_i64(v + 16, cap)
    v
}

# ============================================================================
# Accessors
# ============================================================================

F vec_data(v: i64) -> i64 = load_i64(v)
F vec_len(v: i64) -> i64 = load_i64(v + 8)
F vec_cap(v: i64) -> i64 = load_i64(v + 16)

F vec_is_empty(v: i64) -> i64 {
    I vec_len(v) == 0 { 1 } E { 0 }
}

# ============================================================================
# Element Access
# ============================================================================

# Get element at index (no bounds check)
F vec_get(v: i64, idx: i64) -> i64 {
    data := load_i64(v)
    load_i64(data + idx * 8)
}

# Set element at index (no bounds check)
F vec_set(v: i64, idx: i64, val: i64) -> i64 {
    data := load_i64(v)
    store_i64(data + idx * 8, val)
    0
}

# Get element with bounds check, returns Option (opt_some/opt_none)
F vec_get_checked(v: i64, idx: i64) -> i64 {
    len := vec_len(v)
    I idx >= 0 {
        I idx < len {
            data := load_i64(v)
            val := load_i64(data + idx * 8)
            # Return opt_some(val) inline
            opt := malloc(16)
            store_i64(opt, 0)
            store_i64(opt + 8, val)
            opt
        } E {
            # Return opt_none inline
            opt := malloc(16)
            store_i64(opt, 1)
            store_i64(opt + 8, 0)
            opt
        }
    } E {
        opt := malloc(16)
        store_i64(opt, 1)
        store_i64(opt + 8, 0)
        opt
    }
}

# Get first element
F vec_first(v: i64) -> i64 = vec_get(v, 0)

# Get last element
F vec_last(v: i64) -> i64 {
    len := vec_len(v)
    vec_get(v, len - 1)
}

# ============================================================================
# Growth
# ============================================================================

F vec_grow(v: i64) -> i64 {
    old_data := load_i64(v)
    old_len := load_i64(v + 8)
    old_cap := load_i64(v + 16)
    new_cap := old_cap * 2
    new_data := malloc(new_cap * 8)
    memcpy(new_data, old_data, old_len * 8)
    free(old_data)
    store_i64(v, new_data)
    store_i64(v + 16, new_cap)
    0
}

F vec_ensure_cap(v: i64, needed: i64) -> i64 {
    cap := load_i64(v + 16)
    I needed > cap {
        old_data := load_i64(v)
        old_len := load_i64(v + 8)
        new_cap := needed * 2
        new_data := malloc(new_cap * 8)
        memcpy(new_data, old_data, old_len * 8)
        free(old_data)
        store_i64(v, new_data)
        store_i64(v + 16, new_cap)
        0
    } E { 0 }
}

# ============================================================================
# Mutation
# ============================================================================

# Push element to end
F vec_push(v: i64, val: i64) -> i64 {
    len := load_i64(v + 8)
    cap := load_i64(v + 16)
    I len >= cap {
        vec_grow(v)
        0
    } E { 0 }
    data := load_i64(v)
    store_i64(data + len * 8, val)
    store_i64(v + 8, len + 1)
    0
}

# Pop element from end, returns the value (undefined if empty)
F vec_pop(v: i64) -> i64 {
    len := load_i64(v + 8)
    I len > 0 {
        new_len := len - 1
        store_i64(v + 8, new_len)
        data := load_i64(v)
        load_i64(data + new_len * 8)
    } E {
        puts("panic: vec_pop on empty vec")
        0
    }
}

# Insert element at index, shifting subsequent elements right
F vec_insert(v: i64, idx: i64, val: i64) -> i64 {
    len := load_i64(v + 8)
    cap := load_i64(v + 16)
    I len >= cap {
        vec_grow(v)
        0
    } E { 0 }
    data := load_i64(v)
    # Shift elements right from end to idx
    i := mut len
    L i > idx {
        prev := load_i64(data + (i - 1) * 8)
        store_i64(data + i * 8, prev)
        i = i - 1
    }
    store_i64(data + idx * 8, val)
    store_i64(v + 8, len + 1)
    0
}

# Remove element at index, shifting subsequent elements left
F vec_remove(v: i64, idx: i64) -> i64 {
    len := load_i64(v + 8)
    data := load_i64(v)
    val := load_i64(data + idx * 8)
    # Shift elements left
    i := mut idx
    L i < len - 1 {
        next := load_i64(data + (i + 1) * 8)
        store_i64(data + i * 8, next)
        i = i + 1
    }
    store_i64(v + 8, len - 1)
    val
}

# Swap remove: O(1) removal by swapping with last element
F vec_swap_remove(v: i64, idx: i64) -> i64 {
    len := load_i64(v + 8)
    data := load_i64(v)
    val := load_i64(data + idx * 8)
    new_len := len - 1
    I idx < new_len {
        last := load_i64(data + new_len * 8)
        store_i64(data + idx * 8, last)
        0
    } E { 0 }
    store_i64(v + 8, new_len)
    val
}

# Clear all elements (does not free memory)
F vec_clear(v: i64) -> i64 {
    store_i64(v + 8, 0)
    0
}

# Truncate to len elements
F vec_truncate(v: i64, new_len: i64) -> i64 {
    len := load_i64(v + 8)
    I new_len < len {
        store_i64(v + 8, new_len)
        0
    } E { 0 }
}

# ============================================================================
# Search
# ============================================================================

# Find index of value, returns -1 if not found
F vec_index_of(v: i64, val: i64) -> i64 {
    len := vec_len(v)
    data := load_i64(v)
    i := mut 0
    result := mut 0 - 1
    L i < len {
        elem := load_i64(data + i * 8)
        I elem == val {
            result = i
            i = len  # break
        } E {
            i = i + 1
        }
    }
    result
}

# Check if value exists in vec
F vec_contains(v: i64, val: i64) -> i64 {
    idx := vec_index_of(v, val)
    I idx >= 0 { 1 } E { 0 }
}

# ============================================================================
# Bulk Operations
# ============================================================================

# Extend vec with elements from another vec
F vec_extend(dst: i64, src: i64) -> i64 {
    src_len := vec_len(src)
    dst_len := vec_len(dst)
    vec_ensure_cap(dst, dst_len + src_len)
    src_data := load_i64(src)
    dst_data := load_i64(dst)
    memcpy(dst_data + dst_len * 8, src_data, src_len * 8)
    store_i64(dst + 8, dst_len + src_len)
    0
}

# Clone vec (deep copy of data array)
F vec_clone(v: i64) -> i64 {
    len := vec_len(v)
    cap := vec_cap(v)
    data := load_i64(v)
    new_v := malloc(24)
    new_data := malloc(cap * 8)
    memcpy(new_data, data, len * 8)
    store_i64(new_v, new_data)
    store_i64(new_v + 8, len)
    store_i64(new_v + 16, cap)
    new_v
}

# Reverse vec in-place
F vec_reverse(v: i64) -> i64 {
    len := vec_len(v)
    data := load_i64(v)
    i := mut 0
    j := mut len - 1
    L i < j {
        a := load_i64(data + i * 8)
        b := load_i64(data + j * 8)
        store_i64(data + i * 8, b)
        store_i64(data + j * 8, a)
        i = i + 1
        j = j - 1
    }
    0
}

# ============================================================================
# Sorting (insertion sort â€” good for small arrays)
# ============================================================================

F vec_sort(v: i64) -> i64 {
    len := vec_len(v)
    data := load_i64(v)
    i := mut 1
    L i < len {
        key := load_i64(data + i * 8)
        j := mut i - 1
        done := mut 0
        L done == 0 {
            I j >= 0 {
                elem := load_i64(data + j * 8)
                I elem > key {
                    store_i64(data + (j + 1) * 8, elem)
                    j = j - 1
                } E {
                    done = 1
                }
            } E {
                done = 1
            }
        }
        store_i64(data + (j + 1) * 8, key)
        i = i + 1
    }
    0
}

# ============================================================================
# Cleanup
# ============================================================================

# Free vec and its data buffer
F vec_drop(v: i64) -> i64 {
    data := load_i64(v)
    free(data)
    free(v)
    0
}

# Free vec, data buffer, and each element (if elements are malloc'd pointers)
F vec_drop_deep(v: i64) -> i64 {
    len := vec_len(v)
    data := load_i64(v)
    i := mut 0
    L i < len {
        elem := load_i64(data + i * 8)
        I elem != 0 {
            free(elem)
            0
        } E { 0 }
        i = i + 1
    }
    free(data)
    free(v)
    0
}

# ============================================================================
# Debug
# ============================================================================

# Print vec contents: [1, 2, 3]
F vec_print(v: i64) -> i64 {
    len := vec_len(v)
    data := load_i64(v)
    putchar(91)  # [
    i := mut 0
    L i < len {
        I i > 0 {
            putchar(44)  # ,
            putchar(32)  # space
            0
        } E { 0 }
        val := load_i64(data + i * 8)
        printf("%ld", val)
        i = i + 1
    }
    putchar(93)  # ]
    putchar(10)  # newline
    0
}
