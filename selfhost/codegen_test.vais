# Vais Self-Hosting Compiler - Codegen Test
# Tests simple LLVM IR generation (procedural style)

# ============================================================================
# StringBuffer (procedural functions)
# ============================================================================

F sb_new(initial_cap: i64) -> i64 {
    # Allocate struct: 3 fields * 8 bytes = 24 bytes
    sb := malloc(24)
    data := malloc(initial_cap)
    store_i64(sb + 0, data)       # data pointer
    store_i64(sb + 8, 0)          # len
    store_i64(sb + 16, initial_cap)  # cap
    sb
}

F sb_get_data(sb: i64) -> i64 = load_i64(sb + 0)
F sb_get_len(sb: i64) -> i64 = load_i64(sb + 8)
F sb_get_cap(sb: i64) -> i64 = load_i64(sb + 16)

F sb_set_data(sb: i64, data: i64) -> i64 {
    store_i64(sb + 0, data)
    0
}

F sb_set_len(sb: i64, len: i64) -> i64 {
    store_i64(sb + 8, len)
    0
}

F sb_set_cap(sb: i64, cap: i64) -> i64 {
    store_i64(sb + 16, cap)
    0
}

F sb_grow_to(sb: i64, new_cap: i64) -> i64 {
    old_data := sb_get_data(sb)
    old_len := sb_get_len(sb)
    new_data := malloc(new_cap)
    memcpy(new_data, old_data, old_len)
    free(old_data)
    sb_set_data(sb, new_data)
    sb_set_cap(sb, new_cap)
    1
}

F sb_append_byte(sb: i64, byte: i64) -> i64 {
    len := sb_get_len(sb)
    cap := sb_get_cap(sb)
    I len >= cap {
        sb_grow_to(sb, cap * 2)
        0
    } E { 0 }
    data := sb_get_data(sb)
    store_byte(data + len, byte)
    sb_set_len(sb, len + 1)
    1
}

F sb_append_cstr(sb: i64, s: str) -> i64 {
    slen := strlen(s)
    len := sb_get_len(sb)
    cap := sb_get_cap(sb)
    I len + slen > cap {
        sb_grow_to(sb, len + slen + 1024)
        0
    } E { 0 }
    data := sb_get_data(sb)
    memcpy_str(data + len, s, slen)
    sb_set_len(sb, len + slen)
    1
}

F sb_append_i64(sb: i64, value: i64) -> i64 {
    I value == 0 {
        sb_append_byte(sb, 48)
    } E I value < 0 {
        sb_append_byte(sb, 45)
        sb_append_i64(sb, 0 - value)
    } E {
        I value >= 10 {
            sb_append_i64(sb, value / 10)
            0
        } E { 0 }
        sb_append_byte(sb, (value % 10) + 48)
    }
}

F sb_append_newline(sb: i64) -> i64 = sb_append_byte(sb, 10)

F sb_free(sb: i64) -> i64 {
    free(sb_get_data(sb))
    free(sb)
    1
}

# ============================================================================
# Simple Code Generator (procedural)
# ============================================================================

F cg_new() -> i64 {
    # Allocate struct: sb (8) + reg_counter (8) = 16 bytes
    cg := malloc(16)
    sb := sb_new(4096)
    store_i64(cg + 0, sb)
    store_i64(cg + 8, 0)  # reg_counter
    cg
}

F cg_get_sb(cg: i64) -> i64 = load_i64(cg + 0)
F cg_get_reg(cg: i64) -> i64 = load_i64(cg + 8)

F cg_fresh_reg(cg: i64) -> i64 {
    r := cg_get_reg(cg)
    store_i64(cg + 8, r + 1)
    r
}

F cg_emit(cg: i64, s: str) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_cstr(sb, s)
}

F cg_emit_quote(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_byte(sb, 34)  # ASCII quote character
}

F cg_emit_i64(cg: i64, v: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_i64(sb, v)
}

F cg_emit_newline(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_newline(sb)
}

# Generate header for module
F cg_emit_header(cg: i64) -> i64 {
    cg_emit(cg, "; Generated by Vais Self-Hosting Compiler")
    cg_emit_newline(cg)
    cg_emit(cg, "source_filename = ")
    cg_emit_quote(cg)
    cg_emit(cg, "test")
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit(cg, "target triple = ")
    cg_emit_quote(cg)
    cg_emit(cg, "x86_64-apple-macosx")
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit_newline(cg)
    cg_emit(cg, "; External declarations")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i32 @putchar(i32)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i32 @puts(i8*)")
    cg_emit_newline(cg)
    cg_emit_newline(cg)
    1
}

# Generate add function
F cg_emit_add_function(cg: i64) -> i64 {
    cg_emit(cg, "define i64 @add(i64 %a, i64 %b) {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %result = add i64 %a, %b")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret i64 %result")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)
    1
}

# Generate hello main
F cg_emit_hello_main(cg: i64) -> i64 {
    # String constant: "Hello, Vais!\n\0"
    cg_emit(cg, "@.str.hello = private constant [14 x i8] c")
    cg_emit_quote(cg)
    cg_emit(cg, "Hello, Vais!")
    sb := cg_get_sb(cg)
    sb_append_byte(sb, 92)  # backslash
    sb_append_byte(sb, 48)  # 0
    sb_append_byte(sb, 65)  # A (for \0A = newline)
    sb_append_byte(sb, 92)  # backslash
    sb_append_byte(sb, 48)  # 0
    sb_append_byte(sb, 48)  # 0 (for \00 = null)
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit_newline(cg)
    cg_emit(cg, "define i64 @main() {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %str = getelementptr [14 x i8], [14 x i8]* @.str.hello, i64 0, i64 0")
    cg_emit_newline(cg)
    cg_emit(cg, "  call i32 @puts(i8* %str)")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret i64 0")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    1
}

F cg_get_output(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_get_data(sb)
}

F cg_get_output_len(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_get_len(sb)
}

F cg_free(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_free(sb)
    free(cg)
    1
}

# ============================================================================
# Main Test
# ============================================================================

F main() -> i64 {
    puts("=== Codegen Test ===\n")

    # Generate simple LLVM IR
    gen := cg_new()
    cg_emit_header(gen)
    cg_emit_add_function(gen)
    cg_emit_hello_main(gen)

    # Print generated IR
    puts("\n--- Generated LLVM IR ---\n")
    ir_ptr := cg_get_output(gen)
    ir_len := cg_get_output_len(gen)

    i: mut i64 = 0
    L {
        I i >= ir_len { B } E { 0 }
        putchar(load_byte(ir_ptr + i))
        i = i + 1
    }

    puts("\n--- End of LLVM IR ---\n")

    # Write to file
    fp := fopen("selfhost/codegen_test_output.ll", "wb")
    I fp != 0 {
        fwrite(ir_ptr, 1, ir_len, fp)
        fclose(fp)
        puts("[OK] Written to selfhost/codegen_test_output.ll\n")
        0
    } E {
        puts("[ERROR] Could not write output file\n")
        0
    }

    cg_free(gen)

    puts("\n=== Codegen Test Complete ===\n")
    0
}
