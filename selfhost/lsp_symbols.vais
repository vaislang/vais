# Vais Self-Hosting LSP Server - Symbol Table & AST Traversal
# Collects definitions and references from parsed AST

U constants
U stringbuffer_s1
U helpers_s1
U lsp_json

# ============================================================================
# Symbol Kind Constants
# ============================================================================
F SYM_FUNCTION() -> i64 = 1
F SYM_STRUCT() -> i64 = 2
F SYM_ENUM() -> i64 = 3
F SYM_TRAIT() -> i64 = 4
F SYM_FIELD() -> i64 = 5
F SYM_PARAM() -> i64 = 6
F SYM_VARIABLE() -> i64 = 7
F SYM_METHOD() -> i64 = 8

# ============================================================================
# SymbolDef (48 bytes)
# ============================================================================
# Layout: kind(8) + name_ptr(8) + name_len(8) + span_start(8) + span_end(8) + extra(8)
# extra: for functions, ptr to params info; for structs, ptr to fields info

F symdef_new(kind: i64, name_ptr: i64, name_len: i64, span_start: i64, span_end: i64) -> i64 {
    s := malloc(48)
    store_i64(s + 0, kind)
    store_i64(s + 8, name_ptr)
    store_i64(s + 16, name_len)
    store_i64(s + 24, span_start)
    store_i64(s + 32, span_end)
    store_i64(s + 40, 0)
    s
}

F symdef_kind(s: i64) -> i64 = load_i64(s + 0)
F symdef_name_ptr(s: i64) -> i64 = load_i64(s + 8)
F symdef_name_len(s: i64) -> i64 = load_i64(s + 16)
F symdef_span_start(s: i64) -> i64 = load_i64(s + 24)
F symdef_span_end(s: i64) -> i64 = load_i64(s + 32)
F symdef_extra(s: i64) -> i64 = load_i64(s + 40)
F symdef_set_extra(s: i64, v: i64) -> i64 { store_i64(s + 40, v); 0 }

# ============================================================================
# SymbolRef (32 bytes)
# ============================================================================
# Layout: name_ptr(8) + name_len(8) + span_start(8) + span_end(8)

F symref_new(name_ptr: i64, name_len: i64, span_start: i64, span_end: i64) -> i64 {
    r := malloc(32)
    store_i64(r + 0, name_ptr)
    store_i64(r + 8, name_len)
    store_i64(r + 16, span_start)
    store_i64(r + 24, span_end)
    r
}

F symref_name_ptr(r: i64) -> i64 = load_i64(r + 0)
F symref_name_len(r: i64) -> i64 = load_i64(r + 8)
F symref_span_start(r: i64) -> i64 = load_i64(r + 16)
F symref_span_end(r: i64) -> i64 = load_i64(r + 24)

# ============================================================================
# SymbolTable (dynamic arrays)
# ============================================================================
# Layout: defs_ptr(8) + defs_count(8) + defs_cap(8) +
#         refs_ptr(8) + refs_count(8) + refs_cap(8) = 48 bytes

F symtable_new() -> i64 {
    st := malloc(48)
    store_i64(st + 0, malloc(256 * 8))   # defs array
    store_i64(st + 8, 0)                   # defs count
    store_i64(st + 16, 256)                # defs cap
    store_i64(st + 24, malloc(1024 * 8))  # refs array
    store_i64(st + 32, 0)                   # refs count
    store_i64(st + 40, 1024)               # refs cap
    st
}

F symtable_add_def(st: i64, def: i64) -> i64 {
    defs := load_i64(st + 0)
    count := load_i64(st + 8)
    cap := load_i64(st + 16)
    I count >= cap {
        new_cap := cap * 2
        new_defs := malloc(new_cap * 8)
        memcpy(new_defs, defs, count * 8)
        free(defs)
        store_i64(st + 0, new_defs)
        store_i64(st + 16, new_cap)
        defs = new_defs
        0
    } E { 0 }
    store_i64(defs + count * 8, def)
    store_i64(st + 8, count + 1)
    0
}

F symtable_add_ref(st: i64, ref: i64) -> i64 {
    refs := load_i64(st + 24)
    count := load_i64(st + 32)
    cap := load_i64(st + 40)
    I count >= cap {
        new_cap := cap * 2
        new_refs := malloc(new_cap * 8)
        memcpy(new_refs, refs, count * 8)
        free(refs)
        store_i64(st + 24, new_refs)
        store_i64(st + 40, new_cap)
        refs = new_refs
        0
    } E { 0 }
    store_i64(refs + count * 8, ref)
    store_i64(st + 32, count + 1)
    0
}

F symtable_defs_count(st: i64) -> i64 = load_i64(st + 8)
F symtable_refs_count(st: i64) -> i64 = load_i64(st + 32)
F symtable_get_def(st: i64, idx: i64) -> i64 {
    defs := load_i64(st + 0)
    load_i64(defs + idx * 8)
}
F symtable_get_ref(st: i64, idx: i64) -> i64 {
    refs := load_i64(st + 24)
    load_i64(refs + idx * 8)
}

# ============================================================================
# Position Helpers
# ============================================================================

# Convert byte offset to (line, col) — 0-based
# src: source code ptr, src_len: length, offset: byte offset
# out: store line at out+0, col at out+8
F offset_to_line_col(src: i64, src_len: i64, offset: i64, out: i64) -> i64 {
    line: mut i64 = 0
    col: mut i64 = 0
    i: mut i64 = 0
    L {
        I i >= offset { B } E { 0 }
        I i >= src_len { B } E { 0 }
        I load_byte(src + i) == 10 {  # newline
            line = line + 1
            col = 0
            0
        } E {
            col = col + 1
            0
        }
        i = i + 1
    }
    store_i64(out, line)
    store_i64(out + 8, col)
    0
}

# Convert (line, col) to byte offset — 0-based
F line_col_to_offset(src: i64, src_len: i64, target_line: i64, target_col: i64) -> i64 {
    line: mut i64 = 0
    col: mut i64 = 0
    i: mut i64 = 0
    L {
        I i >= src_len { B } E { 0 }
        I line == target_line {
            I col == target_col { R i } E { 0 }
        } E { 0 }
        I load_byte(src + i) == 10 {
            line = line + 1
            col = 0
            0
        } E {
            col = col + 1
            0
        }
        i = i + 1
    }
    i
}

# ============================================================================
# AST Definition Collection
# ============================================================================

# Collect definitions from items array
# items: pointer array, count: number of items
F collect_definitions(st: i64, items: i64, count: i64) -> i64 {
    i: mut i64 = 0
    L {
        I i >= count { B } E { 0 }
        item := load_i64(items + i * 8)
        I item == 0 { i = i + 1; C } E { 0 }
        kind := item_get_kind(item)
        name_ptr := item_get_name_ptr(item)
        name_len := item_get_name_len(item)

        I kind == ITEM_FUNCTION() {
            # Function: data0=params, data1=param_count, data2=ret_type, data3=body
            def := symdef_new(SYM_FUNCTION(), name_ptr, name_len, 0, 0)
            symdef_set_extra(def, item)  # store item ptr for signature info
            symtable_add_def(st, def)
            # Also add parameters as definitions
            params := item_get_data0(item)
            param_count := item_get_data1(item)
            pi: mut i64 = 0
            L {
                I pi >= param_count { B } E { 0 }
                param := load_i64(params + pi * 8)
                I param != 0 {
                    pn_ptr := param_get_name_ptr(param)
                    pn_len := param_get_name_len(param)
                    pdef := symdef_new(SYM_PARAM(), pn_ptr, pn_len, 0, 0)
                    symtable_add_def(st, pdef)
                    0
                } E { 0 }
                pi = pi + 1
            }
            0
        } E I kind == ITEM_STRUCT() {
            # Struct: data0=fields, data1=field_count
            def := symdef_new(SYM_STRUCT(), name_ptr, name_len, 0, 0)
            symdef_set_extra(def, item)
            symtable_add_def(st, def)
            # Add fields
            fields := item_get_data0(item)
            field_count := item_get_data1(item)
            fi: mut i64 = 0
            L {
                I fi >= field_count { B } E { 0 }
                field := load_i64(fields + fi * 8)
                I field != 0 {
                    fn_ptr := field_get_name_ptr(field)
                    fn_len := field_get_name_len(field)
                    fdef := symdef_new(SYM_FIELD(), fn_ptr, fn_len, 0, 0)
                    symtable_add_def(st, fdef)
                    0
                } E { 0 }
                fi = fi + 1
            }
            0
        } E I kind == 7 {  # ITEM_IMPL
            # Impl block: data0=methods, data1=method_count
            methods := item_get_data0(item)
            method_count := item_get_data1(item)
            mi: mut i64 = 0
            L {
                I mi >= method_count { B } E { 0 }
                method := load_i64(methods + mi * 8)
                I method != 0 {
                    mn_ptr := item_get_name_ptr(method)
                    mn_len := item_get_name_len(method)
                    mdef := symdef_new(SYM_METHOD(), mn_ptr, mn_len, 0, 0)
                    symdef_set_extra(mdef, method)
                    symtable_add_def(st, mdef)
                    0
                } E { 0 }
                mi = mi + 1
            }
            0
        } E { 0 }

        i = i + 1
    }
    0
}

# ============================================================================
# AST Reference Collection (recursive expr traversal)
# ============================================================================

F collect_refs_expr(st: i64, expr: i64) -> i64 {
    I expr == 0 { R 0 } E { 0 }
    kind := expr_get_kind(expr)

    I kind == EXPR_IDENT() {
        # field0=name_ptr, field1=name_len
        name_ptr := expr_get_field0(expr)
        name_len := expr_get_field1(expr)
        ref := symref_new(name_ptr, name_len, 0, 0)
        symtable_add_ref(st, ref)
        0
    } E I kind == EXPR_CALL() {
        # field0=name_ptr, field1=name_len, field2=args, field3=arg_count
        name_ptr := expr_get_field0(expr)
        name_len := expr_get_field1(expr)
        ref := symref_new(name_ptr, name_len, 0, 0)
        symtable_add_ref(st, ref)
        args := expr_get_field2(expr)
        argc := expr_get_field3(expr)
        ai: mut i64 = 0
        L {
            I ai >= argc { B } E { 0 }
            arg := load_i64(args + ai * 8)
            collect_refs_expr(st, arg)
            ai = ai + 1
        }
        0
    } E I kind == EXPR_BINARY() {
        # field0=op, field1=lhs, field2=rhs
        collect_refs_expr(st, expr_get_field1(expr))
        collect_refs_expr(st, expr_get_field2(expr))
        0
    } E I kind == EXPR_UNARY() {
        # field0=op, field1=operand
        collect_refs_expr(st, expr_get_field1(expr))
        0
    } E I kind == EXPR_IF() {
        # field0=cond, field1=then, field2=else
        collect_refs_expr(st, expr_get_field0(expr))
        collect_refs_expr(st, expr_get_field1(expr))
        collect_refs_expr(st, expr_get_field2(expr))
        0
    } E I kind == EXPR_LOOP() {
        # field0=body (block expr)
        collect_refs_expr(st, expr_get_field0(expr))
        0
    } E I kind == EXPR_BLOCK() {
        # field0=stmts_ptr, field1=stmts_count
        stmts := expr_get_field0(expr)
        count := expr_get_field1(expr)
        collect_refs_stmts(st, stmts, count)
        0
    } E I kind == EXPR_METHOD_CALL() {
        # field0=receiver, field1=name_ptr, field2=name_len, field3=args, field4=argc
        collect_refs_expr(st, expr_get_field0(expr))
        name_ptr := expr_get_field1(expr)
        name_len := expr_get_field2(expr)
        ref := symref_new(name_ptr, name_len, 0, 0)
        symtable_add_ref(st, ref)
        args := expr_get_field3(expr)
        argc := expr_get_field4(expr)
        ai: mut i64 = 0
        L {
            I ai >= argc { B } E { 0 }
            arg := load_i64(args + ai * 8)
            collect_refs_expr(st, arg)
            ai = ai + 1
        }
        0
    } E I kind == EXPR_FIELD() {
        # field0=receiver, field1=field_name_ptr, field2=field_name_len
        collect_refs_expr(st, expr_get_field0(expr))
        0
    } E I kind == EXPR_INDEX() {
        # field0=receiver, field1=index
        collect_refs_expr(st, expr_get_field0(expr))
        collect_refs_expr(st, expr_get_field1(expr))
        0
    } E I kind == EXPR_ARRAY() {
        # field0=elements, field1=count
        elems := expr_get_field0(expr)
        count := expr_get_field1(expr)
        ei: mut i64 = 0
        L {
            I ei >= count { B } E { 0 }
            elem := load_i64(elems + ei * 8)
            collect_refs_expr(st, elem)
            ei = ei + 1
        }
        0
    } E I kind == EXPR_STRUCT_LIT() {
        # field0=name_ptr, field1=name_len, field2=fields, field3=field_count
        name_ptr := expr_get_field0(expr)
        name_len := expr_get_field1(expr)
        ref := symref_new(name_ptr, name_len, 0, 0)
        symtable_add_ref(st, ref)
        fields := expr_get_field2(expr)
        fc := expr_get_field3(expr)
        fi: mut i64 = 0
        L {
            I fi >= fc { B } E { 0 }
            # Each struct field init: value_expr at some offset
            fval := load_i64(fields + fi * 8)
            collect_refs_expr(st, fval)
            fi = fi + 1
        }
        0
    } E I kind == EXPR_ASSIGN() {
        # field0=target, field1=value
        collect_refs_expr(st, expr_get_field0(expr))
        collect_refs_expr(st, expr_get_field1(expr))
        0
    } E I kind == EXPR_MATCH() {
        # field0=scrutinee, field1=arms, field2=arm_count
        collect_refs_expr(st, expr_get_field0(expr))
        0
    } E I kind == EXPR_SELF_CALL() {
        # field0=args, field1=arg_count
        args := expr_get_field0(expr)
        argc := expr_get_field1(expr)
        ai: mut i64 = 0
        L {
            I ai >= argc { B } E { 0 }
            arg := load_i64(args + ai * 8)
            collect_refs_expr(st, arg)
            ai = ai + 1
        }
        0
    } E { 0 }
}

# Collect refs from statements (56-byte inline layout)
F collect_refs_stmts(st: i64, stmts: i64, count: i64) -> i64 {
    i: mut i64 = 0
    L {
        I i >= count { B } E { 0 }
        # StmtNode: kind(8) + span_start(8) + span_end(8) + field0(8) + field1(8) + field2(8) + field3(8) = 56 bytes
        stmt_ptr := stmts + i * 56
        kind := load_i64(stmt_ptr + 0)

        I kind == STMT_LET() {
            # field0=name_ptr, field1=name_len, field2=type_expr, field3=init_expr
            name_ptr := load_i64(stmt_ptr + 24)
            name_len := load_i64(stmt_ptr + 32)
            # Add variable as both def and ref source
            vdef := symdef_new(SYM_VARIABLE(), name_ptr, name_len, 0, 0)
            symtable_add_def(st, vdef)
            # Collect refs from init expr
            init := load_i64(stmt_ptr + 48)
            collect_refs_expr(st, init)
            0
        } E I kind == STMT_EXPR() {
            # field0=expr
            expr := load_i64(stmt_ptr + 24)
            collect_refs_expr(st, expr)
            0
        } E I kind == STMT_RETURN() {
            # field0=expr (may be 0)
            expr := load_i64(stmt_ptr + 24)
            I expr != 0 { collect_refs_expr(st, expr); 0 } E { 0 }
        } E { 0 }

        i = i + 1
    }
    0
}

# Collect all refs from function bodies
F collect_all_refs(st: i64, items: i64, count: i64) -> i64 {
    i: mut i64 = 0
    L {
        I i >= count { B } E { 0 }
        item := load_i64(items + i * 8)
        I item == 0 { i = i + 1; C } E { 0 }
        kind := item_get_kind(item)

        I kind == ITEM_FUNCTION() {
            body := item_get_data3(item)
            collect_refs_expr(st, body)
            0
        } E I kind == 7 {  # ITEM_IMPL
            methods := item_get_data0(item)
            method_count := item_get_data1(item)
            mi: mut i64 = 0
            L {
                I mi >= method_count { B } E { 0 }
                method := load_i64(methods + mi * 8)
                I method != 0 {
                    body := item_get_data3(method)
                    collect_refs_expr(st, body)
                    0
                } E { 0 }
                mi = mi + 1
            }
            0
        } E { 0 }

        i = i + 1
    }
    0
}

# ============================================================================
# Symbol Lookup
# ============================================================================

# Find symbol at given byte offset in source
# Returns name_ptr+name_len packed: result_ptr at out+0, result_len at out+8
F find_symbol_at_offset(st: i64, src: i64, src_len: i64, offset: i64, out: i64) -> i64 {
    # Check definitions first
    dc := symtable_defs_count(st)
    di: mut i64 = 0
    L {
        I di >= dc { B } E { 0 }
        def := symtable_get_def(st, di)
        np := symdef_name_ptr(def)
        nl := symdef_name_len(def)
        # For now, scan source for identifier at offset
        # We'll use a simpler approach: find the word at offset
        di = di + 1
    }
    # Extract word at offset from source
    find_word_at_offset(src, src_len, offset, out)
}

# Find the identifier word at a given byte offset
F find_word_at_offset(src: i64, src_len: i64, offset: i64, out: i64) -> i64 {
    I offset >= src_len {
        store_i64(out, 0)
        store_i64(out + 8, 0)
        R 0
    } E { 0 }
    # Go back to start of word
    start: mut i64 = offset
    L {
        I start <= 0 { B } E { 0 }
        ch := load_byte(src + start - 1)
        I is_ident_char(ch) == 1 { start = start - 1; 0 } E { B }
    }
    # Go forward to end of word
    end: mut i64 = offset
    L {
        I end >= src_len { B } E { 0 }
        ch := load_byte(src + end)
        I is_ident_char(ch) == 1 { end = end + 1; 0 } E { B }
    }
    I end <= start {
        store_i64(out, 0)
        store_i64(out + 8, 0)
        R 0
    } E { 0 }
    store_i64(out, src + start)
    store_i64(out + 8, end - start)
    1
}

F is_ident_char(ch: i64) -> i64 {
    I ch >= 65 {
        I ch <= 90 { R 1 } E { 0 }  # A-Z
    } E { 0 }
    I ch >= 97 {
        I ch <= 122 { R 1 } E { 0 }  # a-z
    } E { 0 }
    I ch >= 48 {
        I ch <= 57 { R 1 } E { 0 }  # 0-9
    } E { 0 }
    I ch == 95 { R 1 } E { 0 }  # _
    0
}

# Find definition by name
F find_definition_by_name(st: i64, name_ptr: i64, name_len: i64) -> i64 {
    dc := symtable_defs_count(st)
    i: mut i64 = 0
    L {
        I i >= dc { B } E { 0 }
        def := symtable_get_def(st, i)
        np := symdef_name_ptr(def)
        nl := symdef_name_len(def)
        I nl == name_len {
            I lsp_memcmp(np, name_ptr, nl) == 0 {
                R def
            } E { 0 }
        } E { 0 }
        i = i + 1
    }
    0
}

# Find all references matching name (returns count, fills result array)
# results: pre-allocated array of i64 pointers to symref
# Returns count of matches
F find_all_references(st: i64, name_ptr: i64, name_len: i64, results: i64, max_results: i64) -> i64 {
    rc := symtable_refs_count(st)
    found: mut i64 = 0
    i: mut i64 = 0
    L {
        I i >= rc { B } E { 0 }
        I found >= max_results { B } E { 0 }
        ref := symtable_get_ref(st, i)
        np := symref_name_ptr(ref)
        nl := symref_name_len(ref)
        I nl == name_len {
            I lsp_memcmp(np, name_ptr, nl) == 0 {
                store_i64(results + found * 8, ref)
                found = found + 1
                0
            } E { 0 }
        } E { 0 }
        i = i + 1
    }
    found
}

# Build function signature string for hover
# item: ITEM_FUNCTION item pointer
# Returns sb (StringBuffer) with signature
F build_function_signature(item: i64) -> i64 {
    sb := sb_new(256)
    sb_append_cstr(sb, "F ")
    name_ptr := item_get_name_ptr(item)
    name_len := item_get_name_len(item)
    sb_append_bytes(sb, name_ptr, name_len)
    sb_append_byte(sb, 40)  # (

    params := item_get_data0(item)
    param_count := item_get_data1(item)
    pi: mut i64 = 0
    L {
        I pi >= param_count { B } E { 0 }
        I pi > 0 { sb_append_cstr(sb, ", "); 0 } E { 0 }
        param := load_i64(params + pi * 8)
        I param != 0 {
            pn_ptr := param_get_name_ptr(param)
            pn_len := param_get_name_len(param)
            sb_append_bytes(sb, pn_ptr, pn_len)
            sb_append_cstr(sb, ": ")
            pt_ptr := param_get_type_ptr(param)
            pt_len := param_get_type_len(param)
            I pt_len > 0 {
                sb_append_bytes(sb, pt_ptr, pt_len)
                0
            } E {
                sb_append_cstr(sb, "i64")
                0
            }
        } E { 0 }
        pi = pi + 1
    }
    sb_append_byte(sb, 41)  # )

    # Return type
    ret_type := item_get_data2(item)
    I ret_type != 0 {
        sb_append_cstr(sb, " -> ")
        # ret_type is a type node ptr; use its text representation
        # For simplicity, check if it's a named type
        rk := load_i64(ret_type)
        I rk == 1 {  # TYPE_NAMED (simple text)
            rt_ptr := load_i64(ret_type + 8)
            rt_len := load_i64(ret_type + 16)
            I rt_len > 0 {
                sb_append_bytes(sb, rt_ptr, rt_len)
                0
            } E {
                sb_append_cstr(sb, "i64")
                0
            }
        } E {
            sb_append_cstr(sb, "i64")
            0
        }
    } E { 0 }

    sb
}

# Build struct info string for hover
F build_struct_info(item: i64) -> i64 {
    sb := sb_new(256)
    sb_append_cstr(sb, "S ")
    name_ptr := item_get_name_ptr(item)
    name_len := item_get_name_len(item)
    sb_append_bytes(sb, name_ptr, name_len)
    sb_append_cstr(sb, " {\\n")

    fields := item_get_data0(item)
    field_count := item_get_data1(item)
    fi: mut i64 = 0
    L {
        I fi >= field_count { B } E { 0 }
        field := load_i64(fields + fi * 8)
        I field != 0 {
            sb_append_cstr(sb, "    ")
            fn_ptr := field_get_name_ptr(field)
            fn_len := field_get_name_len(field)
            sb_append_bytes(sb, fn_ptr, fn_len)
            sb_append_cstr(sb, ": ")
            ft_ptr := field_get_type_ptr(field)
            ft_len := field_get_type_len(field)
            I ft_len > 0 {
                sb_append_bytes(sb, ft_ptr, ft_len)
                0
            } E {
                sb_append_cstr(sb, "i64")
                0
            }
            sb_append_cstr(sb, "\\n")
            0
        } E { 0 }
        fi = fi + 1
    }

    sb_append_byte(sb, 125)  # }
    sb
}
