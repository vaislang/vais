# Vais Self-Hosting Compiler - Main Entry Point
# Minimal version for bootstrapping
# Uses hardcoded test file path for initial testing

# Result structure for IR generation
S IrResult {
    ptr: i64,
    len: i64
}

F main() -> i64 {
    puts("=================================\n")
    puts("  Vais Self-Hosting Compiler\n")
    puts("  Version: 0.1.0\n")
    puts("=================================\n\n")

    # For initial testing, use a hardcoded path
    input_path := "selfhost/bootstrap_test.vais"

    puts("Compiling: ")
    puts(input_path)
    puts("\n")

    # Read source file - returns ptr with len stored at ptr-8
    source_data := read_file(input_path)
    I source_data == 0 {
        puts("[ERROR] Cannot read input file\n")
        1
    } E {
        # Len is stored before the data
        source_len := load_i64(source_data - 8)
        puts("[INFO] Read ")
        print_i64(source_len)
        puts(" bytes from source file\n")

        # Count lines in source
        line_count := count_lines(source_data, source_len)
        print_info("Parsed source file")
        puts("       Lines: ")
        print_i64(line_count)
        putchar(10)
        puts("       Bytes: ")
        print_i64(source_len)
        putchar(10)

        # Generate placeholder output (for now)
        result := generate_placeholder_ir()

        puts("[INFO] Generated ")
        print_i64(result.len)
        puts(" bytes of LLVM IR\n")

        # Write to output file
        out_fp := fopen("selfhost/main_output.ll", "wb")
        I out_fp == 0 {
            puts("[ERROR] Cannot create output file\n")
            free(source_data - 8)
            1
        } E {
            fwrite(result.ptr, 1, result.len, out_fp)
            fclose(out_fp)
            free(result.ptr)
            free(source_data - 8)

            puts("[OK] Generated: selfhost/main_output.ll\n")
            puts("[OK] Compilation successful!\n")
            0
        }
    }
}

# Read entire file into memory
# Returns pointer to data, with length stored 8 bytes before data
# Returns 0 on failure
F read_file(path: str) -> i64 {
    fp := fopen(path, "rb")
    I fp == 0 {
        0
    } E {
        # Get file size
        fseek(fp, 0, 2)  # SEEK_END = 2
        size := ftell(fp)
        fseek(fp, 0, 0)  # SEEK_SET = 0

        # Allocate (8 bytes for len + size + 1 for null)
        buf := malloc(size + 9)
        I buf == 0 {
            fclose(fp)
            0
        } E {
            bytes_read := fread(buf + 8, 1, size, fp)
            store_byte(buf + 8 + bytes_read, 0)  # null terminate
            store_i64(buf, bytes_read)  # store length
            fclose(fp)
            buf + 8  # return pointer to data
        }
    }
}

# Count newlines in buffer
F count_lines(data: i64, len: i64) -> i64 {
    count: mut i64 = 0
    i: mut i64 = 0
    L {
        I i >= len { B } E { 0 }
        byte := load_byte(data + i)
        I byte == 10 {  # newline
            count = count + 1
            0
        } E { 0 }
        i = i + 1
    }
    I len > 0 {
        # Count last line if doesn't end with newline
        last_byte := load_byte(data + len - 1)
        I last_byte != 10 {
            count + 1
        } E {
            count
        }
    } E {
        count
    }
}

# Print integer to stdout
F print_i64(val: i64) -> i64 {
    I val == 0 {
        putchar(48)
        0
    } E I val < 0 {
        putchar(45)
        print_i64(0 - val)
    } E {
        I val >= 10 {
            print_i64(val / 10)
            0
        } E { 0 }
        putchar(48 + (val % 10))
        0
    }
}

# Generate placeholder LLVM IR
F generate_placeholder_ir() -> IrResult {
    ir := malloc(512)
    I ir == 0 {
        IrResult { ptr: 0, len: 0 }
    } E {
        pos: mut i64 = 0

        # Write IR header - use write_line for newlines
        pos = write_line(ir, pos, "; Generated by Vais Self-Hosting Compiler")
        pos = write_str(ir, pos, "target triple = ")
        pos = write_byte(ir, pos, 34)  # "
        pos = write_str(ir, pos, "x86_64-apple-macosx")
        pos = write_byte(ir, pos, 34)  # "
        pos = write_byte(ir, pos, 10)  # newline
        pos = write_byte(ir, pos, 10)  # newline

        pos = write_str(ir, pos, "@.str = private constant [26 x i8] c")
        pos = write_byte(ir, pos, 34)  # "
        pos = write_str(ir, pos, "Vais self-hosting works!")
        pos = write_byte(ir, pos, 92)  # backslash
        pos = write_str(ir, pos, "0A")
        pos = write_byte(ir, pos, 92)  # backslash
        pos = write_str(ir, pos, "00")
        pos = write_byte(ir, pos, 34)  # "
        pos = write_byte(ir, pos, 10)  # newline
        pos = write_byte(ir, pos, 10)  # newline

        pos = write_line(ir, pos, "declare i32 @puts(ptr)")
        pos = write_byte(ir, pos, 10)  # newline
        pos = write_line(ir, pos, "define i64 @main() {")
        pos = write_line(ir, pos, "  call i32 @puts(ptr @.str)")
        pos = write_line(ir, pos, "  ret i64 0")
        pos = write_line(ir, pos, "}")

        store_byte(ir + pos, 0)
        IrResult { ptr: ir, len: pos }
    }
}

# Write string to buffer at position, return new position
F write_str(buf: i64, pos: i64, s: str) -> i64 {
    slen := strlen(s)
    memcpy_str(buf + pos, s, slen)
    pos + slen
}

# Write single byte to buffer
F write_byte(buf: i64, pos: i64, byte: i64) -> i64 {
    store_byte(buf + pos, byte)
    pos + 1
}

# Write string followed by newline
F write_line(buf: i64, pos: i64, s: str) -> i64 {
    new_pos := write_str(buf, pos, s)
    write_byte(buf, new_pos, 10)
}

# ============================================================================
# Error Reporting Functions
# ============================================================================

# Print error with location: "error[E001]: message"
F print_error(code: str, msg: str) -> i64 {
    puts("error[")
    puts(code)
    puts("]: ")
    puts(msg)
    putchar(10)
    0
}

# Print error with file location
F print_error_at(file: str, line: i64, col: i64, code: str, msg: str) -> i64 {
    puts("error[")
    puts(code)
    puts("]: ")
    puts(msg)
    putchar(10)
    puts("  --> ")
    puts(file)
    putchar(58)  # ':'
    print_i64(line)
    putchar(58)  # ':'
    print_i64(col)
    putchar(10)
    0
}

# Print warning
F print_warning(msg: str) -> i64 {
    puts("warning: ")
    puts(msg)
    putchar(10)
    0
}

# Print info message
F print_info(msg: str) -> i64 {
    puts("[INFO] ")
    puts(msg)
    putchar(10)
    0
}

# Print a line from source with line number
F print_source_line(data: i64, len: i64, line_num: i64) -> i64 {
    # Find line start
    current_line: mut i64 = 1
    line_start: mut i64 = 0
    i: mut i64 = 0

    L {
        I current_line >= line_num { B } E { 0 }
        I i >= len { B } E { 0 }
        I load_byte(data + i) == 10 {
            current_line = current_line + 1
            line_start = i + 1
            0
        } E { 0 }
        i = i + 1
    }

    # Find line end
    line_end: mut i64 = line_start
    L {
        I line_end >= len { B } E { 0 }
        I load_byte(data + line_end) == 10 { B } E { 0 }
        line_end = line_end + 1
    }

    # Print line number
    puts("  ")
    print_i64(line_num)
    puts(" | ")

    # Print line content
    j: mut i64 = line_start
    L {
        I j >= line_end { B } E { 0 }
        putchar(load_byte(data + j))
        j = j + 1
    }
    putchar(10)
    0
}

# Print underline at column position
F print_underline(col: i64, width: i64) -> i64 {
    puts("    | ")
    # Print spaces until column
    i: mut i64 = 1
    L {
        I i >= col { B } E { 0 }
        putchar(32)  # space
        i = i + 1
    }
    # Print underline
    j: mut i64 = 0
    L {
        I j >= width { B } E { 0 }
        putchar(94)  # '^'
        j = j + 1
    }
    putchar(10)
    0
}
