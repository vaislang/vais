# Vais Self-Hosting Compiler - Stage 1 Entry Point
# Full Lexer -> Parser -> Codegen pipeline
# Based on integrated_test.vais (verified working)

# ============================================================================
# Token Constants
# ============================================================================

F TOK_KW_F() -> i64 = 1
F TOK_KW_S() -> i64 = 2
F TOK_KW_E() -> i64 = 3
F TOK_KW_I() -> i64 = 4
F TOK_KW_L() -> i64 = 5
F TOK_KW_R() -> i64 = 13
F TOK_KW_B() -> i64 = 14
F TOK_INT() -> i64 = 51
F TOK_IDENT() -> i64 = 54
F TOK_PLUS() -> i64 = 61
F TOK_MINUS() -> i64 = 62
F TOK_STAR() -> i64 = 63
F TOK_LPAREN() -> i64 = 91
F TOK_RPAREN() -> i64 = 92
F TOK_LBRACE() -> i64 = 93
F TOK_RBRACE() -> i64 = 94
F TOK_COMMA() -> i64 = 101
F TOK_COLON() -> i64 = 102
F TOK_DOT() -> i64 = 104
F TOK_ARROW() -> i64 = 107
F TOK_EQ() -> i64 = 81
F TOK_EOF() -> i64 = 200

# Type token constants
F TOK_TY_I64() -> i64 = 34

# ============================================================================
# AST Node Types
# ============================================================================

F EXPR_INT() -> i64 = 20
F EXPR_IDENT() -> i64 = 25
F EXPR_BINARY() -> i64 = 27
F BINOP_ADD() -> i64 = 1

# ============================================================================
# StringBuffer (procedural)
# ============================================================================

F sb_new(initial_cap: i64) -> i64 {
    sb := malloc(24)
    data := malloc(initial_cap)
    store_i64(sb + 0, data)
    store_i64(sb + 8, 0)
    store_i64(sb + 16, initial_cap)
    sb
}

F sb_get_data(sb: i64) -> i64 = load_i64(sb + 0)
F sb_get_len(sb: i64) -> i64 = load_i64(sb + 8)
F sb_get_cap(sb: i64) -> i64 = load_i64(sb + 16)

F sb_set_data(sb: i64, data: i64) -> i64 {
    store_i64(sb + 0, data)
    0
}

F sb_set_len(sb: i64, len: i64) -> i64 {
    store_i64(sb + 8, len)
    0
}

F sb_set_cap(sb: i64, cap: i64) -> i64 {
    store_i64(sb + 16, cap)
    0
}

F sb_grow_to(sb: i64, new_cap: i64) -> i64 {
    old_data := sb_get_data(sb)
    old_len := sb_get_len(sb)
    new_data := malloc(new_cap)
    memcpy(new_data, old_data, old_len)
    free(old_data)
    sb_set_data(sb, new_data)
    sb_set_cap(sb, new_cap)
    1
}

F sb_append_byte(sb: i64, byte: i64) -> i64 {
    len := sb_get_len(sb)
    cap := sb_get_cap(sb)
    I len >= cap {
        sb_grow_to(sb, cap * 2)
        0
    } E { 0 }
    data := sb_get_data(sb)
    store_byte(data + len, byte)
    sb_set_len(sb, len + 1)
    1
}

F sb_append_cstr(sb: i64, s: str) -> i64 {
    slen := strlen(s)
    len := sb_get_len(sb)
    cap := sb_get_cap(sb)
    I len + slen > cap {
        sb_grow_to(sb, len + slen + 1024)
        0
    } E { 0 }
    data := sb_get_data(sb)
    memcpy_str(data + len, s, slen)
    sb_set_len(sb, len + slen)
    1
}

F sb_append_i64(sb: i64, value: i64) -> i64 {
    I value == 0 {
        sb_append_byte(sb, 48)
    } E I value < 0 {
        sb_append_byte(sb, 45)
        sb_append_i64(sb, 0 - value)
    } E {
        I value >= 10 {
            sb_append_i64(sb, value / 10)
            0
        } E { 0 }
        sb_append_byte(sb, (value % 10) + 48)
    }
}

F sb_append_newline(sb: i64) -> i64 = sb_append_byte(sb, 10)

F sb_free(sb: i64) -> i64 {
    free(sb_get_data(sb))
    free(sb)
    1
}

# ============================================================================
# Lexer (procedural)
# ============================================================================

# Lexer struct: source(8) + source_len(8) + pos(8) + line(8) + col(8) = 40 bytes
F lexer_new(source: i64, len: i64) -> i64 {
    lex := malloc(40)
    store_i64(lex + 0, source)
    store_i64(lex + 8, len)
    store_i64(lex + 16, 0)   # pos
    store_i64(lex + 24, 1)   # line
    store_i64(lex + 32, 1)   # col
    lex
}

F lexer_get_source(lex: i64) -> i64 = load_i64(lex + 0)
F lexer_get_len(lex: i64) -> i64 = load_i64(lex + 8)
F lexer_get_pos(lex: i64) -> i64 = load_i64(lex + 16)
F lexer_set_pos(lex: i64, pos: i64) -> i64 {
    store_i64(lex + 16, pos)
    0
}

F lexer_is_eof(lex: i64) -> i64 {
    pos := lexer_get_pos(lex)
    len := lexer_get_len(lex)
    I pos >= len { 1 } E { 0 }
}

F lexer_peek(lex: i64) -> i64 {
    I lexer_is_eof(lex) == 1 { 0 }
    E {
        src := lexer_get_source(lex)
        pos := lexer_get_pos(lex)
        load_byte(src + pos)
    }
}

F lexer_advance(lex: i64) -> i64 {
    I lexer_is_eof(lex) == 1 { 0 }
    E {
        c := lexer_peek(lex)
        pos := lexer_get_pos(lex)
        lexer_set_pos(lex, pos + 1)
        c
    }
}

F is_digit(c: i64) -> i64 {
    I c >= 48 && c <= 57 { 1 } E { 0 }
}

F is_ident_start(c: i64) -> i64 {
    I (c >= 65 && c <= 90) || (c >= 97 && c <= 122) || c == 95 { 1 } E { 0 }
}

F is_ident_char(c: i64) -> i64 {
    I is_ident_start(c) == 1 || is_digit(c) == 1 { 1 } E { 0 }
}

F is_whitespace(c: i64) -> i64 {
    I c == 32 || c == 9 || c == 10 || c == 13 { 1 } E { 0 }
}

F lexer_skip_whitespace(lex: i64) -> i64 {
    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        c := lexer_peek(lex)
        I is_whitespace(c) == 0 { B } E { 0 }
        lexer_advance(lex)
    }
    1
}

F lexer_skip_comment(lex: i64) -> i64 {
    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        I lexer_peek(lex) == 10 { B } E { 0 }
        lexer_advance(lex)
    }
    1
}

F lexer_skip_whitespace_and_comments(lex: i64) -> i64 {
    L {
        lexer_skip_whitespace(lex)
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        I lexer_peek(lex) == 35 {
            lexer_skip_comment(lex)
            0
        } E {
            B
        }
    }
    1
}

# Token storage: kind(8) + value(8) + str_ptr(8) + str_len(8) + span_start(8) + span_end(8) = 48 bytes
F token_store(tokens: i64, idx: i64, kind: i64, value: i64, str_ptr: i64, str_len: i64, start: i64, end: i64) -> i64 {
    ptr := tokens + idx * 48
    store_i64(ptr + 0, kind)
    store_i64(ptr + 8, value)
    store_i64(ptr + 16, str_ptr)
    store_i64(ptr + 24, str_len)
    store_i64(ptr + 32, start)
    store_i64(ptr + 40, end)
    1
}

F token_get_kind(tokens: i64, idx: i64) -> i64 = load_i64(tokens + idx * 48 + 0)
F token_get_value(tokens: i64, idx: i64) -> i64 = load_i64(tokens + idx * 48 + 8)
F token_get_str_ptr(tokens: i64, idx: i64) -> i64 = load_i64(tokens + idx * 48 + 16)
F token_get_str_len(tokens: i64, idx: i64) -> i64 = load_i64(tokens + idx * 48 + 24)

F lexer_scan_number(lex: i64, tokens: i64, count: i64) -> i64 {
    start := lexer_get_pos(lex)
    value: mut i64 = 0
    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        c := lexer_peek(lex)
        I is_digit(c) == 0 { B } E { 0 }
        value = value * 10 + (c - 48)
        lexer_advance(lex)
    }
    end := lexer_get_pos(lex)
    token_store(tokens, count, TOK_INT(), value, 0, 0, start, end)
}

F lexer_scan_ident(lex: i64, tokens: i64, count: i64) -> i64 {
    start := lexer_get_pos(lex)
    src := lexer_get_source(lex)
    str_start := src + start

    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        I is_ident_char(lexer_peek(lex)) == 0 { B } E { 0 }
        lexer_advance(lex)
    }

    end := lexer_get_pos(lex)
    len := end - start

    # Check for keywords
    kind: mut i64 = TOK_IDENT()

    I len == 1 {
        c := load_byte(str_start)
        I c == 70 { kind = TOK_KW_F(); 0 }
        E I c == 83 { kind = TOK_KW_S(); 0 }
        E I c == 73 { kind = TOK_KW_I(); 0 }
        E I c == 76 { kind = TOK_KW_L(); 0 }
        E I c == 82 { kind = TOK_KW_R(); 0 }
        E I c == 66 { kind = TOK_KW_B(); 0 }
        E I c == 69 { kind = TOK_KW_E(); 0 }
        E { 0 }
    } E I len == 3 {
        # Check for i64
        c0 := load_byte(str_start)
        c1 := load_byte(str_start + 1)
        c2 := load_byte(str_start + 2)
        I c0 == 105 && c1 == 54 && c2 == 52 {
            kind = TOK_TY_I64()
            0
        } E { 0 }
    } E { 0 }

    token_store(tokens, count, kind, 0, str_start, len, start, end)
}

F lexer_scan_operator(lex: i64, tokens: i64, count: i64) -> i64 {
    start := lexer_get_pos(lex)
    c := lexer_advance(lex)
    kind: mut i64 = 0

    I c == 40 { kind = TOK_LPAREN(); 0 }
    E I c == 41 { kind = TOK_RPAREN(); 0 }
    E I c == 123 { kind = TOK_LBRACE(); 0 }
    E I c == 125 { kind = TOK_RBRACE(); 0 }
    E I c == 44 { kind = TOK_COMMA(); 0 }
    E I c == 58 { kind = TOK_COLON(); 0 }
    E I c == 46 { kind = TOK_DOT(); 0 }
    E I c == 43 { kind = TOK_PLUS(); 0 }
    E I c == 45 {
        I lexer_peek(lex) == 62 {
            lexer_advance(lex)
            kind = TOK_ARROW()
            0
        } E {
            kind = TOK_MINUS()
            0
        }
    }
    E I c == 42 { kind = TOK_STAR(); 0 }
    E I c == 61 { kind = TOK_EQ(); 0 }
    E { 0 }

    end := lexer_get_pos(lex)
    token_store(tokens, count, kind, 0, 0, 0, start, end)
}

F lexer_tokenize(lex: i64, tokens: i64) -> i64 {
    count: mut i64 = 0
    L {
        lexer_skip_whitespace_and_comments(lex)
        I lexer_is_eof(lex) == 1 { B } E { 0 }

        c := lexer_peek(lex)

        I is_digit(c) == 1 {
            lexer_scan_number(lex, tokens, count)
            count = count + 1
            0
        } E I is_ident_start(c) == 1 {
            lexer_scan_ident(lex, tokens, count)
            count = count + 1
            0
        } E {
            lexer_scan_operator(lex, tokens, count)
            count = count + 1
            0
        }
    }

    # Add EOF
    pos := lexer_get_pos(lex)
    token_store(tokens, count, TOK_EOF(), 0, 0, 0, pos, pos)
    count + 1
}

F lexer_free(lex: i64) -> i64 {
    free(lex)
    1
}

# ============================================================================
# Simple Parser (procedural)
# Parses: F name(param: i64) -> i64 = expr
# ============================================================================

# Parser struct: tokens(8) + token_count(8) + pos(8) + func_name_ptr(8) + func_name_len(8)
#                + param_name_ptr(8) + param_name_len(8) + body_expr(8) = 64 bytes
F parser_new(tokens: i64, count: i64) -> i64 {
    p := malloc(64)
    store_i64(p + 0, tokens)
    store_i64(p + 8, count)
    store_i64(p + 16, 0)  # pos
    store_i64(p + 24, 0)  # func_name_ptr
    store_i64(p + 32, 0)  # func_name_len
    store_i64(p + 40, 0)  # param_name_ptr
    store_i64(p + 48, 0)  # param_name_len
    store_i64(p + 56, 0)  # body_expr
    p
}

F parser_get_tokens(p: i64) -> i64 = load_i64(p + 0)
F parser_get_count(p: i64) -> i64 = load_i64(p + 8)
F parser_get_pos(p: i64) -> i64 = load_i64(p + 16)
F parser_set_pos(p: i64, pos: i64) -> i64 {
    store_i64(p + 16, pos)
    0
}

F parser_current_kind(p: i64) -> i64 {
    tokens := parser_get_tokens(p)
    pos := parser_get_pos(p)
    token_get_kind(tokens, pos)
}

F parser_advance(p: i64) -> i64 {
    pos := parser_get_pos(p)
    parser_set_pos(p, pos + 1)
    pos
}

F parser_expect(p: i64, kind: i64) -> i64 {
    I parser_current_kind(p) == kind {
        parser_advance(p)
        1
    } E { 0 }
}

# Parse simple expression: ident, int, or binary add
# Returns pointer to expression node or 0 on error
# Expr node: kind(8) + field0(8) + field1(8) + field2(8) = 32 bytes
F parser_parse_primary(p: i64) -> i64 {
    kind := parser_current_kind(p)
    tokens := parser_get_tokens(p)
    pos := parser_get_pos(p)

    I kind == TOK_INT() {
        value := token_get_value(tokens, pos)
        parser_advance(p)
        expr := malloc(32)
        store_i64(expr + 0, EXPR_INT())
        store_i64(expr + 8, value)
        store_i64(expr + 16, 0)
        store_i64(expr + 24, 0)
        expr
    } E I kind == TOK_IDENT() {
        str_ptr := token_get_str_ptr(tokens, pos)
        str_len := token_get_str_len(tokens, pos)
        parser_advance(p)
        expr := malloc(32)
        store_i64(expr + 0, EXPR_IDENT())
        store_i64(expr + 8, str_ptr)
        store_i64(expr + 16, str_len)
        store_i64(expr + 24, 0)
        expr
    } E { 0 }
}

F parser_parse_expr(p: i64) -> i64 {
    left := parser_parse_primary(p)
    I left == 0 { R 0 }

    # Check for binary +
    I parser_current_kind(p) == TOK_PLUS() {
        parser_advance(p)
        right := parser_parse_primary(p)
        I right == 0 { R left }

        expr := malloc(32)
        store_i64(expr + 0, EXPR_BINARY())
        store_i64(expr + 8, BINOP_ADD())
        store_i64(expr + 16, left)
        store_i64(expr + 24, right)
        expr
    } E { left }
}

# Parse: F name(param: i64) -> i64 = expr
F parser_parse_function(p: i64) -> i64 {
    # Expect F
    I parser_expect(p, TOK_KW_F()) == 0 { R 0 }

    # Get function name
    tokens := parser_get_tokens(p)
    pos := parser_get_pos(p)
    I parser_current_kind(p) != TOK_IDENT() { R 0 }
    func_name_ptr := token_get_str_ptr(tokens, pos)
    func_name_len := token_get_str_len(tokens, pos)
    store_i64(p + 24, func_name_ptr)
    store_i64(p + 32, func_name_len)
    parser_advance(p)

    # Expect (
    I parser_expect(p, TOK_LPAREN()) == 0 { R 0 }

    # Get param name
    pos2 := parser_get_pos(p)
    I parser_current_kind(p) != TOK_IDENT() { R 0 }
    param_name_ptr := token_get_str_ptr(tokens, pos2)
    param_name_len := token_get_str_len(tokens, pos2)
    store_i64(p + 40, param_name_ptr)
    store_i64(p + 48, param_name_len)
    parser_advance(p)

    # Expect : i64 )
    I parser_expect(p, TOK_COLON()) == 0 { R 0 }
    I parser_expect(p, TOK_TY_I64()) == 0 { R 0 }
    I parser_expect(p, TOK_RPAREN()) == 0 { R 0 }

    # Expect -> i64
    I parser_expect(p, TOK_ARROW()) == 0 { R 0 }
    I parser_expect(p, TOK_TY_I64()) == 0 { R 0 }

    # Expect =
    I parser_expect(p, TOK_EQ()) == 0 { R 0 }

    # Parse body expression
    body := parser_parse_expr(p)
    store_i64(p + 56, body)

    1
}

F parser_get_func_name_ptr(p: i64) -> i64 = load_i64(p + 24)
F parser_get_func_name_len(p: i64) -> i64 = load_i64(p + 32)
F parser_get_param_name_ptr(p: i64) -> i64 = load_i64(p + 40)
F parser_get_param_name_len(p: i64) -> i64 = load_i64(p + 48)
F parser_get_body_expr(p: i64) -> i64 = load_i64(p + 56)

F parser_free(p: i64) -> i64 {
    free(p)
    1
}

# ============================================================================
# Code Generator (procedural)
# ============================================================================

F cg_new() -> i64 {
    cg := malloc(16)
    sb := sb_new(4096)
    store_i64(cg + 0, sb)
    store_i64(cg + 8, 0)  # reg_counter
    cg
}

F cg_get_sb(cg: i64) -> i64 = load_i64(cg + 0)

F cg_fresh_reg(cg: i64) -> i64 {
    r := load_i64(cg + 8)
    store_i64(cg + 8, r + 1)
    r
}

F cg_emit(cg: i64, s: str) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_cstr(sb, s)
}

F cg_emit_i64(cg: i64, v: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_i64(sb, v)
}

F cg_emit_newline(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_newline(sb)
}

F cg_emit_quote(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_byte(sb, 34)
}

F cg_emit_str(cg: i64, ptr: i64, len: i64) -> i64 {
    sb := cg_get_sb(cg)
    i: mut i64 = 0
    L {
        I i >= len { B } E { 0 }
        sb_append_byte(sb, load_byte(ptr + i))
        i = i + 1
    }
    1
}

F cg_emit_header(cg: i64) -> i64 {
    cg_emit(cg, "; Generated by Vais Self-Hosting Compiler (vaisc-stage1)")
    cg_emit_newline(cg)
    cg_emit(cg, "source_filename = ")
    cg_emit_quote(cg)
    cg_emit(cg, "main")
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit(cg, "target triple = ")
    cg_emit_quote(cg)
    cg_emit(cg, "arm64-apple-macosx")
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit_newline(cg)
    1
}

# Generate expression, returns register number
F cg_gen_expr(cg: i64, expr: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    kind := load_i64(expr + 0)

    I kind == EXPR_INT() {
        value := load_i64(expr + 8)
        reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, reg)
        cg_emit(cg, " = add i64 ")
        cg_emit_i64(cg, value)
        cg_emit(cg, ", 0")
        cg_emit_newline(cg)
        reg
    } E I kind == EXPR_IDENT() {
        # Return param directly
        0 - 1  # Special marker for parameter
    } E I kind == EXPR_BINARY() {
        op := load_i64(expr + 8)
        left := load_i64(expr + 16)
        right := load_i64(expr + 24)

        left_reg := cg_gen_expr(cg, left, param_name_ptr, param_name_len)
        right_reg := cg_gen_expr(cg, right, param_name_ptr, param_name_len)

        result_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " = add i64 ")

        # Left operand
        I left_reg == 0 - 1 {
            cg_emit(cg, "%")
            cg_emit_str(cg, param_name_ptr, param_name_len)
            0
        } E {
            cg_emit(cg, "%")
            cg_emit_i64(cg, left_reg)
            0
        }

        cg_emit(cg, ", ")

        # Right operand
        I right_reg == 0 - 1 {
            cg_emit(cg, "%")
            cg_emit_str(cg, param_name_ptr, param_name_len)
            0
        } E {
            cg_emit(cg, "%")
            cg_emit_i64(cg, right_reg)
            0
        }

        cg_emit_newline(cg)
        result_reg
    } E { 0 }
}

F cg_gen_function(cg: i64, func_name_ptr: i64, func_name_len: i64,
                   param_name_ptr: i64, param_name_len: i64, body_expr: i64) -> i64 {
    cg_emit(cg, "define i64 @")
    cg_emit_str(cg, func_name_ptr, func_name_len)
    cg_emit(cg, "(i64 %")
    cg_emit_str(cg, param_name_ptr, param_name_len)
    cg_emit(cg, ") {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)

    # Generate body
    result_reg := cg_gen_expr(cg, body_expr, param_name_ptr, param_name_len)

    # Return
    cg_emit(cg, "  ret i64 ")
    I result_reg == 0 - 1 {
        cg_emit(cg, "%")
        cg_emit_str(cg, param_name_ptr, param_name_len)
        0
    } E {
        cg_emit(cg, "%")
        cg_emit_i64(cg, result_reg)
        0
    }
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)
    1
}

F cg_gen_main_that_calls(cg: i64, func_name_ptr: i64, func_name_len: i64) -> i64 {
    cg_emit(cg, "declare i32 @printf(i8*, ...)")
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    # Format string: "Result: %ld\n\0" = 13 bytes
    cg_emit(cg, "@.str.fmt = private constant [13 x i8] c")
    cg_emit_quote(cg)
    cg_emit(cg, "Result: %ld")
    sb := cg_get_sb(cg)
    sb_append_byte(sb, 92)  # backslash
    sb_append_byte(sb, 48)  # 0
    sb_append_byte(sb, 65)  # A
    sb_append_byte(sb, 92)  # backslash
    sb_append_byte(sb, 48)  # 0
    sb_append_byte(sb, 48)  # 0
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    cg_emit(cg, "define i64 @main() {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %result = call i64 @")
    cg_emit_str(cg, func_name_ptr, func_name_len)
    cg_emit(cg, "(i64 10)")
    cg_emit_newline(cg)
    cg_emit(cg, "  %fmt = getelementptr [13 x i8], [13 x i8]* @.str.fmt, i64 0, i64 0")
    cg_emit_newline(cg)
    cg_emit(cg, "  call i32 (i8*, ...) @printf(i8* %fmt, i64 %result)")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret i64 0")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    1
}

F cg_get_output(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_get_data(sb)
}

F cg_get_output_len(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_get_len(sb)
}

F cg_free(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_free(sb)
    free(cg)
    1
}

# ============================================================================
# Print helpers
# ============================================================================

F print_i64(val: i64) -> i64 {
    I val == 0 {
        putchar(48)
        0
    } E I val < 0 {
        putchar(45)
        print_i64(0 - val)
    } E {
        I val >= 10 {
            print_i64(val / 10)
            0
        } E { 0 }
        putchar(48 + (val % 10))
        0
    }
}

F print_str(ptr: i64, len: i64) -> i64 {
    i: mut i64 = 0
    L {
        I i >= len { B } E { 0 }
        putchar(load_byte(ptr + i))
        i = i + 1
    }
    1
}

# Read file into memory (length stored at ptr-8)
F read_file(path: str) -> i64 {
    fp := fopen(path, "rb")
    I fp == 0 { 0 }
    E {
        fseek(fp, 0, 2)  # SEEK_END
        size := ftell(fp)
        fseek(fp, 0, 0)  # SEEK_SET

        buf := malloc(size + 9)
        I buf == 0 {
            fclose(fp)
            0
        } E {
            bytes_read := fread(buf + 8, 1, size, fp)
            store_byte(buf + 8 + bytes_read, 0)
            store_i64(buf, bytes_read)
            fclose(fp)
            buf + 8
        }
    }
}

# ============================================================================
# Main Entry Point
# ============================================================================

F main() -> i64 {
    puts("=======================================\n")
    puts("  Vais Self-Hosting Compiler (Stage 1)\n")
    puts("  Version: 0.2.0\n")
    puts("=======================================\n\n")

    # Hardcoded path for bootstrapping
    input_path := "selfhost/test2.vais"

    puts("[INFO] Compiling: ")
    puts(input_path)
    putchar(10)

    # Read source file
    source_data := read_file(input_path)
    I source_data == 0 {
        puts("[ERROR] Cannot read input file\n")
        R 1
    }

    source_len := load_i64(source_data - 8)
    puts("[INFO] Read ")
    print_i64(source_len)
    puts(" bytes\n\n")

    # Step 1: Lexer
    puts("[1] Lexer...\n")
    lex := lexer_new(source_data, source_len)
    tokens := malloc(64 * 48)
    token_count := lexer_tokenize(lex, tokens)
    puts("    Tokens: ")
    print_i64(token_count)
    putchar(10)

    # Step 2: Parser
    puts("[2] Parser...\n")
    parser := parser_new(tokens, token_count)
    result := parser_parse_function(parser)
    I result == 1 {
        puts("    Parse: OK\n")
        puts("    Function: ")
        print_str(parser_get_func_name_ptr(parser), parser_get_func_name_len(parser))
        putchar(10)
        puts("    Param: ")
        print_str(parser_get_param_name_ptr(parser), parser_get_param_name_len(parser))
        putchar(10)
        0
    } E {
        puts("    Parse: FAILED\n")
        R 1
    }

    # Step 3: Codegen
    puts("[3] Codegen...\n")
    cg := cg_new()
    cg_emit_header(cg)
    cg_gen_function(cg,
        parser_get_func_name_ptr(parser), parser_get_func_name_len(parser),
        parser_get_param_name_ptr(parser), parser_get_param_name_len(parser),
        parser_get_body_expr(parser))
    cg_gen_main_that_calls(cg, parser_get_func_name_ptr(parser), parser_get_func_name_len(parser))

    # Print generated IR
    puts("\n--- Generated LLVM IR ---\n")
    ir_ptr := cg_get_output(cg)
    ir_len := cg_get_output_len(cg)
    print_str(ir_ptr, ir_len)
    puts("--- End of LLVM IR ---\n")

    # Write to file
    fp := fopen("selfhost/main_output.ll", "wb")
    I fp != 0 {
        fwrite(ir_ptr, 1, ir_len, fp)
        fclose(fp)
        puts("\n[OK] Written to selfhost/main_output.ll\n")
        0
    } E {
        puts("\n[ERROR] Could not write output file\n")
        0
    }

    # Cleanup
    cg_free(cg)
    parser_free(parser)
    lexer_free(lex)
    free(tokens)
    free(source_data - 8)

    puts("[OK] Compilation successful!\n")
    0
}
