# Vais Self-Hosting Compiler - Stage 1 Entry Point
# Full Lexer -> Parser -> Codegen pipeline
# Based on integrated_test.vais (verified working)

# ============================================================================
# Token Constants
# ============================================================================

# Keyword tokens (1-30)
F TOK_KW_F() -> i64 = 1        # function
F TOK_KW_S() -> i64 = 2        # struct
F TOK_KW_E() -> i64 = 3        # enum
F TOK_KW_I() -> i64 = 4        # if
F TOK_KW_L() -> i64 = 5        # loop
F TOK_KW_M() -> i64 = 6        # match
F TOK_KW_W() -> i64 = 7        # trait (With)
F TOK_KW_X() -> i64 = 8        # impl (eXtend)
F TOK_KW_T() -> i64 = 9        # type
F TOK_KW_U() -> i64 = 10       # use
F TOK_KW_P() -> i64 = 11       # pub
F TOK_KW_A() -> i64 = 12       # async
F TOK_KW_R() -> i64 = 13       # return
F TOK_KW_B() -> i64 = 14       # break
F TOK_KW_C() -> i64 = 15       # continue
F TOK_KW_TRUE() -> i64 = 16
F TOK_KW_FALSE() -> i64 = 17
F TOK_KW_MUT() -> i64 = 18
F TOK_KW_ELSE() -> i64 = 19
F TOK_KW_D() -> i64 = 20       # defer
F TOK_KW_O() -> i64 = 21       # union
F TOK_KW_N() -> i64 = 22       # extern
F TOK_KW_G() -> i64 = 23       # global
F TOK_KW_Y() -> i64 = 24       # await (also "await" keyword)

# Type keyword tokens (31-50)
F TOK_TY_I8() -> i64 = 31
F TOK_TY_I16() -> i64 = 32
F TOK_TY_I32() -> i64 = 33
F TOK_TY_I64() -> i64 = 34
F TOK_TY_I128() -> i64 = 35
F TOK_TY_U8() -> i64 = 36
F TOK_TY_U16() -> i64 = 37
F TOK_TY_U32() -> i64 = 38
F TOK_TY_U64() -> i64 = 39
F TOK_TY_U128() -> i64 = 40
F TOK_TY_F32() -> i64 = 41
F TOK_TY_F64() -> i64 = 42
F TOK_TY_BOOL() -> i64 = 43
F TOK_TY_STR() -> i64 = 44

# Literal tokens (51-60)
F TOK_INT() -> i64 = 51        # Integer literal
F TOK_FLOAT() -> i64 = 52      # Float literal
F TOK_STRING() -> i64 = 53     # String literal
F TOK_IDENT() -> i64 = 54      # Identifier

# Operator tokens (61-100)
F TOK_PLUS() -> i64 = 61       # +
F TOK_MINUS() -> i64 = 62      # -
F TOK_STAR() -> i64 = 63       # *
F TOK_SLASH() -> i64 = 64      # /
F TOK_PERCENT() -> i64 = 65    # %
F TOK_LT() -> i64 = 66         # <
F TOK_GT() -> i64 = 67         # >
F TOK_LT_EQ() -> i64 = 68      # <=
F TOK_GT_EQ() -> i64 = 69      # >=
F TOK_EQ_EQ() -> i64 = 70      # ==
F TOK_NOT_EQ() -> i64 = 71     # !=
F TOK_AMP() -> i64 = 72        # &
F TOK_PIPE() -> i64 = 73       # |
F TOK_CARET() -> i64 = 74      # ^
F TOK_TILDE() -> i64 = 75      # ~
F TOK_SHL() -> i64 = 76        # <<
F TOK_SHR() -> i64 = 77        # >>
F TOK_BANG() -> i64 = 78       # !
F TOK_NOT() -> i64 = 78        # ! (logical not) - same as TOK_BANG
F TOK_AND() -> i64 = 79        # &&
F TOK_OR() -> i64 = 80         # ||

# Assignment tokens (81-90)
F TOK_EQ() -> i64 = 81         # =
F TOK_COLON_EQ() -> i64 = 82   # :=
F TOK_PLUS_EQ() -> i64 = 83    # +=
F TOK_MINUS_EQ() -> i64 = 84   # -=
F TOK_STAR_EQ() -> i64 = 85    # *=
F TOK_SLASH_EQ() -> i64 = 86   # /=

# Delimiter tokens (91-100)
F TOK_LPAREN() -> i64 = 91     # (
F TOK_RPAREN() -> i64 = 92     # )
F TOK_LBRACE() -> i64 = 93     # {
F TOK_RBRACE() -> i64 = 94     # }
F TOK_LBRACKET() -> i64 = 95   # [
F TOK_RBRACKET() -> i64 = 96   # ]

# Punctuation tokens (101-120)
F TOK_COMMA() -> i64 = 101     # ,
F TOK_COLON() -> i64 = 102     # :
F TOK_SEMI() -> i64 = 103      # ;
F TOK_DOT() -> i64 = 104       # .
F TOK_DOT_DOT() -> i64 = 105   # ..
F TOK_DOT_DOT_EQ() -> i64 = 106 # ..=
F TOK_ARROW() -> i64 = 107     # ->
F TOK_FAT_ARROW() -> i64 = 108 # =>
F TOK_COLON_COLON() -> i64 = 109 # ::
F TOK_QUESTION() -> i64 = 110  # ?
F TOK_AT() -> i64 = 111        # @
F TOK_HASH() -> i64 = 112      # #

# Special tokens
F TOK_EOF() -> i64 = 200
F TOK_ERROR() -> i64 = 201

# ============================================================================
# AST Node Types
# ============================================================================

# Item types
F ITEM_FUNCTION() -> i64 = 1
F ITEM_STRUCT() -> i64 = 2
F ITEM_USE() -> i64 = 3
F ITEM_IMPL() -> i64 = 7

# Statement types
F STMT_LET() -> i64 = 10
F STMT_EXPR() -> i64 = 11
F STMT_RETURN() -> i64 = 12
F STMT_BREAK() -> i64 = 13
F STMT_CONTINUE() -> i64 = 14

# Expression types
F EXPR_INT() -> i64 = 20
F EXPR_BOOL() -> i64 = 22
F EXPR_STRING() -> i64 = 23
F EXPR_IDENT() -> i64 = 25
F EXPR_SELF_CALL() -> i64 = 26
F EXPR_BINARY() -> i64 = 27
F EXPR_UNARY() -> i64 = 28
F EXPR_IF() -> i64 = 30
F EXPR_LOOP() -> i64 = 31
F EXPR_CALL() -> i64 = 33
F EXPR_METHOD_CALL() -> i64 = 34
F EXPR_FIELD() -> i64 = 36
F EXPR_INDEX() -> i64 = 37
F EXPR_STRUCT_LIT() -> i64 = 40
F EXPR_BLOCK() -> i64 = 42
F EXPR_ASSIGN() -> i64 = 48
F EXPR_MATCH() -> i64 = 49

# Binary operators
F BINOP_ADD() -> i64 = 1
F BINOP_SUB() -> i64 = 2
F BINOP_MUL() -> i64 = 3
F BINOP_DIV() -> i64 = 4
F BINOP_MOD() -> i64 = 5
F BINOP_LT() -> i64 = 6
F BINOP_LTE() -> i64 = 7
F BINOP_GT() -> i64 = 8
F BINOP_GTE() -> i64 = 9
F BINOP_EQ() -> i64 = 10
F BINOP_NEQ() -> i64 = 11
F BINOP_AND() -> i64 = 12
F BINOP_OR() -> i64 = 13

# Unary operators
F UNOP_NEG() -> i64 = 1
F UNOP_NOT() -> i64 = 2

# ============================================================================
# StringBuffer (procedural)
# ============================================================================

F sb_new(initial_cap: i64) -> i64 {
    sb := malloc(24)
    data := malloc(initial_cap)
    store_i64(sb + 0, data)
    store_i64(sb + 8, 0)
    store_i64(sb + 16, initial_cap)
    sb
}

F sb_get_data(sb: i64) -> i64 = load_i64(sb + 0)
F sb_get_len(sb: i64) -> i64 = load_i64(sb + 8)
F sb_get_cap(sb: i64) -> i64 = load_i64(sb + 16)

F sb_set_data(sb: i64, data: i64) -> i64 {
    store_i64(sb + 0, data)
    0
}

F sb_set_len(sb: i64, len: i64) -> i64 {
    store_i64(sb + 8, len)
    0
}

F sb_set_cap(sb: i64, cap: i64) -> i64 {
    store_i64(sb + 16, cap)
    0
}

F sb_grow_to(sb: i64, new_cap: i64) -> i64 {
    old_data := sb_get_data(sb)
    old_len := sb_get_len(sb)
    new_data := malloc(new_cap)
    memcpy(new_data, old_data, old_len)
    free(old_data)
    sb_set_data(sb, new_data)
    sb_set_cap(sb, new_cap)
    1
}

F sb_append_byte(sb: i64, byte: i64) -> i64 {
    len := sb_get_len(sb)
    cap := sb_get_cap(sb)
    I len >= cap {
        sb_grow_to(sb, cap * 2)
        0
    } E { 0 }
    data := sb_get_data(sb)
    store_byte(data + len, byte)
    sb_set_len(sb, len + 1)
    1
}

F sb_append_cstr(sb: i64, s: str) -> i64 {
    slen := strlen(s)
    len := sb_get_len(sb)
    cap := sb_get_cap(sb)
    I len + slen > cap {
        sb_grow_to(sb, len + slen + 1024)
        0
    } E { 0 }
    data := sb_get_data(sb)
    memcpy_str(data + len, s, slen)
    sb_set_len(sb, len + slen)
    1
}

# Append bytes from i64 pointer
F sb_append_bytes(sb: i64, src: i64, slen: i64) -> i64 {
    len := sb_get_len(sb)
    cap := sb_get_cap(sb)
    I len + slen > cap {
        sb_grow_to(sb, len + slen + 1024)
        0
    } E { 0 }
    data := sb_get_data(sb)
    memcpy(data + len, src, slen)
    sb_set_len(sb, len + slen)
    1
}

F sb_append_i64(sb: i64, value: i64) -> i64 {
    I value == 0 {
        sb_append_byte(sb, 48)
    } E I value < 0 {
        sb_append_byte(sb, 45)
        sb_append_i64(sb, 0 - value)
    } E {
        I value >= 10 {
            sb_append_i64(sb, value / 10)
            0
        } E { 0 }
        sb_append_byte(sb, (value % 10) + 48)
    }
}

F sb_append_newline(sb: i64) -> i64 = sb_append_byte(sb, 10)

F sb_free(sb: i64) -> i64 {
    free(sb_get_data(sb))
    free(sb)
    1
}

# ============================================================================
# Lexer (procedural)
# ============================================================================

# Lexer struct: source(8) + source_len(8) + pos(8) + line(8) + col(8) = 40 bytes
F lexer_new(source: i64, len: i64) -> i64 {
    lex := malloc(40)
    store_i64(lex + 0, source)
    store_i64(lex + 8, len)
    store_i64(lex + 16, 0)   # pos
    store_i64(lex + 24, 1)   # line
    store_i64(lex + 32, 1)   # col
    lex
}

F lexer_get_source(lex: i64) -> i64 = load_i64(lex + 0)
F lexer_get_len(lex: i64) -> i64 = load_i64(lex + 8)
F lexer_get_pos(lex: i64) -> i64 = load_i64(lex + 16)
F lexer_set_pos(lex: i64, pos: i64) -> i64 {
    store_i64(lex + 16, pos)
    0
}

F lexer_is_eof(lex: i64) -> i64 {
    pos := lexer_get_pos(lex)
    len := lexer_get_len(lex)
    I pos >= len { 1 } E { 0 }
}

F lexer_peek(lex: i64) -> i64 {
    I lexer_is_eof(lex) == 1 { 0 }
    E {
        src := lexer_get_source(lex)
        pos := lexer_get_pos(lex)
        load_byte(src + pos)
    }
}

F lexer_advance(lex: i64) -> i64 {
    I lexer_is_eof(lex) == 1 { 0 }
    E {
        c := lexer_peek(lex)
        pos := lexer_get_pos(lex)
        lexer_set_pos(lex, pos + 1)
        c
    }
}

F is_digit(c: i64) -> i64 {
    I c >= 48 && c <= 57 { 1 } E { 0 }
}

F is_ident_start(c: i64) -> i64 {
    I (c >= 65 && c <= 90) || (c >= 97 && c <= 122) || c == 95 { 1 } E { 0 }
}

F is_ident_char(c: i64) -> i64 {
    I is_ident_start(c) == 1 || is_digit(c) == 1 { 1 } E { 0 }
}

F is_whitespace(c: i64) -> i64 {
    I c == 32 || c == 9 || c == 10 || c == 13 { 1 } E { 0 }
}

F lexer_skip_whitespace(lex: i64) -> i64 {
    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        c := lexer_peek(lex)
        I is_whitespace(c) == 0 { B } E { 0 }
        lexer_advance(lex)
    }
    1
}

F lexer_skip_comment(lex: i64) -> i64 {
    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        I lexer_peek(lex) == 10 { B } E { 0 }
        lexer_advance(lex)
    }
    1
}

F lexer_skip_whitespace_and_comments(lex: i64) -> i64 {
    L {
        lexer_skip_whitespace(lex)
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        I lexer_peek(lex) == 35 {
            lexer_skip_comment(lex)
            0
        } E {
            B
        }
    }
    1
}

# Token storage: kind(8) + value(8) + str_ptr(8) + str_len(8) + span_start(8) + span_end(8) = 48 bytes
F token_store(tokens: i64, idx: i64, kind: i64, value: i64, str_ptr: i64, str_len: i64, start: i64, end: i64) -> i64 {
    ptr := tokens + idx * 48
    store_i64(ptr + 0, kind)
    store_i64(ptr + 8, value)
    store_i64(ptr + 16, str_ptr)
    store_i64(ptr + 24, str_len)
    store_i64(ptr + 32, start)
    store_i64(ptr + 40, end)
    1
}

F token_get_kind(tokens: i64, idx: i64) -> i64 = load_i64(tokens + idx * 48 + 0)
F token_get_value(tokens: i64, idx: i64) -> i64 = load_i64(tokens + idx * 48 + 8)
F token_get_str_ptr(tokens: i64, idx: i64) -> i64 = load_i64(tokens + idx * 48 + 16)
F token_get_str_len(tokens: i64, idx: i64) -> i64 = load_i64(tokens + idx * 48 + 24)

F lexer_scan_number(lex: i64, tokens: i64, count: i64) -> i64 {
    start := lexer_get_pos(lex)
    value: mut i64 = 0
    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        c := lexer_peek(lex)
        I is_digit(c) == 0 { B } E { 0 }
        value = value * 10 + (c - 48)
        lexer_advance(lex)
    }
    end := lexer_get_pos(lex)
    token_store(tokens, count, TOK_INT(), value, 0, 0, start, end)
}

F lexer_scan_ident(lex: i64, tokens: i64, count: i64) -> i64 {
    start := lexer_get_pos(lex)
    src := lexer_get_source(lex)
    str_start := src + start

    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        I is_ident_char(lexer_peek(lex)) == 0 { B } E { 0 }
        lexer_advance(lex)
    }

    end := lexer_get_pos(lex)
    len := end - start

    # Check for keywords
    kind: mut i64 = TOK_IDENT()

    I len == 1 {
        c := load_byte(str_start)
        # Check M first to avoid adding to E I chain
        I c == 77 { kind = TOK_KW_M(); 0 } E { 0 }
        I c == 70 { kind = TOK_KW_F(); 0 }       # F
        E I c == 83 { kind = TOK_KW_S(); 0 }     # S
        E I c == 88 { kind = TOK_KW_X(); 0 }     # X
        E I c == 73 { kind = TOK_KW_I(); 0 }     # I
        E I c == 76 { kind = TOK_KW_L(); 0 }     # L
        E I c == 82 { kind = TOK_KW_R(); 0 }     # R
        E I c == 66 { kind = TOK_KW_B(); 0 }     # B
        E I c == 69 { kind = TOK_KW_E(); 0 }     # E
        E I c == 85 { kind = TOK_KW_U(); 0 }     # U (import)
        E { 0 }
    } E I len == 3 {
        c0 := load_byte(str_start)
        c1 := load_byte(str_start + 1)
        c2 := load_byte(str_start + 2)
        # Check for i64
        I c0 == 105 && c1 == 54 && c2 == 52 {
            kind = TOK_TY_I64()
            0
        # Check for str
        } E I c0 == 115 && c1 == 116 && c2 == 114 {
            kind = TOK_TY_STR()
            0
        # Check for mut
        } E I c0 == 109 && c1 == 117 && c2 == 116 {
            kind = TOK_KW_MUT()
            0
        } E { 0 }
    } E I len == 4 {
        c0 := load_byte(str_start)
        c1 := load_byte(str_start + 1)
        c2 := load_byte(str_start + 2)
        c3 := load_byte(str_start + 3)
        # Check for bool
        I c0 == 98 && c1 == 111 && c2 == 111 && c3 == 108 {
            kind = TOK_TY_BOOL()
            0
        } E { 0 }
    } E { 0 }

    token_store(tokens, count, kind, 0, str_start, len, start, end)
}

F lexer_scan_operator(lex: i64, tokens: i64, count: i64) -> i64 {
    start := lexer_get_pos(lex)
    c := lexer_advance(lex)
    kind: mut i64 = 0

    # Special handling for => at start to avoid adding nesting
    I c == 61 {
        I lexer_peek(lex) == 62 {
            lexer_advance(lex)
            fat_end := lexer_get_pos(lex)
            token_store(tokens, count, TOK_FAT_ARROW(), 0, 0, 0, start, fat_end)
            R 0
        } E { 0 }
    } E { 0 }

    I c == 40 { kind = TOK_LPAREN(); 0 }       # (
    E I c == 41 { kind = TOK_RPAREN(); 0 }     # )
    E I c == 123 { kind = TOK_LBRACE(); 0 }    # {
    E I c == 125 { kind = TOK_RBRACE(); 0 }    # }
    E I c == 91 { kind = TOK_LBRACKET(); 0 }   # [
    E I c == 93 { kind = TOK_RBRACKET(); 0 }   # ]
    E I c == 44 { kind = TOK_COMMA(); 0 }      # ,
    E I c == 59 { kind = TOK_SEMI(); 0 }       # ;
    E I c == 64 { kind = TOK_AT(); 0 }         # @
    E I c == 58 {
        # Check for :=
        I lexer_peek(lex) == 61 {
            lexer_advance(lex)
            kind = TOK_COLON_EQ()
            0
        } E {
            kind = TOK_COLON()
            0
        }
    }
    E I c == 46 { kind = TOK_DOT(); 0 }        # .
    E I c == 43 { kind = TOK_PLUS(); 0 }       # +
    E I c == 45 {
        I lexer_peek(lex) == 62 {
            lexer_advance(lex)
            kind = TOK_ARROW()
            0
        } E {
            kind = TOK_MINUS()
            0
        }
    }
    E I c == 42 { kind = TOK_STAR(); 0 }       # *
    E I c == 47 { kind = TOK_SLASH(); 0 }      # /
    E I c == 37 { kind = TOK_PERCENT(); 0 }    # %
    E I c == 60 {
        # < or <= or <<
        I lexer_peek(lex) == 61 {
            lexer_advance(lex)
            kind = TOK_LT_EQ()
            0
        } E {
            kind = TOK_LT()
            0
        }
    }
    E I c == 62 {
        # > or >= or >>
        I lexer_peek(lex) == 61 {
            lexer_advance(lex)
            kind = TOK_GT_EQ()
            0
        } E {
            kind = TOK_GT()
            0
        }
    }
    E I c == 61 {
        # = or ==
        I lexer_peek(lex) == 61 {
            lexer_advance(lex)
            kind = TOK_EQ_EQ()
            0
        } E {
            kind = TOK_EQ()
            0
        }
    }
    E I c == 33 {
        # ! or !=
        I lexer_peek(lex) == 61 {
            lexer_advance(lex)
            kind = TOK_NOT_EQ()
            0
        } E {
            kind = TOK_NOT()
            0
        }
    }
    E I c == 38 {
        # & or &&
        I lexer_peek(lex) == 38 {
            lexer_advance(lex)
            kind = TOK_AND()
            0
        } E {
            kind = TOK_AMP()
            0
        }
    }
    E I c == 124 {
        # | or ||
        I lexer_peek(lex) == 124 {
            lexer_advance(lex)
            kind = TOK_OR()
            0
        } E {
            kind = TOK_PIPE()
            0
        }
    }
    E { 0 }

    end := lexer_get_pos(lex)
    token_store(tokens, count, kind, 0, 0, 0, start, end)
}

# Scan a string literal (double-quoted) with escape sequence processing
F lexer_scan_string(lex: i64, tokens: i64, count: i64) -> i64 {
    lexer_advance(lex)  # consume opening quote
    start := lexer_get_pos(lex)

    # Allocate buffer for processed string (max size = original size)
    # We'll copy characters with escape processing
    buf := malloc(4096)
    buf_len: mut i64 = 0

    L {
        I lexer_is_eof(lex) == 1 { B } E { 0 }
        c := lexer_peek(lex)
        I c == 34 { B } E { 0 }  # closing quote
        I c == 92 {
            # escape sequence
            lexer_advance(lex)
            I lexer_is_eof(lex) == 0 {
                ec := lexer_peek(lex)
                lexer_advance(lex)
                # Process escape character
                I ec == 110 {
                    # \n -> newline (10)
                    store_byte(buf + buf_len, 10)
                    buf_len = buf_len + 1
                } E I ec == 116 {
                    # \t -> tab (9)
                    store_byte(buf + buf_len, 9)
                    buf_len = buf_len + 1
                } E I ec == 114 {
                    # \r -> carriage return (13)
                    store_byte(buf + buf_len, 13)
                    buf_len = buf_len + 1
                } E I ec == 92 {
                    # \\ -> backslash
                    store_byte(buf + buf_len, 92)
                    buf_len = buf_len + 1
                } E I ec == 34 {
                    # \" -> double quote
                    store_byte(buf + buf_len, 34)
                    buf_len = buf_len + 1
                } E I ec == 48 {
                    # \0 -> null
                    store_byte(buf + buf_len, 0)
                    buf_len = buf_len + 1
                } E {
                    # Unknown escape: keep both chars
                    store_byte(buf + buf_len, 92)
                    buf_len = buf_len + 1
                    store_byte(buf + buf_len, ec)
                    buf_len = buf_len + 1
                }
                0
            } E { 0 }
        } E {
            # Normal character
            store_byte(buf + buf_len, c)
            buf_len = buf_len + 1
            lexer_advance(lex)
            0
        }
    }

    end := lexer_get_pos(lex)
    lexer_advance(lex)  # consume closing quote

    token_store(tokens, count, TOK_STRING(), 0, buf, buf_len, start, end)
}

F lexer_tokenize(lex: i64, tokens: i64) -> i64 {
    count: mut i64 = 0
    c: mut i64 = 0
    L {
        lexer_skip_whitespace_and_comments(lex)
        I lexer_is_eof(lex) == 1 { B } E { 0 }

        c = lexer_peek(lex)

        I is_digit(c) == 1 {
            lexer_scan_number(lex, tokens, count)
            count = count + 1
            0
        } E I is_ident_start(c) == 1 {
            lexer_scan_ident(lex, tokens, count)
            count = count + 1
            0
        } E I c == 34 {
            # String literal (double quote)
            lexer_scan_string(lex, tokens, count)
            count = count + 1
            0
        } E {
            lexer_scan_operator(lex, tokens, count)
            count = count + 1
            0
        }
    }

    # Add EOF
    pos := lexer_get_pos(lex)
    token_store(tokens, count, TOK_EOF(), 0, 0, 0, pos, pos)
    count + 1
}

F lexer_free(lex: i64) -> i64 {
    free(lex)
    1
}

# ============================================================================
# Parser (procedural) - Extended for S/X support
# ============================================================================

# Item node layout (64 bytes):
#   kind(8) + name_ptr(8) + name_len(8) + data0(8) + data1(8) + data2(8) + data3(8) + data4(8)
F ITEM_SIZE() -> i64 = 64

F item_new(kind: i64, name_ptr: i64, name_len: i64) -> i64 {
    item := malloc(ITEM_SIZE())
    store_i64(item + 0, kind)
    store_i64(item + 8, name_ptr)
    store_i64(item + 16, name_len)
    store_i64(item + 24, 0)  # data0
    store_i64(item + 32, 0)  # data1
    store_i64(item + 40, 0)  # data2
    store_i64(item + 48, 0)  # data3
    store_i64(item + 56, 0)  # data4
    item
}

F item_get_kind(item: i64) -> i64 = load_i64(item + 0)
F item_get_name_ptr(item: i64) -> i64 = load_i64(item + 8)
F item_get_name_len(item: i64) -> i64 = load_i64(item + 16)
F item_set_data0(item: i64, v: i64) -> i64 { store_i64(item + 24, v); 0 }
F item_set_data1(item: i64, v: i64) -> i64 { store_i64(item + 32, v); 0 }
F item_set_data2(item: i64, v: i64) -> i64 { store_i64(item + 40, v); 0 }
F item_set_data3(item: i64, v: i64) -> i64 { store_i64(item + 48, v); 0 }
F item_set_data4(item: i64, v: i64) -> i64 { store_i64(item + 56, v); 0 }
F item_get_data0(item: i64) -> i64 = load_i64(item + 24)
F item_get_data1(item: i64) -> i64 = load_i64(item + 32)
F item_get_data2(item: i64) -> i64 = load_i64(item + 40)
F item_get_data3(item: i64) -> i64 = load_i64(item + 48)
F item_get_data4(item: i64) -> i64 = load_i64(item + 56)

# Field node layout (32 bytes): name_ptr(8) + name_len(8) + type_ptr(8) + type_len(8)
F FIELD_SIZE() -> i64 = 32

F field_new(name_ptr: i64, name_len: i64, type_ptr: i64, type_len: i64) -> i64 {
    f := malloc(FIELD_SIZE())
    store_i64(f + 0, name_ptr)
    store_i64(f + 8, name_len)
    store_i64(f + 16, type_ptr)
    store_i64(f + 24, type_len)
    f
}

F field_get_name_ptr(f: i64) -> i64 = load_i64(f + 0)
F field_get_name_len(f: i64) -> i64 = load_i64(f + 8)
F field_get_type_ptr(f: i64) -> i64 = load_i64(f + 16)
F field_get_type_len(f: i64) -> i64 = load_i64(f + 24)

# Param node layout (32 bytes): name_ptr(8) + name_len(8) + type_ptr(8) + type_len(8)
F PARAM_SIZE() -> i64 = 32

F param_new(name_ptr: i64, name_len: i64, type_ptr: i64, type_len: i64) -> i64 {
    p := malloc(PARAM_SIZE())
    store_i64(p + 0, name_ptr)
    store_i64(p + 8, name_len)
    store_i64(p + 16, type_ptr)
    store_i64(p + 24, type_len)
    p
}

F param_get_name_ptr(p: i64) -> i64 = load_i64(p + 0)
F param_get_name_len(p: i64) -> i64 = load_i64(p + 8)
F param_get_type_ptr(p: i64) -> i64 = load_i64(p + 16)
F param_get_type_len(p: i64) -> i64 = load_i64(p + 24)

# Parser struct (128 bytes):
#   tokens(8) + token_count(8) + pos(8) +
#   items(8) + item_count(8) + item_cap(8) +
#   structs(8) + struct_count(8) +
#   impls(8) + impl_count(8) +
#   functions(8) + function_count(8) +
#   (legacy fields for compatibility)
#   func_name_ptr(8) + func_name_len(8) + param_name_ptr(8) + param_name_len(8) + body_expr(8)
F parser_new(tokens: i64, count: i64) -> i64 {
    p := malloc(128)
    store_i64(p + 0, tokens)
    store_i64(p + 8, count)
    store_i64(p + 16, 0)   # pos
    # Item storage
    items := malloc(512 * 8)  # array of 512 item pointers
    store_i64(p + 24, items)
    store_i64(p + 32, 0)   # item_count
    store_i64(p + 40, 512)  # item_cap
    # Categorized storage
    store_i64(p + 48, 0)   # structs ptr (will be set during parsing)
    store_i64(p + 56, 0)   # struct_count
    store_i64(p + 64, 0)   # impls ptr
    store_i64(p + 72, 0)   # impl_count
    store_i64(p + 80, 0)   # functions ptr
    store_i64(p + 88, 0)   # function_count
    # Legacy fields (for backward compatibility)
    store_i64(p + 96, 0)   # func_name_ptr
    store_i64(p + 104, 0)  # func_name_len
    store_i64(p + 112, 0)  # param_name_ptr (unused now)
    store_i64(p + 120, 0)  # param_name_len (unused now)
    p
}

F parser_get_tokens(p: i64) -> i64 = load_i64(p + 0)
F parser_get_count(p: i64) -> i64 = load_i64(p + 8)
F parser_get_pos(p: i64) -> i64 = load_i64(p + 16)
F parser_set_pos(p: i64, pos: i64) -> i64 {
    store_i64(p + 16, pos)
    0
}

F parser_current_kind(p: i64) -> i64 {
    tokens := parser_get_tokens(p)
    pos := parser_get_pos(p)
    token_get_kind(tokens, pos)
}

F parser_advance(p: i64) -> i64 {
    pos := parser_get_pos(p)
    parser_set_pos(p, pos + 1)
    pos
}

F parser_expect(p: i64, kind: i64) -> i64 {
    I parser_current_kind(p) == kind {
        parser_advance(p)
        1
    } E { 0 }
}

# Item management
F parser_get_items(p: i64) -> i64 = load_i64(p + 24)
F parser_get_item_count(p: i64) -> i64 = load_i64(p + 32)
F parser_set_item_count(p: i64, c: i64) -> i64 { store_i64(p + 32, c); 0 }

F parser_add_item(p: i64, item: i64) -> i64 {
    items := parser_get_items(p)
    count := parser_get_item_count(p)
    store_i64(items + count * 8, item)
    parser_set_item_count(p, count + 1)
    1
}

# Get current token's string pointer/length
F parser_current_str_ptr(p: i64) -> i64 {
    tokens := parser_get_tokens(p)
    pos := parser_get_pos(p)
    token_get_str_ptr(tokens, pos)
}

F parser_current_str_len(p: i64) -> i64 {
    tokens := parser_get_tokens(p)
    pos := parser_get_pos(p)
    token_get_str_len(tokens, pos)
}

F parser_current_value(p: i64) -> i64 {
    tokens := parser_get_tokens(p)
    pos := parser_get_pos(p)
    token_get_value(tokens, pos)
}

# ============================================================================
# Expression Parsing (extended)
# ============================================================================

# Expr node: kind(8) + field0(8) + field1(8) + field2(8) + field3(8) + field4(8) = 48 bytes
F EXPR_SIZE() -> i64 = 48

F expr_new(kind: i64) -> i64 {
    e := malloc(EXPR_SIZE())
    store_i64(e + 0, kind)
    store_i64(e + 8, 0)
    store_i64(e + 16, 0)
    store_i64(e + 24, 0)
    store_i64(e + 32, 0)
    store_i64(e + 40, 0)
    e
}

F expr_get_kind(e: i64) -> i64 = load_i64(e + 0)
F expr_set_field0(e: i64, v: i64) -> i64 { store_i64(e + 8, v); 0 }
F expr_set_field1(e: i64, v: i64) -> i64 { store_i64(e + 16, v); 0 }
F expr_set_field2(e: i64, v: i64) -> i64 { store_i64(e + 24, v); 0 }
F expr_set_field3(e: i64, v: i64) -> i64 { store_i64(e + 32, v); 0 }
F expr_set_field4(e: i64, v: i64) -> i64 { store_i64(e + 40, v); 0 }
F expr_get_field0(e: i64) -> i64 = load_i64(e + 8)
F expr_get_field1(e: i64) -> i64 = load_i64(e + 16)
F expr_get_field2(e: i64) -> i64 = load_i64(e + 24)
F expr_get_field3(e: i64) -> i64 = load_i64(e + 32)
F expr_get_field4(e: i64) -> i64 = load_i64(e + 40)

# Forward declarations for recursive parsing
# parser_parse_expr is the main entry point

# Parse function call expression
F parser_parse_call_expr(p: i64, str_ptr: i64, str_len: i64) -> i64 {
    parser_advance(p)  # consume (

    args := malloc(16 * 8)
    arg_count: mut i64 = 0

    L {
        I parser_current_kind(p) == TOK_RPAREN() { B } E { 0 }
        I parser_current_kind(p) == TOK_EOF() { B } E { 0 }

        arg := parser_parse_expr(p)
        I arg != 0 {
            store_i64(args + arg_count * 8, arg)
            arg_count = arg_count + 1
            0
        } E { B }

        I parser_current_kind(p) == TOK_COMMA() {
            parser_advance(p)
            0
        } E { 0 }
    }

    parser_expect(p, TOK_RPAREN())

    e := expr_new(EXPR_CALL())
    expr_set_field0(e, str_ptr)
    expr_set_field1(e, str_len)
    expr_set_field2(e, args)
    expr_set_field3(e, arg_count)
    e
}

# Parse struct literal expression
F parser_parse_struct_lit_expr(p: i64, str_ptr: i64, str_len: i64) -> i64 {
    parser_advance(p)  # consume {

    fields := malloc(32 * 8)
    field_count: mut i64 = 0

    L {
        I parser_current_kind(p) == TOK_RBRACE() { B } E { 0 }
        I parser_current_kind(p) == TOK_EOF() { B } E { 0 }

        I parser_current_kind(p) != TOK_IDENT() { B } E { 0 }
        fname_ptr := parser_current_str_ptr(p)
        fname_len := parser_current_str_len(p)
        parser_advance(p)

        I parser_expect(p, TOK_COLON()) == 0 { B } E { 0 }

        fvalue := parser_parse_expr(p)

        store_i64(fields + field_count * 24 + 0, fname_ptr)
        store_i64(fields + field_count * 24 + 8, fname_len)
        store_i64(fields + field_count * 24 + 16, fvalue)
        field_count = field_count + 1

        I parser_current_kind(p) == TOK_COMMA() {
            parser_advance(p)
            0
        } E { 0 }
    }

    parser_expect(p, TOK_RBRACE())

    e := expr_new(EXPR_STRUCT_LIT())
    expr_set_field0(e, str_ptr)
    expr_set_field1(e, str_len)
    expr_set_field2(e, fields)
    expr_set_field3(e, field_count)
    e
}

# Parse identifier-based expression: call, struct literal, or plain ident
F parser_parse_ident_expr(p: i64, str_ptr: i64, str_len: i64) -> i64 {
    next_kind := parser_current_kind(p)

    result: mut i64 = 0

    I next_kind == TOK_LBRACE() {
        # Check if this is a struct literal: { ident : ... } pattern
        # We need lookahead to distinguish "b { a }" (not struct) from "Point { x: 1 }" (struct)
        saved_pos := parser_get_pos(p)
        parser_advance(p)  # consume {

        is_struct_lit: mut i64 = 0
        I parser_current_kind(p) == TOK_IDENT() {
            parser_advance(p)  # consume ident
            I parser_current_kind(p) == TOK_COLON() {
                is_struct_lit = 1
                0
            } E { 0 }
        } E { 0 }

        parser_set_pos(p, saved_pos)  # restore position

        I is_struct_lit == 1 {
            result = parser_parse_struct_lit_expr(p, str_ptr, str_len)
            0
        } E {
            # Not a struct literal, just return the identifier
            e := expr_new(EXPR_IDENT())
            expr_set_field0(e, str_ptr)
            expr_set_field1(e, str_len)
            result = e
            0
        }
    } E I next_kind == TOK_LPAREN() {
        result = parser_parse_call_expr(p, str_ptr, str_len)
        0
    } E {
        # Simple identifier
        e := expr_new(EXPR_IDENT())
        expr_set_field0(e, str_ptr)
        expr_set_field1(e, str_len)
        result = e
        0
    }

    result
}

# Parse single match arm: pattern => body
# Returns 1 if arm parsed, 0 if not
F parser_parse_match_arm(p: i64, arms: i64, arm_count_ptr: i64) -> i64 {
    arm_count := load_i64(arm_count_ptr)

    # Check if we can parse a pattern (integer literal for now)
    I parser_current_kind(p) != TOK_INT() { R 0 } E { 0 }

    pattern_val := parser_current_value(p)
    parser_advance(p)

    I parser_expect(p, TOK_FAT_ARROW()) == 0 { R 0 } E { 0 }

    body := parser_parse_expr(p)
    I body == 0 { R 0 } E { 0 }

    store_i64(arms + arm_count * 16, pattern_val)
    store_i64(arms + arm_count * 16 + 8, body)
    store_i64(arm_count_ptr, arm_count + 1)
    1
}

# Parse match expression: M expr { pattern => body, ... }
# Note: scrutinee must be a simple identifier (not followed by { which would be struct lit)
F parser_parse_match(p: i64) -> i64 {
    parser_advance(p)  # consume M

    # Parse scrutinee - only identifier for now to avoid { ambiguity
    I parser_current_kind(p) != TOK_IDENT() { R 0 } E { 0 }
    str_ptr := parser_current_str_ptr(p)
    str_len := parser_current_str_len(p)
    parser_advance(p)

    scrutinee := expr_new(EXPR_IDENT())
    expr_set_field0(scrutinee, str_ptr)
    expr_set_field1(scrutinee, str_len)

    I parser_expect(p, TOK_LBRACE()) == 0 { R 0 } E { 0 }

    arms := malloc(64 * 16)
    arm_count := malloc(8)
    store_i64(arm_count, 0)

    L {
        I parser_current_kind(p) == TOK_RBRACE() { B } E { 0 }
        I parser_parse_match_arm(p, arms, arm_count) == 0 { B } E { 0 }
        I parser_current_kind(p) == TOK_COMMA() { parser_advance(p); 0 } E { 0 }
    }

    I parser_expect(p, TOK_RBRACE()) == 0 { R 0 } E { 0 }

    e := expr_new(EXPR_MATCH())
    expr_set_field0(e, scrutinee)
    expr_set_field1(e, arms)
    expr_set_field2(e, load_i64(arm_count))
    free(arm_count)
    e
}

# Parse primary expression: int, bool, ident, ( expr ), block, struct literal
# Forward declaration marker for block parsing
# parser_parse_block_expr is defined after parser_parse_expr

F parser_parse_primary(p: i64) -> i64 {
    kind := parser_current_kind(p)

    I kind == TOK_INT() {
        value := parser_current_value(p)
        parser_advance(p)
        e := expr_new(EXPR_INT())
        expr_set_field0(e, value)
        e
    } E I kind == TOK_IDENT() {
        str_ptr := parser_current_str_ptr(p)
        str_len := parser_current_str_len(p)
        parser_advance(p)

        # Use helper function to handle ident-based expressions
        parser_parse_ident_expr(p, str_ptr, str_len)
    } E I kind == TOK_STRING() {
        # String literal
        str_ptr := parser_current_str_ptr(p)
        str_len := parser_current_str_len(p)
        parser_advance(p)
        e := expr_new(EXPR_STRING())
        expr_set_field0(e, str_ptr)
        expr_set_field1(e, str_len)
        e
    } E I kind == TOK_LBRACE() {
        # Block expression: { stmts... expr }
        parser_parse_block_expr(p)
    } E I kind == TOK_LPAREN() {
        # Parenthesized expression
        parser_advance(p)
        inner := parser_parse_expr(p)
        parser_expect(p, TOK_RPAREN())
        inner
    } E I kind == TOK_AT() {
        # Self-call: @(args...) or @.method(args...)
        parser_advance(p)  # consume @

        I parser_current_kind(p) == TOK_DOT() {
            # @.method(...)
            parser_advance(p)  # consume .
            I parser_current_kind(p) != TOK_IDENT() { R 0 }
            method_ptr := parser_current_str_ptr(p)
            method_len := parser_current_str_len(p)
            parser_advance(p)

            I parser_expect(p, TOK_LPAREN()) == 0 { R 0 }

            args := malloc(16 * 8)
            arg_count: mut i64 = 0

            L {
                I parser_current_kind(p) == TOK_RPAREN() { B } E { 0 }
                arg := parser_parse_expr(p)
                I arg != 0 {
                    store_i64(args + arg_count * 8, arg)
                    arg_count = arg_count + 1
                    0
                } E { B }
                I parser_current_kind(p) == TOK_COMMA() {
                    parser_advance(p)
                    0
                } E { 0 }
            }

            parser_expect(p, TOK_RPAREN())

            e := expr_new(EXPR_SELF_CALL())
            expr_set_field0(e, method_ptr)
            expr_set_field1(e, method_len)
            expr_set_field2(e, args)
            expr_set_field3(e, arg_count)
            e
        } E I parser_current_kind(p) == TOK_LPAREN() {
            # @(args...) - recursive self call
            parser_advance(p)

            args := malloc(16 * 8)
            arg_count: mut i64 = 0

            L {
                I parser_current_kind(p) == TOK_RPAREN() { B } E { 0 }
                arg := parser_parse_expr(p)
                I arg != 0 {
                    store_i64(args + arg_count * 8, arg)
                    arg_count = arg_count + 1
                    0
                } E { B }
                I parser_current_kind(p) == TOK_COMMA() {
                    parser_advance(p)
                    0
                } E { 0 }
            }

            parser_expect(p, TOK_RPAREN())

            e := expr_new(EXPR_SELF_CALL())
            expr_set_field0(e, 0)  # no method name = recursive call
            expr_set_field1(e, 0)
            expr_set_field2(e, args)
            expr_set_field3(e, arg_count)
            e
        } E { 0 }
    } E I kind == TOK_KW_I() {
        # If expression: I cond { then } E { else }
        parser_advance(p)  # consume I

        cond := parser_parse_expr(p)
        I cond == 0 { R 0 }

        I parser_expect(p, TOK_LBRACE()) == 0 { R 0 }
        then_expr := parser_parse_block_contents(p)
        I parser_expect(p, TOK_RBRACE()) == 0 { R 0 }

        else_expr: mut i64 = 0
        I parser_current_kind(p) == TOK_KW_E() {
            parser_advance(p)
            I parser_current_kind(p) == TOK_KW_I() {
                # else if chain
                else_expr = parser_parse_primary(p)
                0
            } E {
                I parser_expect(p, TOK_LBRACE()) == 0 { R 0 }
                else_expr = parser_parse_block_contents(p)
                I parser_expect(p, TOK_RBRACE()) == 0 { R 0 }
                0
            }
        } E { 0 }

        e := expr_new(EXPR_IF())
        expr_set_field0(e, cond)
        expr_set_field1(e, then_expr)
        expr_set_field2(e, else_expr)
        e
    } E I kind == TOK_KW_L() {
        # Loop: L { body }
        parser_advance(p)  # consume L

        I parser_expect(p, TOK_LBRACE()) == 0 { R 0 }
        body := parser_parse_block_contents(p)
        I parser_expect(p, TOK_RBRACE()) == 0 { R 0 }

        e := expr_new(EXPR_LOOP())
        expr_set_field0(e, body)
        e
    } E { 0 }
}

# Parse postfix operators: .field, .method(), [index]
F parser_parse_postfix(p: i64) -> i64 {
    left: mut i64 = parser_parse_primary(p)
    I left == 0 { R 0 }

    L {
        kind := parser_current_kind(p)

        I kind == TOK_DOT() {
            parser_advance(p)
            I parser_current_kind(p) != TOK_IDENT() { B } E { 0 }

            member_ptr := parser_current_str_ptr(p)
            member_len := parser_current_str_len(p)
            parser_advance(p)

            I parser_current_kind(p) == TOK_LPAREN() {
                # Method call: expr.method(args...)
                parser_advance(p)

                args := malloc(16 * 8)
                arg_count: mut i64 = 0

                L {
                    I parser_current_kind(p) == TOK_RPAREN() { B } E { 0 }
                    arg := parser_parse_expr(p)
                    I arg != 0 {
                        store_i64(args + arg_count * 8, arg)
                        arg_count = arg_count + 1
                        0
                    } E { B }
                    I parser_current_kind(p) == TOK_COMMA() {
                        parser_advance(p)
                        0
                    } E { 0 }
                }

                parser_expect(p, TOK_RPAREN())

                e := expr_new(EXPR_METHOD_CALL())
                expr_set_field0(e, left)        # receiver
                expr_set_field1(e, member_ptr)  # method name
                expr_set_field2(e, member_len)
                expr_set_field3(e, args)
                expr_set_field4(e, arg_count)
                left = e
                0
            } E {
                # Field access: expr.field
                e := expr_new(EXPR_FIELD())
                expr_set_field0(e, left)
                expr_set_field1(e, member_ptr)
                expr_set_field2(e, member_len)
                left = e
                0
            }
        } E I kind == TOK_LBRACKET() {
            # Index: expr[index]
            parser_advance(p)
            index := parser_parse_expr(p)
            parser_expect(p, TOK_RBRACKET())

            e := expr_new(EXPR_INDEX())
            expr_set_field0(e, left)
            expr_set_field1(e, index)
            left = e
            0
        } E { B }
    }

    left
}

# Parse unary: - ! expressions
F parser_parse_unary(p: i64) -> i64 {
    kind := parser_current_kind(p)

    I kind == TOK_MINUS() {
        parser_advance(p)
        operand := parser_parse_unary(p)
        e := expr_new(EXPR_UNARY())
        expr_set_field0(e, UNOP_NEG())
        expr_set_field1(e, operand)
        e
    } E I kind == TOK_NOT() {
        parser_advance(p)
        operand := parser_parse_unary(p)
        e := expr_new(EXPR_UNARY())
        expr_set_field0(e, UNOP_NOT())
        expr_set_field1(e, operand)
        e
    } E {
        parser_parse_postfix(p)
    }
}

# Get binary operator precedence
F get_binop_precedence(kind: i64) -> i64 {
    I kind == TOK_OR() { 1 }
    E I kind == TOK_AND() { 2 }
    E I kind == TOK_EQ_EQ() || kind == TOK_NOT_EQ() { 3 }
    E I kind == TOK_LT() || kind == TOK_GT() || kind == TOK_LT_EQ() || kind == TOK_GT_EQ() { 4 }
    E I kind == TOK_PLUS() || kind == TOK_MINUS() { 5 }
    E I kind == TOK_STAR() || kind == TOK_SLASH() || kind == TOK_PERCENT() { 6 }
    E { 0 }
}

# Convert token to binary operator
F token_to_binop(kind: i64) -> i64 {
    I kind == TOK_PLUS() { BINOP_ADD() }
    E I kind == TOK_MINUS() { BINOP_SUB() }
    E I kind == TOK_STAR() { BINOP_MUL() }
    E I kind == TOK_SLASH() { BINOP_DIV() }
    E I kind == TOK_PERCENT() { BINOP_MOD() }
    E I kind == TOK_LT() { BINOP_LT() }
    E I kind == TOK_LT_EQ() { BINOP_LTE() }
    E I kind == TOK_GT() { BINOP_GT() }
    E I kind == TOK_GT_EQ() { BINOP_GTE() }
    E I kind == TOK_EQ_EQ() { BINOP_EQ() }
    E I kind == TOK_NOT_EQ() { BINOP_NEQ() }
    E I kind == TOK_AND() { BINOP_AND() }
    E I kind == TOK_OR() { BINOP_OR() }
    E { 0 }
}

# Parse binary expression with precedence climbing
F parser_parse_binary(p: i64, min_prec: i64) -> i64 {
    left: mut i64 = parser_parse_unary(p)
    I left == 0 { R 0 }

    L {
        kind := parser_current_kind(p)
        prec := get_binop_precedence(kind)
        I prec < min_prec || prec == 0 { B } E { 0 }

        op := token_to_binop(kind)
        parser_advance(p)

        right := parser_parse_binary(p, prec + 1)
        I right == 0 { B } E { 0 }

        e := expr_new(EXPR_BINARY())
        expr_set_field0(e, op)
        expr_set_field1(e, left)
        expr_set_field2(e, right)
        left = e
    }

    left
}

# Parse assignment or expression
F parser_parse_expr(p: i64) -> i64 {
    left := parser_parse_binary(p, 1)
    I left == 0 { R 0 }

    # Check for assignment: expr = value
    I parser_current_kind(p) == TOK_EQ() {
        parser_advance(p)
        right := parser_parse_expr(p)

        e := expr_new(EXPR_ASSIGN())
        expr_set_field0(e, left)
        expr_set_field1(e, right)
        e
    } E { left }
}

# Parse block contents: stmts... [final_expr]
# Returns a block expression
F parser_parse_block_contents(p: i64) -> i64 {
    stmts := malloc(256 * 8)  # up to 256 statements (for large blocks)
    stmts_len: mut i64 = 0
    final_expr: mut i64 = 0

    L {
        # Skip semicolons (statement separator)
        L {
            I parser_current_kind(p) == TOK_SEMI() {
                parser_advance(p)
            } E { B }
        }
        # Check for M (match) - parse as final expr and break
        I parser_current_kind(p) == TOK_KW_M() { final_expr = parser_parse_match(p); B } E { 0 }
        I parser_current_kind(p) == TOK_RBRACE() { B } E { 0 }
        I parser_current_kind(p) == TOK_EOF() { B } E { 0 }

        # Check for let statement: name := expr or mut name := expr
        I parser_current_kind(p) == TOK_IDENT() {
            # Lookahead for := or : mut
            saved_pos := parser_get_pos(p)
            name_ptr := parser_current_str_ptr(p)
            name_len := parser_current_str_len(p)
            parser_advance(p)

            I parser_current_kind(p) == TOK_COLON_EQ() {
                # Let binding: name := expr
                parser_advance(p)
                value := parser_parse_expr(p)

                stmt := malloc(32)
                store_i64(stmt + 0, STMT_LET())
                store_i64(stmt + 8, name_ptr)
                store_i64(stmt + 16, name_len)
                store_i64(stmt + 24, value)

                store_i64(stmts + stmts_len * 8, stmt)
                stmts_len = stmts_len + 1
                0
            } E I parser_current_kind(p) == TOK_COLON() {
                # Could be: name: mut Type = expr or name: Type = expr
                parser_advance(p)

                is_mut: mut i64 = 0
                I parser_current_kind(p) == TOK_KW_MUT() {
                    is_mut = 1
                    parser_advance(p)
                    0
                } E { 0 }

                # Skip type
                I parser_current_kind(p) == TOK_IDENT() || parser_current_kind(p) == TOK_TY_I64() {
                    parser_advance(p)
                    0
                } E { 0 }

                I parser_current_kind(p) == TOK_EQ() {
                    parser_advance(p)
                    value := parser_parse_expr(p)

                    stmt := malloc(40)
                    store_i64(stmt + 0, STMT_LET())
                    store_i64(stmt + 8, name_ptr)
                    store_i64(stmt + 16, name_len)
                    store_i64(stmt + 24, value)
                    store_i64(stmt + 32, is_mut)

                    store_i64(stmts + stmts_len * 8, stmt)
                    stmts_len = stmts_len + 1
                    0
                } E {
                    # Restore position, it's not a let
                    parser_set_pos(p, saved_pos)
                    e := parser_parse_expr(p)
                    I parser_current_kind(p) == TOK_RBRACE() {
                        final_expr = e
                        0
                    } E {
                        stmt := malloc(16)
                        store_i64(stmt + 0, STMT_EXPR())
                        store_i64(stmt + 8, e)
                        store_i64(stmts + stmts_len * 8, stmt)
                        stmts_len = stmts_len + 1
                        0
                    }
                }
            } E {
                # Not a let, restore and parse as expression
                parser_set_pos(p, saved_pos)
                e := parser_parse_expr(p)

                I parser_current_kind(p) == TOK_RBRACE() {
                    final_expr = e
                    0
                } E {
                    stmt := malloc(16)
                    store_i64(stmt + 0, STMT_EXPR())
                    store_i64(stmt + 8, e)
                    store_i64(stmts + stmts_len * 8, stmt)
                    stmts_len = stmts_len + 1
                    0
                }
            }
        } E I parser_current_kind(p) == TOK_KW_R() {
            # Return statement: R expr
            parser_advance(p)
            value := parser_parse_expr(p)

            stmt := malloc(16)
            store_i64(stmt + 0, STMT_RETURN())
            store_i64(stmt + 8, value)
            store_i64(stmts + stmts_len * 8, stmt)
            stmts_len = stmts_len + 1
            0
        } E I parser_current_kind(p) == TOK_KW_B() {
            # Break: B
            parser_advance(p)
            stmt := malloc(8)
            store_i64(stmt + 0, STMT_BREAK())
            store_i64(stmts + stmts_len * 8, stmt)
            stmts_len = stmts_len + 1
            0
        } E {
            # Expression statement or final expression
            e := parser_parse_expr(p)
            I parser_current_kind(p) == TOK_RBRACE() {
                final_expr = e
                0
            } E {
                stmt := malloc(16)
                store_i64(stmt + 0, STMT_EXPR())
                store_i64(stmt + 8, e)
                store_i64(stmts + stmts_len * 8, stmt)
                stmts_len = stmts_len + 1
                0
            }
        }
    }

    e := expr_new(EXPR_BLOCK())
    expr_set_field0(e, stmts)
    expr_set_field1(e, stmts_len)
    expr_set_field2(e, final_expr)
    e
}

# Parse block expression: { ... }
F parser_parse_block_expr(p: i64) -> i64 {
    I parser_expect(p, TOK_LBRACE()) == 0 { R 0 }
    block := parser_parse_block_contents(p)
    I parser_expect(p, TOK_RBRACE()) == 0 { R 0 }
    block
}

# ============================================================================
# Item Parsing: Functions, Structs, Impls
# ============================================================================

# Parse type: i64, str, bool, Name, Name<T>, *T, &T
F parser_parse_type(p: i64) -> i64 {
    kind := parser_current_kind(p)

    I kind == TOK_TY_I64() || kind == TOK_TY_STR() || kind == TOK_TY_BOOL() || kind == TOK_IDENT() {
        type_ptr := parser_current_str_ptr(p)
        type_len := parser_current_str_len(p)
        parser_advance(p)

        # Check for generic: Name<T>
        I parser_current_kind(p) == TOK_LT() {
            parser_advance(p)
            # Skip generic params for now
            L {
                I parser_current_kind(p) == TOK_GT() { B } E { 0 }
                I parser_current_kind(p) == TOK_EOF() { B } E { 0 }
                parser_advance(p)
            }
            parser_expect(p, TOK_GT())
            0
        } E { 0 }

        # Return type info as packed value: (ptr << 32) | len (simplified)
        # For now just return the ptr (can be used to lookup type name)
        type_ptr
    } E I kind == TOK_STAR() || kind == TOK_AMP() {
        # Pointer or reference type
        parser_advance(p)
        parser_parse_type(p)  # recursive
    } E { 0 }
}

# Parse parameter: name: Type or &self or &mut self
# Returns param struct pointer
F parser_parse_param(p: i64) -> i64 {
    # Check for &self
    I parser_current_kind(p) == TOK_AMP() {
        parser_advance(p)
        I parser_current_kind(p) == TOK_KW_MUT() {
            parser_advance(p)
            0
        } E { 0 }
        # Expect "self"
        I parser_current_kind(p) == TOK_IDENT() {
            name_ptr := parser_current_str_ptr(p)
            name_len := parser_current_str_len(p)
            parser_advance(p)
            # Create self param
            param_new(name_ptr, name_len, 0, 0)  # type = self
        } E { 0 }
    } E I parser_current_kind(p) == TOK_IDENT() {
        name_ptr := parser_current_str_ptr(p)
        name_len := parser_current_str_len(p)
        parser_advance(p)

        I parser_expect(p, TOK_COLON()) == 0 { R 0 }

        # Check for mut
        I parser_current_kind(p) == TOK_KW_MUT() {
            parser_advance(p)
            0
        } E { 0 }

        type_info := parser_parse_type(p)
        param_new(name_ptr, name_len, type_info, 0)
    } E { 0 }
}

# Parse function: F name(params...) -> Type = expr  OR  F name(params...) -> Type { block }
# Returns Item pointer
F parser_parse_function_item(p: i64) -> i64 {
    I parser_expect(p, TOK_KW_F()) == 0 { R 0 }

    I parser_current_kind(p) != TOK_IDENT() { R 0 }
    name_ptr := parser_current_str_ptr(p)
    name_len := parser_current_str_len(p)
    parser_advance(p)

    I parser_expect(p, TOK_LPAREN()) == 0 { R 0 }

    # Parse parameters
    params := malloc(16 * 8)  # up to 16 params
    param_count: mut i64 = 0

    L {
        I parser_current_kind(p) == TOK_RPAREN() { B } E { 0 }
        I parser_current_kind(p) == TOK_EOF() { B } E { 0 }

        param := parser_parse_param(p)
        I param != 0 {
            store_i64(params + param_count * 8, param)
            param_count = param_count + 1
            0
        } E { B }

        I parser_current_kind(p) == TOK_COMMA() {
            parser_advance(p)
            0
        } E { 0 }
    }

    I parser_expect(p, TOK_RPAREN()) == 0 { R 0 }

    # Parse return type (optional)
    ret_type: mut i64 = 0
    I parser_current_kind(p) == TOK_ARROW() {
        parser_advance(p)
        ret_type = parser_parse_type(p)
        0
    } E { 0 }

    # Parse body: = expr OR { block }
    body: mut i64 = 0
    I parser_current_kind(p) == TOK_EQ() {
        parser_advance(p)
        body = parser_parse_expr(p)
        0
    } E I parser_current_kind(p) == TOK_LBRACE() {
        body = parser_parse_block_expr(p)
        0
    } E { 0 }

    # Create function item
    item := item_new(ITEM_FUNCTION(), name_ptr, name_len)
    item_set_data0(item, params)
    item_set_data1(item, param_count)
    item_set_data2(item, ret_type)
    item_set_data3(item, body)
    item
}

# Parse struct field: name: Type
F parser_parse_struct_field(p: i64) -> i64 {
    I parser_current_kind(p) != TOK_IDENT() { R 0 }
    name_ptr := parser_current_str_ptr(p)
    name_len := parser_current_str_len(p)
    parser_advance(p)

    I parser_expect(p, TOK_COLON()) == 0 { R 0 }

    type_ptr := parser_current_str_ptr(p)
    type_len := parser_current_str_len(p)
    parser_parse_type(p)

    field_new(name_ptr, name_len, type_ptr, type_len)
}

# Parse struct: S Name { field: Type, ... }
F parser_parse_struct_item(p: i64) -> i64 {
    I parser_expect(p, TOK_KW_S()) == 0 { R 0 }

    I parser_current_kind(p) != TOK_IDENT() { R 0 }
    name_ptr := parser_current_str_ptr(p)
    name_len := parser_current_str_len(p)
    parser_advance(p)

    I parser_expect(p, TOK_LBRACE()) == 0 { R 0 }

    # Parse fields
    fields := malloc(32 * 8)  # up to 32 fields
    field_count: mut i64 = 0

    L {
        I parser_current_kind(p) == TOK_RBRACE() { B } E { 0 }
        I parser_current_kind(p) == TOK_EOF() { B } E { 0 }

        field := parser_parse_struct_field(p)
        I field != 0 {
            store_i64(fields + field_count * 8, field)
            field_count = field_count + 1
            0
        } E { B }

        I parser_current_kind(p) == TOK_COMMA() {
            parser_advance(p)
            0
        } E { 0 }
    }

    I parser_expect(p, TOK_RBRACE()) == 0 { R 0 }

    item := item_new(ITEM_STRUCT(), name_ptr, name_len)
    item_set_data0(item, fields)
    item_set_data1(item, field_count)
    item
}

# Parse impl block: X Name { methods... }
F parser_parse_impl_item(p: i64) -> i64 {
    I parser_expect(p, TOK_KW_X()) == 0 { R 0 }

    I parser_current_kind(p) != TOK_IDENT() { R 0 }
    name_ptr := parser_current_str_ptr(p)
    name_len := parser_current_str_len(p)
    parser_advance(p)

    I parser_expect(p, TOK_LBRACE()) == 0 { R 0 }

    # Parse methods
    methods := malloc(32 * 8)  # up to 32 methods
    method_count: mut i64 = 0

    L {
        I parser_current_kind(p) == TOK_RBRACE() { B } E { 0 }
        I parser_current_kind(p) == TOK_EOF() { B } E { 0 }

        I parser_current_kind(p) == TOK_KW_F() {
            method := parser_parse_function_item(p)
            I method != 0 {
                store_i64(methods + method_count * 8, method)
                method_count = method_count + 1
                0
            } E { B }
        } E {
            # Skip unknown tokens
            parser_advance(p)
            0
        }
    }

    I parser_expect(p, TOK_RBRACE()) == 0 { R 0 }

    item := item_new(ITEM_IMPL(), name_ptr, name_len)
    item_set_data0(item, methods)
    item_set_data1(item, method_count)
    item
}

# Parse a single top-level item: F, S, or X
# Parse use/import statement: U path/to/module
F parser_parse_use_item(p: i64) -> i64 {
    # Consume U keyword
    parser_advance(p)

    # Parse path (identifier with optional / separators)
    I parser_current_kind(p) != TOK_IDENT() {
        puts("[Parser] Expected module path after U\n")
        R 0
    }

    # Build path string by collecting identifiers and slashes
    path_sb := sb_new(256)

    # First identifier
    sb_append_bytes(path_sb, parser_current_str_ptr(p), parser_current_str_len(p))
    parser_advance(p)

    # Continue with /identifier pattern
    L {
        I parser_current_kind(p) != TOK_SLASH() { B } E { 0 }
        sb_append_byte(path_sb, 47)  # /
        parser_advance(p)

        I parser_current_kind(p) != TOK_IDENT() {
            puts("[Parser] Expected identifier after / in path\n")
            sb_free(path_sb)
            R 0
        }
        sb_append_bytes(path_sb, parser_current_str_ptr(p), parser_current_str_len(p))
        parser_advance(p)
    }

    # Create use item
    path_ptr := sb_get_data(path_sb)
    path_len := sb_get_len(path_sb)

    item := item_new(ITEM_USE(), path_ptr, path_len)
    # Note: path_sb data is now owned by item, don't free it
    free(path_sb)  # Free only the sb struct, not its data

    item
}

F parser_parse_item(p: i64) -> i64 {
    kind := parser_current_kind(p)

    I kind == TOK_KW_F() {
        parser_parse_function_item(p)
    } E I kind == TOK_KW_S() {
        parser_parse_struct_item(p)
    } E I kind == TOK_KW_X() {
        parser_parse_impl_item(p)
    } E I kind == TOK_KW_U() {
        parser_parse_use_item(p)
    } E { 0 }
}

# Parse entire module (multiple items)
F parser_parse_module(p: i64) -> i64 {
    item: mut i64 = 0
    L {
        I parser_current_kind(p) == TOK_EOF() { B } E { 0 }

        item = parser_parse_item(p)
        I item != 0 {
            parser_add_item(p, item)
            0
        } E {
            # Skip unknown token
            parser_advance(p)
            0
        }
    }
    1
}

# Legacy function for backward compatibility (single function parsing)
F parser_parse_function(p: i64) -> i64 {
    item := parser_parse_function_item(p)
    I item == 0 { R 0 }

    # Store in legacy fields for backward compatibility
    store_i64(p + 96, item_get_name_ptr(item))
    store_i64(p + 104, item_get_name_len(item))

    # Get first param
    params := item_get_data0(item)
    param_count := item_get_data1(item)
    I param_count > 0 {
        param := load_i64(params)
        store_i64(p + 112, param_get_name_ptr(param))
        store_i64(p + 120, param_get_name_len(param))
        0
    } E { 0 }

    # Store body
    body := item_get_data3(item)

    # Add item to list
    parser_add_item(p, item)

    1
}

# Legacy getters (for backward compatibility with existing code)
F parser_get_func_name_ptr(p: i64) -> i64 = load_i64(p + 96)
F parser_get_func_name_len(p: i64) -> i64 = load_i64(p + 104)
F parser_get_param_name_ptr(p: i64) -> i64 = load_i64(p + 112)
F parser_get_param_name_len(p: i64) -> i64 = load_i64(p + 120)

# Get body from first function item
F parser_get_body_expr(p: i64) -> i64 {
    items := parser_get_items(p)
    count := parser_get_item_count(p)
    I count > 0 {
        item := load_i64(items)
        item_get_data3(item)
    } E { 0 }
}

F parser_free(p: i64) -> i64 {
    free(parser_get_items(p))
    free(p)
    1
}

# ============================================================================
# Code Generator (procedural)
# ============================================================================

F cg_new() -> i64 {
    cg := malloc(120)
    sb := sb_new(1048576)  # Test 1MB buffer
    store_i64(cg + 0, sb)
    store_i64(cg + 8, 0)    # reg_counter
    store_i64(cg + 16, 0)   # label_counter
    store_i64(cg + 24, 0)   # current_block_type: 0=entry, 1=then, 2=else, 3=merge
    store_i64(cg + 32, 0)   # current_block_id
    store_i64(cg + 40, 0)   # loop_header_label (for continue)
    store_i64(cg + 48, 0)   # loop_end_label (for break)
    store_i64(cg + 56, 0)   # block_terminated: 1 if break/continue/return was emitted
    # Variable storage: array of (name_ptr, name_len, alloca_reg) triples
    vars := malloc(256 * 24)  # up to 256 variables per function
    store_i64(cg + 64, vars)
    store_i64(cg + 72, 0)   # var_count
    store_i64(cg + 80, 0)   # param_name_ptr (current function's parameter)
    store_i64(cg + 88, 0)   # param_name_len
    # String constant storage: array of (str_ptr, str_len, global_id) triples
    strings := malloc(1024 * 24)  # up to 1024 strings per module
    store_i64(cg + 96, strings)
    store_i64(cg + 104, 0)  # string_count
    strings_sb := sb_new(65536)  # StringBuilder for string constant declarations
    store_i64(cg + 112, strings_sb)
    cg
}

# Block type constants
F BLOCK_ENTRY() -> i64 = 0
F BLOCK_THEN() -> i64 = 1
F BLOCK_ELSE() -> i64 = 2
F BLOCK_MERGE() -> i64 = 3
F BLOCK_LOOP_HEADER() -> i64 = 4
F BLOCK_LOOP_BODY() -> i64 = 5
F BLOCK_LOOP_END() -> i64 = 6

F cg_set_current_block(cg: i64, block_type: i64, block_id: i64) -> i64 {
    store_i64(cg + 24, block_type)
    store_i64(cg + 32, block_id)
    0
}

F cg_get_current_block_type(cg: i64) -> i64 = load_i64(cg + 24)
F cg_get_current_block_id(cg: i64) -> i64 = load_i64(cg + 32)

# Loop label management (for break/continue)
F cg_set_loop_labels(cg: i64, header: i64, end: i64) -> i64 {
    store_i64(cg + 40, header)
    store_i64(cg + 48, end)
    0
}

F cg_get_loop_header(cg: i64) -> i64 = load_i64(cg + 40)
F cg_get_loop_end(cg: i64) -> i64 = load_i64(cg + 48)

# Block termination tracking (break/continue/return)
F cg_set_terminated(cg: i64, v: i64) -> i64 { store_i64(cg + 56, v); 0 }
F cg_get_terminated(cg: i64) -> i64 = load_i64(cg + 56)
F cg_clear_terminated(cg: i64) -> i64 { store_i64(cg + 56, 0); 0 }

# Variable management
F cg_get_vars(cg: i64) -> i64 = load_i64(cg + 64)
F cg_get_var_count(cg: i64) -> i64 = load_i64(cg + 72)
F cg_set_var_count(cg: i64, c: i64) -> i64 { store_i64(cg + 72, c); 0 }

# Set current function's parameter info
F cg_set_param(cg: i64, name_ptr: i64, name_len: i64) -> i64 {
    store_i64(cg + 80, name_ptr)
    store_i64(cg + 88, name_len)
    0
}

F cg_get_param_ptr(cg: i64) -> i64 = load_i64(cg + 80)
F cg_get_param_len(cg: i64) -> i64 = load_i64(cg + 88)

# Compare two strings by pointer and length
F str_eq(ptr1: i64, len1: i64, ptr2: i64, len2: i64) -> i64 {
    I len1 != len2 { R 0 }
    i: mut i64 = 0
    L {
        I i >= len1 { B } E { 0 }
        I load_byte(ptr1 + i) != load_byte(ptr2 + i) { R 0 }
        i = i + 1
    }
    1
}

# Add a variable binding (name -> alloca register)
F cg_add_var(cg: i64, name_ptr: i64, name_len: i64, alloca_reg: i64) -> i64 {
    vars := cg_get_vars(cg)
    count := cg_get_var_count(cg)
    offset := count * 24
    store_i64(vars + offset + 0, name_ptr)
    store_i64(vars + offset + 8, name_len)
    store_i64(vars + offset + 16, alloca_reg)
    cg_set_var_count(cg, count + 1)
    1
}

# Find a variable by name, returns alloca register or -1 if not found
# Search in reverse order to support variable shadowing
F cg_find_var(cg: i64, name_ptr: i64, name_len: i64) -> i64 {
    vars := cg_get_vars(cg)
    count := cg_get_var_count(cg)
    # Search from most recent to oldest to support shadowing
    i: mut i64 = count - 1
    L {
        I i < 0 { B } E { 0 }
        offset := i * 24
        var_ptr := load_i64(vars + offset + 0)
        var_len := load_i64(vars + offset + 8)
        I str_eq(name_ptr, name_len, var_ptr, var_len) == 1 {
            R load_i64(vars + offset + 16)
        }
        i = i - 1
    }
    0 - 1  # Not found
}

# Clear all variables (call when starting a new function)
F cg_clear_vars(cg: i64) -> i64 {
    cg_set_var_count(cg, 0)
    0
}

# String constant management
F cg_get_strings(cg: i64) -> i64 = load_i64(cg + 96)
F cg_get_string_count(cg: i64) -> i64 = load_i64(cg + 104)
F cg_set_string_count(cg: i64, c: i64) -> i64 { store_i64(cg + 104, c); 0 }
F cg_get_strings_sb(cg: i64) -> i64 = load_i64(cg + 112)

# Add a string constant, returns the global id (@.str.N)
# Also emits the global declaration to strings_sb
F cg_add_string(cg: i64, str_ptr: i64, str_len: i64) -> i64 {
    strings := cg_get_strings(cg)
    count := cg_get_string_count(cg)

    # Check if string already exists
    i: mut i64 = 0
    L {
        I i >= count { B } E { 0 }
        offset := i * 24
        existing_ptr := load_i64(strings + offset + 0)
        existing_len := load_i64(strings + offset + 8)
        I str_eq(str_ptr, str_len, existing_ptr, existing_len) == 1 {
            # Already exists, return its id
            R load_i64(strings + offset + 16)
        }
        i = i + 1
    }

    # Add new string
    offset := count * 24
    store_i64(strings + offset + 0, str_ptr)
    store_i64(strings + offset + 8, str_len)
    store_i64(strings + offset + 16, count)
    cg_set_string_count(cg, count + 1)

    # Emit global declaration: @.str.N = private constant [len+1 x i8] c"...\00"
    strings_sb := cg_get_strings_sb(cg)
    sb_append_cstr(strings_sb, "@.str.")
    sb_append_i64(strings_sb, count)
    sb_append_cstr(strings_sb, " = private constant [")
    sb_append_i64(strings_sb, str_len + 1)
    sb_append_cstr(strings_sb, " x i8] c\"")

    # Emit string contents with escaping
    j: mut i64 = 0
    L {
        I j >= str_len { B } E { 0 }
        ch := load_byte(str_ptr + j)
        I ch == 10 {
            # newline -> \0A
            sb_append_byte(strings_sb, 92)  # backslash
            sb_append_byte(strings_sb, 48)  # 0
            sb_append_byte(strings_sb, 65)  # A
        } E I ch == 13 {
            # carriage return -> \0D
            sb_append_byte(strings_sb, 92)
            sb_append_byte(strings_sb, 48)
            sb_append_byte(strings_sb, 68)  # D
        } E I ch == 9 {
            # tab -> \09
            sb_append_byte(strings_sb, 92)
            sb_append_byte(strings_sb, 48)
            sb_append_byte(strings_sb, 57)  # 9
        } E I ch == 34 {
            # double quote -> \22
            sb_append_byte(strings_sb, 92)
            sb_append_byte(strings_sb, 50)  # 2
            sb_append_byte(strings_sb, 50)  # 2
        } E I ch == 92 {
            # backslash -> \5C
            sb_append_byte(strings_sb, 92)
            sb_append_byte(strings_sb, 53)  # 5
            sb_append_byte(strings_sb, 67)  # C
        } E {
            sb_append_byte(strings_sb, ch)
        }
        j = j + 1
    }

    sb_append_cstr(strings_sb, "\\00\"")
    sb_append_byte(strings_sb, 10)  # newline

    count
}

F cg_get_sb(cg: i64) -> i64 = load_i64(cg + 0)

F cg_fresh_reg(cg: i64) -> i64 {
    r := load_i64(cg + 8)
    store_i64(cg + 8, r + 1)
    r
}

F cg_fresh_label(cg: i64) -> i64 {
    l := load_i64(cg + 16)
    store_i64(cg + 16, l + 1)
    l
}

F cg_reset_regs(cg: i64) -> i64 {
    store_i64(cg + 8, 0)
    store_i64(cg + 16, 0)
    0
}

F cg_emit(cg: i64, s: str) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_cstr(sb, s)
}

F cg_emit_i64(cg: i64, v: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_i64(sb, v)
}

F cg_emit_newline(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_newline(sb)
}

F cg_emit_quote(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_append_byte(sb, 34)
}

F cg_emit_str(cg: i64, ptr: i64, len: i64) -> i64 {
    sb := cg_get_sb(cg)
    i: mut i64 = 0
    L {
        I i >= len { B } E { 0 }
        sb_append_byte(sb, load_byte(ptr + i))
        i = i + 1
    }
    1
}

F cg_emit_header(cg: i64) -> i64 {
    cg_emit(cg, "; Generated by Vais Self-Hosting Compiler (vaisc-stage1)")
    cg_emit_newline(cg)
    cg_emit(cg, "source_filename = ")
    cg_emit_quote(cg)
    cg_emit(cg, "main")
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit(cg, "target triple = ")
    cg_emit_quote(cg)
    cg_emit(cg, "arm64-apple-macosx")
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    # Extern declarations for runtime functions
    cg_emit(cg, "; External declarations")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i32 @puts(ptr)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i32 @putchar(i32)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare ptr @malloc(i64)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare void @free(ptr)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i64 @fopen(ptr, ptr)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i64 @fclose(i64)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i64 @fread(ptr, i64, i64, i64)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i64 @fwrite(ptr, i64, i64, i64)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i64 @fseek(i64, i64, i32)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i64 @ftell(i64)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare ptr @memcpy(ptr, ptr, i64)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i32 @memcmp(ptr, ptr, i64)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i64 @realloc(ptr, i64)")
    cg_emit_newline(cg)
    cg_emit(cg, "declare i64 @strlen(ptr)")
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    # fopen_ptr: wrapper for fopen that takes i64 path
    cg_emit(cg, "; fopen_ptr wrapper: converts i64 path to ptr")
    cg_emit_newline(cg)
    cg_emit(cg, "define i64 @fopen_ptr(i64 %path, ptr %mode) {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %0 = inttoptr i64 %path to ptr")
    cg_emit_newline(cg)
    cg_emit(cg, "  %1 = call i64 @fopen(ptr %0, ptr %mode)")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret i64 %1")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    # Helper function: load byte from memory
    cg_emit(cg, "; Helper function: load byte from memory")
    cg_emit_newline(cg)
    cg_emit(cg, "define i64 @__load_byte(i64 %ptr) {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %0 = inttoptr i64 %ptr to i8*")
    cg_emit_newline(cg)
    cg_emit(cg, "  %1 = load i8, i8* %0")
    cg_emit_newline(cg)
    cg_emit(cg, "  %2 = zext i8 %1 to i64")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret i64 %2")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    # Helper function: store byte to memory
    cg_emit(cg, "; Helper function: store byte to memory")
    cg_emit_newline(cg)
    cg_emit(cg, "define void @__store_byte(i64 %ptr, i64 %val) {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %0 = inttoptr i64 %ptr to i8*")
    cg_emit_newline(cg)
    cg_emit(cg, "  %1 = trunc i64 %val to i8")
    cg_emit_newline(cg)
    cg_emit(cg, "  store i8 %1, i8* %0")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret void")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    # Helper function: load i64 from memory
    cg_emit(cg, "; Helper function: load i64 from memory")
    cg_emit_newline(cg)
    cg_emit(cg, "define i64 @__load_i64(i64 %ptr) {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %0 = inttoptr i64 %ptr to i64*")
    cg_emit_newline(cg)
    cg_emit(cg, "  %1 = load i64, i64* %0")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret i64 %1")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    # Helper function: store i64 to memory
    cg_emit(cg, "; Helper function: store i64 to memory")
    cg_emit_newline(cg)
    cg_emit(cg, "define void @__store_i64(i64 %ptr, i64 %val) {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %0 = inttoptr i64 %ptr to i64*")
    cg_emit_newline(cg)
    cg_emit(cg, "  store i64 %val, i64* %0")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret void")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    1
}

# Emit operand (either register or parameter name)
F cg_emit_operand(cg: i64, reg: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    I reg == 0 - 1 {
        cg_emit(cg, "%")
        cg_emit_str(cg, param_name_ptr, param_name_len)
        0
    } E {
        cg_emit(cg, "%")
        cg_emit_i64(cg, reg)
        0
    }
}

# Generate integer expression
F cg_gen_int_expr(cg: i64, expr: i64) -> i64 {
    value := load_i64(expr + 8)
    reg := cg_fresh_reg(cg)
    cg_emit(cg, "  %")
    cg_emit_i64(cg, reg)
    cg_emit(cg, " = add i64 ")
    cg_emit_i64(cg, value)
    cg_emit(cg, ", 0")
    cg_emit_newline(cg)
    reg
}

# Generate call expression
# Check if an expression is a string literal
F expr_is_string(expr: i64) -> i64 {
    kind := load_i64(expr + 0)
    I kind == EXPR_STRING() { 1 } E { 0 }
}

# Check if function name matches "puts" (4 chars)
F is_puts_func(ptr: i64, len: i64) -> i64 {
    I len != 4 { R 0 }
    I load_byte(ptr) != 112 { R 0 }       # p
    I load_byte(ptr + 1) != 117 { R 0 }   # u
    I load_byte(ptr + 2) != 116 { R 0 }   # t
    I load_byte(ptr + 3) != 115 { R 0 }   # s
    1
}

# Check if function name matches "putchar" (7 chars)
F is_putchar_func(ptr: i64, len: i64) -> i64 {
    I len != 7 { R 0 }
    I load_byte(ptr) != 112 { R 0 }       # p
    I load_byte(ptr + 1) != 117 { R 0 }   # u
    I load_byte(ptr + 2) != 116 { R 0 }   # t
    I load_byte(ptr + 3) != 99 { R 0 }    # c
    I load_byte(ptr + 4) != 104 { R 0 }   # h
    I load_byte(ptr + 5) != 97 { R 0 }    # a
    I load_byte(ptr + 6) != 114 { R 0 }   # r
    1
}

# Check if function name matches "malloc" (6 chars)
F is_malloc_func(ptr: i64, len: i64) -> i64 {
    I len != 6 { R 0 }
    I load_byte(ptr) != 109 { R 0 }       # m
    I load_byte(ptr + 1) != 97 { R 0 }    # a
    I load_byte(ptr + 2) != 108 { R 0 }   # l
    I load_byte(ptr + 3) != 108 { R 0 }   # l
    I load_byte(ptr + 4) != 111 { R 0 }   # o
    I load_byte(ptr + 5) != 99 { R 0 }    # c
    1
}

# Check if function name matches "free" (4 chars)
F is_free_func(ptr: i64, len: i64) -> i64 {
    I len != 4 { R 0 }
    I load_byte(ptr) != 102 { R 0 }       # f
    I load_byte(ptr + 1) != 114 { R 0 }   # r
    I load_byte(ptr + 2) != 101 { R 0 }   # e
    I load_byte(ptr + 3) != 101 { R 0 }   # e
    1
}

# Check if function name matches "load_byte" (9 chars)
F is_load_byte_func(ptr: i64, len: i64) -> i64 {
    I len != 9 { R 0 }
    I load_byte(ptr) != 108 { R 0 }       # l
    I load_byte(ptr + 1) != 111 { R 0 }   # o
    I load_byte(ptr + 2) != 97 { R 0 }    # a
    I load_byte(ptr + 3) != 100 { R 0 }   # d
    I load_byte(ptr + 4) != 95 { R 0 }    # _
    I load_byte(ptr + 5) != 98 { R 0 }    # b
    I load_byte(ptr + 6) != 121 { R 0 }   # y
    I load_byte(ptr + 7) != 116 { R 0 }   # t
    I load_byte(ptr + 8) != 101 { R 0 }   # e
    1
}

# Check if function name matches "store_byte" (10 chars)
F is_store_byte_func(ptr: i64, len: i64) -> i64 {
    I len != 10 { R 0 }
    I load_byte(ptr) != 115 { R 0 }       # s
    I load_byte(ptr + 1) != 116 { R 0 }   # t
    I load_byte(ptr + 2) != 111 { R 0 }   # o
    I load_byte(ptr + 3) != 114 { R 0 }   # r
    I load_byte(ptr + 4) != 101 { R 0 }   # e
    I load_byte(ptr + 5) != 95 { R 0 }    # _
    I load_byte(ptr + 6) != 98 { R 0 }    # b
    I load_byte(ptr + 7) != 121 { R 0 }   # y
    I load_byte(ptr + 8) != 116 { R 0 }   # t
    I load_byte(ptr + 9) != 101 { R 0 }   # e
    1
}

# Check if function name matches "load_i64" (8 chars)
F is_load_i64_func(ptr: i64, len: i64) -> i64 {
    I len != 8 { R 0 }
    I load_byte(ptr) != 108 { R 0 }       # l
    I load_byte(ptr + 1) != 111 { R 0 }   # o
    I load_byte(ptr + 2) != 97 { R 0 }    # a
    I load_byte(ptr + 3) != 100 { R 0 }   # d
    I load_byte(ptr + 4) != 95 { R 0 }    # _
    I load_byte(ptr + 5) != 105 { R 0 }   # i
    I load_byte(ptr + 6) != 54 { R 0 }    # 6
    I load_byte(ptr + 7) != 52 { R 0 }    # 4
    1
}

# Check if function name matches "store_i64" (9 chars)
F is_store_i64_func(ptr: i64, len: i64) -> i64 {
    I len != 9 { R 0 }
    I load_byte(ptr) != 115 { R 0 }       # s
    I load_byte(ptr + 1) != 116 { R 0 }   # t
    I load_byte(ptr + 2) != 111 { R 0 }   # o
    I load_byte(ptr + 3) != 114 { R 0 }   # r
    I load_byte(ptr + 4) != 101 { R 0 }   # e
    I load_byte(ptr + 5) != 95 { R 0 }    # _
    I load_byte(ptr + 6) != 105 { R 0 }   # i
    I load_byte(ptr + 7) != 54 { R 0 }    # 6
    I load_byte(ptr + 8) != 52 { R 0 }    # 4
    1
}

# Check if function name matches "memcpy" (6 chars)
F is_memcpy_func(ptr: i64, len: i64) -> i64 {
    I len != 6 { R 0 }
    I load_byte(ptr) != 109 { R 0 }       # m
    I load_byte(ptr + 1) != 101 { R 0 }   # e
    I load_byte(ptr + 2) != 109 { R 0 }   # m
    I load_byte(ptr + 3) != 99 { R 0 }    # c
    I load_byte(ptr + 4) != 112 { R 0 }   # p
    I load_byte(ptr + 5) != 121 { R 0 }   # y
    1
}

# Check if function name matches "memcmp" (6 chars)
F is_memcmp_func(ptr: i64, len: i64) -> i64 {
    I len != 6 { R 0 }
    I load_byte(ptr) != 109 { R 0 }       # m
    I load_byte(ptr + 1) != 101 { R 0 }   # e
    I load_byte(ptr + 2) != 109 { R 0 }   # m
    I load_byte(ptr + 3) != 99 { R 0 }    # c
    I load_byte(ptr + 4) != 109 { R 0 }   # m
    I load_byte(ptr + 5) != 112 { R 0 }   # p
    1
}

# Check if function name matches "strlen" (6 chars)
F is_strlen_func(ptr: i64, len: i64) -> i64 {
    I len != 6 { R 0 }
    I load_byte(ptr) != 115 { R 0 }       # s
    I load_byte(ptr + 1) != 116 { R 0 }   # t
    I load_byte(ptr + 2) != 114 { R 0 }   # r
    I load_byte(ptr + 3) != 108 { R 0 }   # l
    I load_byte(ptr + 4) != 101 { R 0 }   # e
    I load_byte(ptr + 5) != 110 { R 0 }   # n
    1
}

# Check if function name matches "memcpy_str" (10 chars)
F is_memcpy_str_func(ptr: i64, len: i64) -> i64 {
    I len != 10 { R 0 }
    I load_byte(ptr) != 109 { R 0 }       # m
    I load_byte(ptr + 1) != 101 { R 0 }   # e
    I load_byte(ptr + 2) != 109 { R 0 }   # m
    I load_byte(ptr + 3) != 99 { R 0 }    # c
    I load_byte(ptr + 4) != 112 { R 0 }   # p
    I load_byte(ptr + 5) != 121 { R 0 }   # y
    I load_byte(ptr + 6) != 95 { R 0 }    # _
    I load_byte(ptr + 7) != 115 { R 0 }   # s
    I load_byte(ptr + 8) != 116 { R 0 }   # t
    I load_byte(ptr + 9) != 114 { R 0 }   # r
    1
}

F cg_gen_call_expr(cg: i64, expr: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    func_name_ptr := expr_get_field0(expr)
    func_name_len := expr_get_field1(expr)
    args := expr_get_field2(expr)
    arg_count := expr_get_field3(expr)

    # Check for known runtime functions
    is_puts := is_puts_func(func_name_ptr, func_name_len)
    is_putchar := is_putchar_func(func_name_ptr, func_name_len)
    is_malloc := is_malloc_func(func_name_ptr, func_name_len)
    is_free := is_free_func(func_name_ptr, func_name_len)
    is_load_byte := is_load_byte_func(func_name_ptr, func_name_len)
    is_store_byte := is_store_byte_func(func_name_ptr, func_name_len)
    is_load_i64 := is_load_i64_func(func_name_ptr, func_name_len)
    is_store_i64 := is_store_i64_func(func_name_ptr, func_name_len)
    is_memcpy := is_memcpy_func(func_name_ptr, func_name_len)
    is_memcmp := is_memcmp_func(func_name_ptr, func_name_len)
    is_strlen := is_strlen_func(func_name_ptr, func_name_len)
    is_memcpy_str := is_memcpy_str_func(func_name_ptr, func_name_len)

    # Track which args are strings (for ptr type)
    arg_is_string := malloc(16)

    # Generate arguments first
    arg_regs := malloc(16 * 8)
    i: mut i64 = 0
    L {
        I i >= arg_count { B } E { 0 }
        arg := load_i64(args + i * 8)
        store_byte(arg_is_string + i, expr_is_string(arg))
        arg_reg := cg_gen_expr(cg, arg, param_name_ptr, param_name_len)
        store_i64(arg_regs + i * 8, arg_reg)
        i = i + 1
    }

    result_reg := cg_fresh_reg(cg)

    # Handle puts: i32 @puts(ptr)
    I is_puts == 1 {
        # Convert i64 to ptr
        ptr_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, ptr_reg)
        cg_emit(cg, " = inttoptr i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 0))
        cg_emit(cg, " to ptr")
        cg_emit_newline(cg)
        # Call puts
        puts_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, puts_reg)
        cg_emit(cg, " = call i32 @puts(ptr %")
        cg_emit_i64(cg, ptr_reg)
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        0
    # Handle putchar: i32 @putchar(i32)
    } E I is_putchar == 1 {
        # Truncate i64 to i32 first
        arg_reg := load_i64(arg_regs + 0)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " = trunc i64 %")
        cg_emit_i64(cg, arg_reg)
        cg_emit(cg, " to i32")
        cg_emit_newline(cg)
        # Call putchar with truncated value
        call_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, call_reg)
        cg_emit(cg, " = call i32 @putchar(i32 %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        0
    # Handle malloc: ptr @malloc(i64)
    } E I is_malloc == 1 {
        cg_emit(cg, "  %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " = call ptr @malloc(i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 0))
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        # Convert ptr to i64
        conv_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, conv_reg)
        cg_emit(cg, " = ptrtoint ptr %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " to i64")
        cg_emit_newline(cg)
        free(arg_regs)
        free(arg_is_string)
        R conv_reg
    # Handle free: void @free(ptr)
    } E I is_free == 1 {
        # Convert i64 to ptr
        ptr_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, ptr_reg)
        cg_emit(cg, " = inttoptr i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 0))
        cg_emit(cg, " to ptr")
        cg_emit_newline(cg)
        cg_emit(cg, "  call void @free(ptr %")
        cg_emit_i64(cg, ptr_reg)
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        free(arg_regs)
        free(arg_is_string)
        R 0
    # Handle load_byte: i64 @__load_byte(i64)
    } E I is_load_byte == 1 {
        cg_emit(cg, "  %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " = call i64 @__load_byte(i64 ")
        cg_emit_operand(cg, load_i64(arg_regs + 0), param_name_ptr, param_name_len)
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        free(arg_regs)
        free(arg_is_string)
        R result_reg
    # Handle store_byte: void @__store_byte(i64, i64)
    } E I is_store_byte == 1 {
        cg_emit(cg, "  call void @__store_byte(i64 ")
        cg_emit_operand(cg, load_i64(arg_regs + 0), param_name_ptr, param_name_len)
        cg_emit(cg, ", i64 ")
        cg_emit_operand(cg, load_i64(arg_regs + 8), param_name_ptr, param_name_len)
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        free(arg_regs)
        free(arg_is_string)
        R 0
    # Handle load_i64: i64 @__load_i64(i64)
    } E I is_load_i64 == 1 {
        cg_emit(cg, "  %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " = call i64 @__load_i64(i64 ")
        cg_emit_operand(cg, load_i64(arg_regs + 0), param_name_ptr, param_name_len)
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        free(arg_regs)
        free(arg_is_string)
        R result_reg
    # Handle store_i64: void @__store_i64(i64, i64)
    } E I is_store_i64 == 1 {
        cg_emit(cg, "  call void @__store_i64(i64 ")
        cg_emit_operand(cg, load_i64(arg_regs + 0), param_name_ptr, param_name_len)
        cg_emit(cg, ", i64 ")
        cg_emit_operand(cg, load_i64(arg_regs + 8), param_name_ptr, param_name_len)
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        free(arg_regs)
        free(arg_is_string)
        R 0
    # Handle memcpy: ptr @memcpy(ptr, ptr, i64) - convert i64 args to ptr
    } E I is_memcpy == 1 {
        # Convert first arg (dest) to ptr
        ptr1_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, ptr1_reg)
        cg_emit(cg, " = inttoptr i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 0))
        cg_emit(cg, " to ptr")
        cg_emit_newline(cg)
        # Convert second arg (src) to ptr
        ptr2_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, ptr2_reg)
        cg_emit(cg, " = inttoptr i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 8))
        cg_emit(cg, " to ptr")
        cg_emit_newline(cg)
        # Call memcpy - get new register for result
        memcpy_result := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, memcpy_result)
        cg_emit(cg, " = call ptr @memcpy(ptr %")
        cg_emit_i64(cg, ptr1_reg)
        cg_emit(cg, ", ptr %")
        cg_emit_i64(cg, ptr2_reg)
        cg_emit(cg, ", i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 16))
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        # Convert result ptr to i64
        conv_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, conv_reg)
        cg_emit(cg, " = ptrtoint ptr %")
        cg_emit_i64(cg, memcpy_result)
        cg_emit(cg, " to i64")
        cg_emit_newline(cg)
        free(arg_regs)
        free(arg_is_string)
        R conv_reg
    # Handle memcmp: i32 @memcmp(ptr, ptr, i64) - convert i64 args to ptr
    } E I is_memcmp == 1 {
        # Convert first arg to ptr
        ptr1_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, ptr1_reg)
        cg_emit(cg, " = inttoptr i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 0))
        cg_emit(cg, " to ptr")
        cg_emit_newline(cg)
        # Convert second arg to ptr
        ptr2_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, ptr2_reg)
        cg_emit(cg, " = inttoptr i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 8))
        cg_emit(cg, " to ptr")
        cg_emit_newline(cg)
        # Call memcmp - get new register for result
        memcmp_result := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, memcmp_result)
        cg_emit(cg, " = call i32 @memcmp(ptr %")
        cg_emit_i64(cg, ptr1_reg)
        cg_emit(cg, ", ptr %")
        cg_emit_i64(cg, ptr2_reg)
        cg_emit(cg, ", i64 %")
        cg_emit_i64(cg, load_i64(arg_regs + 16))
        cg_emit(cg, ")")
        cg_emit_newline(cg)
        # Extend i32 result to i64
        ext_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, ext_reg)
        cg_emit(cg, " = sext i32 %")
        cg_emit_i64(cg, memcmp_result)
        cg_emit(cg, " to i64")
        cg_emit_newline(cg)
        free(arg_regs)
        free(arg_is_string)
        R ext_reg
    # Handle strlen: i64 @strlen(ptr) - first arg may be string (ptr) or i64
    } E I is_strlen == 1 {
        # Check if arg is a string constant (already ptr) or i64
        I load_byte(arg_is_string + 0) == 1 {
            # String constant: arg_reg is already ptr-like, use directly
            cg_emit(cg, "  %")
            cg_emit_i64(cg, result_reg)
            cg_emit(cg, " = call i64 @strlen(ptr %")
            cg_emit_i64(cg, load_i64(arg_regs + 0))
            cg_emit(cg, ")")
            cg_emit_newline(cg)
            0
        } E {
            # i64 pointer: convert to ptr first
            # Allocate both regs upfront for sequential numbering
            ptr_reg := cg_fresh_reg(cg)
            strlen_result := cg_fresh_reg(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, ptr_reg)
            cg_emit(cg, " = inttoptr i64 %")
            cg_emit_i64(cg, load_i64(arg_regs + 0))
            cg_emit(cg, " to ptr")
            cg_emit_newline(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, strlen_result)
            cg_emit(cg, " = call i64 @strlen(ptr %")
            cg_emit_i64(cg, ptr_reg)
            cg_emit(cg, ")")
            cg_emit_newline(cg)
            free(arg_regs)
            free(arg_is_string)
            R strlen_result
        }
        free(arg_regs)
        free(arg_is_string)
        R result_reg
    # Handle memcpy_str: copies from str (ptr) to i64 dest
    } E I is_memcpy_str == 1 {
        # Allocate all regs upfront for sequential numbering
        dest_ptr := cg_fresh_reg(cg)
        # Second arg (src) may be string constant or i64
        I load_byte(arg_is_string + 1) == 1 {
            # String constant: only need dest_ptr and memcpy_result
            memcpy_result := cg_fresh_reg(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, dest_ptr)
            cg_emit(cg, " = inttoptr i64 %")
            cg_emit_i64(cg, load_i64(arg_regs + 0))
            cg_emit(cg, " to ptr")
            cg_emit_newline(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, memcpy_result)
            cg_emit(cg, " = call ptr @memcpy(ptr %")
            cg_emit_i64(cg, dest_ptr)
            cg_emit(cg, ", ptr %")
            cg_emit_i64(cg, load_i64(arg_regs + 8))
            cg_emit(cg, ", i64 %")
            cg_emit_i64(cg, load_i64(arg_regs + 16))
            cg_emit(cg, ")")
            cg_emit_newline(cg)
            0
        } E {
            # i64 pointer: need dest_ptr, src_ptr, memcpy_result
            src_ptr := cg_fresh_reg(cg)
            memcpy_result := cg_fresh_reg(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, dest_ptr)
            cg_emit(cg, " = inttoptr i64 %")
            cg_emit_i64(cg, load_i64(arg_regs + 0))
            cg_emit(cg, " to ptr")
            cg_emit_newline(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, src_ptr)
            cg_emit(cg, " = inttoptr i64 %")
            cg_emit_i64(cg, load_i64(arg_regs + 8))
            cg_emit(cg, " to ptr")
            cg_emit_newline(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, memcpy_result)
            cg_emit(cg, " = call ptr @memcpy(ptr %")
            cg_emit_i64(cg, dest_ptr)
            cg_emit(cg, ", ptr %")
            cg_emit_i64(cg, src_ptr)
            cg_emit(cg, ", i64 %")
            cg_emit_i64(cg, load_i64(arg_regs + 16))
            cg_emit(cg, ")")
            cg_emit_newline(cg)
            0
        }
        free(arg_regs)
        free(arg_is_string)
        R 1
    # Default: user-defined function with i64 args
    } E {
        cg_emit(cg, "  %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " = call i64 @")
        cg_emit_str(cg, func_name_ptr, func_name_len)
        cg_emit(cg, "(")

        # Emit arguments
        i = 0
        L {
            I i >= arg_count { B } E { 0 }
            I i > 0 { cg_emit(cg, ", "); 0 } E { 0 }
            cg_emit(cg, "i64 ")
            arg_reg := load_i64(arg_regs + i * 8)
            cg_emit_operand(cg, arg_reg, param_name_ptr, param_name_len)
            i = i + 1
        }

        cg_emit(cg, ")")
        cg_emit_newline(cg)
        0
    }

    free(arg_regs)
    free(arg_is_string)
    result_reg
}

# Generate binary expression
F cg_gen_binary_expr(cg: i64, expr: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    op := expr_get_field0(expr)
    left := expr_get_field1(expr)
    right := expr_get_field2(expr)

    left_reg := cg_gen_expr(cg, left, param_name_ptr, param_name_len)
    right_reg := cg_gen_expr(cg, right, param_name_ptr, param_name_len)

    result_reg := cg_fresh_reg(cg)
    cg_emit(cg, "  %")
    cg_emit_i64(cg, result_reg)

    # Emit instruction based on operator
    I op == BINOP_ADD() {
        cg_emit(cg, " = add i64 ")
        0
    } E I op == BINOP_SUB() {
        cg_emit(cg, " = sub i64 ")
        0
    } E I op == BINOP_MUL() {
        cg_emit(cg, " = mul i64 ")
        0
    } E I op == BINOP_DIV() {
        cg_emit(cg, " = sdiv i64 ")
        0
    } E I op == BINOP_MOD() {
        cg_emit(cg, " = srem i64 ")
        0
    } E I op == BINOP_LT() {
        cg_emit(cg, " = icmp slt i64 ")
        0
    } E I op == BINOP_LTE() {
        cg_emit(cg, " = icmp sle i64 ")
        0
    } E I op == BINOP_GT() {
        cg_emit(cg, " = icmp sgt i64 ")
        0
    } E I op == BINOP_GTE() {
        cg_emit(cg, " = icmp sge i64 ")
        0
    } E I op == BINOP_EQ() {
        cg_emit(cg, " = icmp eq i64 ")
        0
    } E I op == BINOP_NEQ() {
        cg_emit(cg, " = icmp ne i64 ")
        0
    } E I op == BINOP_AND() {
        cg_emit(cg, " = and i64 ")
        0
    } E I op == BINOP_OR() {
        cg_emit(cg, " = or i64 ")
        0
    } E {
        # Default to add for unknown ops
        cg_emit(cg, " = add i64 ")
        0
    }

    cg_emit_operand(cg, left_reg, param_name_ptr, param_name_len)
    cg_emit(cg, ", ")
    cg_emit_operand(cg, right_reg, param_name_ptr, param_name_len)
    cg_emit_newline(cg)

    # For comparison ops, extend i1 to i64
    I op >= BINOP_LT() && op <= BINOP_NEQ() {
        ext_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, ext_reg)
        cg_emit(cg, " = zext i1 %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " to i64")
        cg_emit_newline(cg)
        ext_reg
    } E {
        result_reg
    }
}

# Generate loop expression: L { body }
# Structure: br loop_header -> body -> br loop_header, with break -> loop_end
F cg_gen_loop_expr(cg: i64, expr: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    body := expr_get_field0(expr)

    # Generate unique labels for loop
    loop_id := cg_fresh_label(cg)

    # Save previous loop labels and terminated state (for nested loops)
    prev_header := cg_get_loop_header(cg)
    prev_end := cg_get_loop_end(cg)
    prev_terminated := cg_get_terminated(cg)

    # Set current loop labels and clear terminated
    cg_set_loop_labels(cg, loop_id, loop_id)
    cg_clear_terminated(cg)

    # Jump to loop header
    cg_emit(cg, "  br label %loop_header")
    cg_emit_i64(cg, loop_id)
    cg_emit_newline(cg)

    # Loop header block
    cg_emit(cg, "loop_header")
    cg_emit_i64(cg, loop_id)
    cg_emit(cg, ":")
    cg_emit_newline(cg)
    cg_set_current_block(cg, BLOCK_LOOP_HEADER(), loop_id)

    # Generate body (the body expression handles break statements)
    body_reg := cg_gen_expr(cg, body, param_name_ptr, param_name_len)

    # After body, check if terminated (all paths in body led to break/return)
    body_terminated := cg_get_terminated(cg)

    # If body was NOT fully terminated, emit back edge to loop header
    # (some path through the body reached the end without break)
    I body_terminated == 0 {
        cg_emit(cg, "  br label %loop_header")
        cg_emit_i64(cg, loop_id)
        cg_emit_newline(cg)
        0
    } E { 0 }

    # Loop end block (break target) - this is where break jumps to
    cg_emit(cg, "loop_end")
    cg_emit_i64(cg, loop_id)
    cg_emit(cg, ":")
    cg_emit_newline(cg)
    cg_set_current_block(cg, BLOCK_LOOP_END(), loop_id)

    # Restore previous loop labels and clear terminated (loop exit is normal flow)
    cg_set_loop_labels(cg, prev_header, prev_end)
    cg_set_terminated(cg, prev_terminated)

    # Loop expression returns 0
    result_reg := cg_fresh_reg(cg)
    cg_emit(cg, "  %")
    cg_emit_i64(cg, result_reg)
    cg_emit(cg, " = add i64 0, 0")
    cg_emit_newline(cg)
    result_reg
}

# Generate if-else expression
# Returns result register number
# Updates current block info after execution
F cg_gen_if_expr(cg: i64, expr: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    cond := expr_get_field0(expr)
    then_expr := expr_get_field1(expr)
    else_expr := expr_get_field2(expr)

    # Generate unique labels
    label_id := cg_fresh_label(cg)

    # Generate condition
    cond_reg := cg_gen_expr(cg, cond, param_name_ptr, param_name_len)

    # Convert to i1 if needed (non-zero = true)
    cmp_reg := cg_fresh_reg(cg)
    cg_emit(cg, "  %")
    cg_emit_i64(cg, cmp_reg)
    cg_emit(cg, " = icmp ne i64 ")
    cg_emit_operand(cg, cond_reg, param_name_ptr, param_name_len)
    cg_emit(cg, ", 0")
    cg_emit_newline(cg)

    # Conditional branch
    cg_emit(cg, "  br i1 %")
    cg_emit_i64(cg, cmp_reg)
    cg_emit(cg, ", label %then")
    cg_emit_i64(cg, label_id)
    cg_emit(cg, ", label %else")
    cg_emit_i64(cg, label_id)
    cg_emit_newline(cg)

    # Then block
    cg_emit(cg, "then")
    cg_emit_i64(cg, label_id)
    cg_emit(cg, ":")
    cg_emit_newline(cg)
    cg_set_current_block(cg, BLOCK_THEN(), label_id)
    cg_clear_terminated(cg)  # Clear before then
    then_reg := cg_gen_expr(cg, then_expr, param_name_ptr, param_name_len)
    then_terminated := cg_get_terminated(cg)
    # After then_expr, check what the current block is now (might have changed due to nesting)
    then_final_type := cg_get_current_block_type(cg)
    then_final_id := cg_get_current_block_id(cg)
    # Only emit br if not terminated by break/continue/return
    I then_terminated == 0 {
        cg_emit(cg, "  br label %merge")
        cg_emit_i64(cg, label_id)
        cg_emit_newline(cg)
        0
    } E { 0 }

    # Else block
    cg_emit(cg, "else")
    cg_emit_i64(cg, label_id)
    cg_emit(cg, ":")
    cg_emit_newline(cg)
    cg_set_current_block(cg, BLOCK_ELSE(), label_id)
    cg_clear_terminated(cg)  # Clear before else
    else_reg: mut i64 = 0
    I else_expr != 0 {
        else_reg = cg_gen_expr(cg, else_expr, param_name_ptr, param_name_len)
        0
    } E {
        # No else branch - use 0
        else_reg = cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, else_reg)
        cg_emit(cg, " = add i64 0, 0")
        cg_emit_newline(cg)
        0
    }
    else_terminated := cg_get_terminated(cg)
    # After else_expr, check what the current block is now
    else_final_type := cg_get_current_block_type(cg)
    else_final_id := cg_get_current_block_id(cg)
    # Only emit br if not terminated
    I else_terminated == 0 {
        cg_emit(cg, "  br label %merge")
        cg_emit_i64(cg, label_id)
        cg_emit_newline(cg)
        0
    } E { 0 }

    # Merge block - only generate if at least one branch reaches it
    I then_terminated == 1 && else_terminated == 1 {
        # Both branches terminated - no merge needed, propagate termination
        cg_set_terminated(cg, 1)
        0 - 2  # No merge block, return special value
    } E {
        # At least one branch reaches merge
        cg_emit(cg, "merge")
        cg_emit_i64(cg, label_id)
        cg_emit(cg, ":")
        cg_emit_newline(cg)
        cg_clear_terminated(cg)  # We're now in merge, not terminated

        # Generate phi only with non-terminated predecessors
        I then_terminated == 0 && else_terminated == 0 {
            # Both branches reach merge - normal phi
            result_reg := cg_fresh_reg(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, result_reg)
            cg_emit(cg, " = phi i64 [ ")
            cg_emit_operand(cg, then_reg, param_name_ptr, param_name_len)
            cg_emit(cg, ", %")
            I then_final_type == BLOCK_MERGE() {
                cg_emit(cg, "merge")
                cg_emit_i64(cg, then_final_id)
                0
            } E {
                cg_emit(cg, "then")
                cg_emit_i64(cg, label_id)
                0
            }
            cg_emit(cg, " ], [ ")
            cg_emit_operand(cg, else_reg, param_name_ptr, param_name_len)
            cg_emit(cg, ", %")
            I else_final_type == BLOCK_MERGE() {
                cg_emit(cg, "merge")
                cg_emit_i64(cg, else_final_id)
                0
            } E {
                cg_emit(cg, "else")
                cg_emit_i64(cg, label_id)
                0
            }
            cg_emit(cg, " ]")
            cg_emit_newline(cg)
            cg_set_current_block(cg, BLOCK_MERGE(), label_id)
            result_reg
        } E I then_terminated == 1 {
            # Only else reaches merge - use else value directly
            cg_set_current_block(cg, BLOCK_MERGE(), label_id)
            else_reg
        } E {
            # Only then reaches merge - use then value directly
            cg_set_current_block(cg, BLOCK_MERGE(), label_id)
            then_reg
        }
    }
}

# Generate single statement, returns 1 if control flow was terminated (break/continue/return)
F cg_gen_stmt(cg: i64, stmt: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    stmt_kind := load_i64(stmt + 0)

    I stmt_kind == STMT_LET() {
        # Let binding: name := value
        # Layout: kind(8) + name_ptr(8) + name_len(8) + value(8)
        name_ptr := load_i64(stmt + 8)
        name_len := load_i64(stmt + 16)
        value := load_i64(stmt + 24)

        # Generate alloca in entry block (simplified: emit here)
        alloca_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, alloca_reg)
        cg_emit(cg, " = alloca i64")
        cg_emit_newline(cg)

        # Generate value expression
        value_reg := cg_gen_expr(cg, value, param_name_ptr, param_name_len)

        # Store value to alloca
        cg_emit(cg, "  store i64 ")
        cg_emit_operand(cg, value_reg, param_name_ptr, param_name_len)
        cg_emit(cg, ", i64* %")
        cg_emit_i64(cg, alloca_reg)
        cg_emit_newline(cg)

        # Register variable in symbol table
        cg_add_var(cg, name_ptr, name_len, alloca_reg)

        R 0
    } E I stmt_kind == STMT_BREAK() {
        # Break: jump to loop_end
        loop_end := cg_get_loop_end(cg)
        cg_emit(cg, "  br label %loop_end")
        cg_emit_i64(cg, loop_end)
        cg_emit_newline(cg)
        cg_set_terminated(cg, 1)
        R 1  # control flow terminated
    } E I stmt_kind == STMT_RETURN() {
        # Return statement: R expr
        ret_value := load_i64(stmt + 8)
        value_reg := cg_gen_expr(cg, ret_value, param_name_ptr, param_name_len)
        cg_emit(cg, "  ret i64 ")
        cg_emit_operand(cg, value_reg, param_name_ptr, param_name_len)
        cg_emit_newline(cg)
        cg_set_terminated(cg, 1)
        R 1  # control flow terminated
    } E I stmt_kind == STMT_EXPR() {
        # Expression statement: evaluate and discard
        stmt_expr := load_i64(stmt + 8)  # expr field
        cg_gen_expr(cg, stmt_expr, param_name_ptr, param_name_len)
        R 0
    } E { 0 }
}

# Generate block expression
F cg_gen_block_expr(cg: i64, expr: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    stmts := expr_get_field0(expr)
    stmts_len := expr_get_field1(expr)
    final_expr := expr_get_field2(expr)

    # Generate statements
    terminated: mut i64 = 0
    i: mut i64 = 0
    L {
        I i >= stmts_len { B } E { 0 }
        I terminated == 1 { B } E { 0 }  # Skip after break/continue/return
        I cg_get_terminated(cg) == 1 { B } E { 0 }  # Also check global terminated
        stmt := load_i64(stmts + i * 8)
        terminated = cg_gen_stmt(cg, stmt, param_name_ptr, param_name_len)
        i = i + 1
    }

    # Check global terminated (from nested blocks)
    I cg_get_terminated(cg) == 1 {
        terminated = 1
        0
    } E { 0 }

    # Generate final expression (only if not terminated by break etc)
    I terminated == 1 {
        # Block was terminated by break/return, don't emit any code
        # Return a dummy register number (won't be used)
        0 - 2  # Special marker for terminated block
    } E I final_expr != 0 {
        cg_gen_expr(cg, final_expr, param_name_ptr, param_name_len)
    } E {
        # No final expression, return 0
        result_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, result_reg)
        cg_emit(cg, " = add i64 0, 0")
        cg_emit_newline(cg)
        result_reg
    }
}

# Generate a single match arm comparison
# result_alloca is the alloca where the result should be stored
F cg_gen_match_arm(cg: i64, scrut_reg: i64, pattern: i64, body: i64,
                   label_id: i64, arm_idx: i64, param_ptr: i64, param_len: i64,
                   result_alloca: i64, merge_label: i64) -> i64 {
    # Generate comparison
    cmp_reg := cg_fresh_reg(cg)
    cg_emit(cg, "  %")
    cg_emit_i64(cg, cmp_reg)
    cg_emit(cg, " = icmp eq i64 ")
    cg_emit_operand(cg, scrut_reg, param_ptr, param_len)
    cg_emit(cg, ", ")
    cg_emit_i64(cg, pattern)
    cg_emit_newline(cg)

    # Branch: if match, goto arm body; else goto next
    cg_emit(cg, "  br i1 %")
    cg_emit_i64(cg, cmp_reg)
    cg_emit(cg, ", label %match_arm")
    cg_emit_i64(cg, label_id)
    cg_emit(cg, "_")
    cg_emit_i64(cg, arm_idx)
    cg_emit(cg, ", label %match_next")
    cg_emit_i64(cg, label_id)
    cg_emit(cg, "_")
    cg_emit_i64(cg, arm_idx)
    cg_emit_newline(cg)

    # Arm body block
    cg_emit(cg, "match_arm")
    cg_emit_i64(cg, label_id)
    cg_emit(cg, "_")
    cg_emit_i64(cg, arm_idx)
    cg_emit(cg, ":")
    cg_emit_newline(cg)

    arm_result := cg_gen_expr(cg, body, param_ptr, param_len)

    # Store result to alloca
    cg_emit(cg, "  store i64 ")
    cg_emit_operand(cg, arm_result, param_ptr, param_len)
    cg_emit(cg, ", i64* %")
    cg_emit_i64(cg, result_alloca)
    cg_emit_newline(cg)

    cg_emit(cg, "  br label %match_merge")
    cg_emit_i64(cg, merge_label)
    cg_emit_newline(cg)

    # Next check block
    cg_emit(cg, "match_next")
    cg_emit_i64(cg, label_id)
    cg_emit(cg, "_")
    cg_emit_i64(cg, arm_idx)
    cg_emit(cg, ":")
    cg_emit_newline(cg)

    1
}

# Generate match expression
F cg_gen_match_expr(cg: i64, expr: i64, param_ptr: i64, param_len: i64) -> i64 {
    scrutinee := expr_get_field0(expr)
    arms := expr_get_field1(expr)
    arm_count := expr_get_field2(expr)

    label_id := cg_fresh_label(cg)

    # Create alloca to store result
    result_alloca := cg_fresh_reg(cg)
    cg_emit(cg, "  %")
    cg_emit_i64(cg, result_alloca)
    cg_emit(cg, " = alloca i64")
    cg_emit_newline(cg)

    # Initialize with 0
    cg_emit(cg, "  store i64 0, i64* %")
    cg_emit_i64(cg, result_alloca)
    cg_emit_newline(cg)

    # Generate scrutinee
    scrut_reg := cg_gen_expr(cg, scrutinee, param_ptr, param_len)

    # Generate each arm
    i: mut i64 = 0
    L {
        I i >= arm_count { B } E { 0 }
        pattern := load_i64(arms + i * 16)
        body := load_i64(arms + i * 16 + 8)
        cg_gen_match_arm(cg, scrut_reg, pattern, body, label_id, i, param_ptr, param_len, result_alloca, label_id)
        i = i + 1
    }

    # Default: keep the 0 value
    cg_emit(cg, "  br label %match_merge")
    cg_emit_i64(cg, label_id)
    cg_emit_newline(cg)

    # Merge block
    cg_emit(cg, "match_merge")
    cg_emit_i64(cg, label_id)
    cg_emit(cg, ":")
    cg_emit_newline(cg)

    # Load result from alloca
    final_reg := cg_fresh_reg(cg)
    cg_emit(cg, "  %")
    cg_emit_i64(cg, final_reg)
    cg_emit(cg, " = load i64, i64* %")
    cg_emit_i64(cg, result_alloca)
    cg_emit_newline(cg)

    final_reg
}

# Generate expression, returns register number
F cg_gen_expr(cg: i64, expr: i64, param_name_ptr: i64, param_name_len: i64) -> i64 {
    I expr == 0 { R 0 }
    kind := load_i64(expr + 0)

    # Check for match early with early return
    I kind == EXPR_MATCH() { R cg_gen_match_expr(cg, expr, param_name_ptr, param_name_len) } E { 0 }

    result: mut i64 = 0

    I kind == EXPR_INT() {
        result = cg_gen_int_expr(cg, expr)
        0
    } E I kind == EXPR_STRING() {
        # String literal: add to string constants and return pointer as i64
        str_ptr := expr_get_field0(expr)
        str_len := expr_get_field1(expr)
        str_id := cg_add_string(cg, str_ptr, str_len)

        # Emit: %N = getelementptr [len+1 x i8], [len+1 x i8]* @.str.ID, i64 0, i64 0
        gep_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, gep_reg)
        cg_emit(cg, " = getelementptr [")
        cg_emit_i64(cg, str_len + 1)
        cg_emit(cg, " x i8], [")
        cg_emit_i64(cg, str_len + 1)
        cg_emit(cg, " x i8]* @.str.")
        cg_emit_i64(cg, str_id)
        cg_emit(cg, ", i64 0, i64 0")
        cg_emit_newline(cg)
        # Convert ptr to i64 for Vais functions
        conv_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, conv_reg)
        cg_emit(cg, " = ptrtoint ptr %")
        cg_emit_i64(cg, gep_reg)
        cg_emit(cg, " to i64")
        cg_emit_newline(cg)
        result = conv_reg
        0
    } E I kind == EXPR_IDENT() {
        # Identifier: could be a local variable or a parameter
        ident_ptr := expr_get_field0(expr)
        ident_len := expr_get_field1(expr)

        # First, look up in local variables (includes params from cg_gen_function_multi)
        var_alloca := cg_find_var(cg, ident_ptr, ident_len)
        I var_alloca != 0 - 1 {
            # Found in variable table: load from alloca
            load_reg := cg_fresh_reg(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, load_reg)
            cg_emit(cg, " = load i64, i64* %")
            cg_emit_i64(cg, var_alloca)
            cg_emit_newline(cg)
            result = load_reg
            0
        } E I str_eq(ident_ptr, ident_len, param_name_ptr, param_name_len) == 1 {
            # Legacy single-param check for backward compatibility
            result = 0 - 1  # Special marker for parameter
            0
        } E {
            # Not found - assume it's a parameter (fallback)
            result = 0 - 1
            0
        }
    } E I kind == EXPR_CALL() {
        result = cg_gen_call_expr(cg, expr, param_name_ptr, param_name_len)
        0
    } E I kind == EXPR_BINARY() {
        result = cg_gen_binary_expr(cg, expr, param_name_ptr, param_name_len)
        0
    } E I kind == EXPR_IF() {
        result = cg_gen_if_expr(cg, expr, param_name_ptr, param_name_len)
        0
    } E I kind == EXPR_BLOCK() {
        result = cg_gen_block_expr(cg, expr, param_name_ptr, param_name_len)
        0
    } E I kind == EXPR_LOOP() {
        result = cg_gen_loop_expr(cg, expr, param_name_ptr, param_name_len)
        0
    } E I kind == EXPR_ASSIGN() {
        # Assignment: target = value
        target := expr_get_field0(expr)
        value := expr_get_field1(expr)

        # Target should be an identifier
        target_kind := load_i64(target + 0)
        I target_kind == EXPR_IDENT() {
            target_ptr := expr_get_field0(target)
            target_len := expr_get_field1(target)

            # Find the variable's alloca
            var_alloca := cg_find_var(cg, target_ptr, target_len)
            I var_alloca != 0 - 1 {
                # Generate value
                value_reg := cg_gen_expr(cg, value, param_name_ptr, param_name_len)

                # Store to alloca
                cg_emit(cg, "  store i64 ")
                cg_emit_operand(cg, value_reg, param_name_ptr, param_name_len)
                cg_emit(cg, ", i64* %")
                cg_emit_i64(cg, var_alloca)
                cg_emit_newline(cg)

                # Assignment returns the value
                result = value_reg
                0
            } E {
                # Variable not found - error
                result = 0
                0
            }
        } E {
            result = 0
            0
        }
    } E I kind == EXPR_UNARY() {
        # Unary expression: op operand
        op := expr_get_field0(expr)
        operand := expr_get_field1(expr)
        operand_reg := cg_gen_expr(cg, operand, param_name_ptr, param_name_len)

        I op == UNOP_NEG() {
            # Negation: 0 - operand
            neg_reg := cg_fresh_reg(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, neg_reg)
            cg_emit(cg, " = sub i64 0, ")
            cg_emit_operand(cg, operand_reg, param_name_ptr, param_name_len)
            cg_emit_newline(cg)
            result = neg_reg
            0
        } E I op == UNOP_NOT() {
            # Logical not: operand == 0 ? 1 : 0
            # Compare to 0
            cmp_reg := cg_fresh_reg(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, cmp_reg)
            cg_emit(cg, " = icmp eq i64 ")
            cg_emit_operand(cg, operand_reg, param_name_ptr, param_name_len)
            cg_emit(cg, ", 0")
            cg_emit_newline(cg)
            # Zero-extend i1 to i64
            zext_reg := cg_fresh_reg(cg)
            cg_emit(cg, "  %")
            cg_emit_i64(cg, zext_reg)
            cg_emit(cg, " = zext i1 %")
            cg_emit_i64(cg, cmp_reg)
            cg_emit(cg, " to i64")
            cg_emit_newline(cg)
            result = zext_reg
            0
        } E {
            result = operand_reg
            0
        }
    } E { 0 }

    result
}

# Generate function with multiple parameters
# params: array of param pointers, param_count: number of parameters
F cg_gen_function_multi(cg: i64, func_name_ptr: i64, func_name_len: i64,
                        params: i64, param_count: i64, body_expr: i64) -> i64 {
    # Clear variables for this function
    cg_clear_vars(cg)

    # Set first param for backward compat (used by cg_gen_expr for single param)
    I param_count > 0 {
        first_param := load_i64(params)
        cg_set_param(cg, param_get_name_ptr(first_param), param_get_name_len(first_param))
        0
    } E {
        cg_set_param(cg, 0, 0)
        0
    }

    cg_emit(cg, "define i64 @")
    cg_emit_str(cg, func_name_ptr, func_name_len)
    cg_emit(cg, "(")

    # Emit all parameters in signature
    i: mut i64 = 0
    L {
        I i >= param_count { B } E { 0 }
        I i > 0 {
            cg_emit(cg, ", ")
            0
        } E { 0 }
        param := load_i64(params + i * 8)
        cg_emit(cg, "i64 %")
        cg_emit_str(cg, param_get_name_ptr(param), param_get_name_len(param))
        i = i + 1
    }

    cg_emit(cg, ") {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)

    # Register all parameters as variables (alloca + store)
    i = 0
    L {
        I i >= param_count { B } E { 0 }
        param := load_i64(params + i * 8)
        p_name_ptr := param_get_name_ptr(param)
        p_name_len := param_get_name_len(param)

        # Allocate stack slot for parameter
        alloca_reg := cg_fresh_reg(cg)
        cg_emit(cg, "  %")
        cg_emit_i64(cg, alloca_reg)
        cg_emit(cg, " = alloca i64")
        cg_emit_newline(cg)

        # Store parameter value into slot
        cg_emit(cg, "  store i64 %")
        cg_emit_str(cg, p_name_ptr, p_name_len)
        cg_emit(cg, ", ptr %")
        cg_emit_i64(cg, alloca_reg)
        cg_emit_newline(cg)

        # Add to variable table
        cg_add_var(cg, p_name_ptr, p_name_len, alloca_reg)

        i = i + 1
    }

    # Generate body (use first param for backward compat)
    first_param_ptr: mut i64 = 0
    first_param_len: mut i64 = 0
    I param_count > 0 {
        first_p := load_i64(params)
        first_param_ptr = param_get_name_ptr(first_p)
        first_param_len = param_get_name_len(first_p)
        0
    } E { 0 }

    result_reg := cg_gen_expr(cg, body_expr, first_param_ptr, first_param_len)

    # Return
    cg_emit(cg, "  ret i64 ")
    I result_reg == 0 - 1 {
        cg_emit(cg, "0")
        0
    } E {
        cg_emit(cg, "%")
        cg_emit_i64(cg, result_reg)
        0
    }
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)
    1
}

# Legacy single-parameter version for backward compatibility
F cg_gen_function(cg: i64, func_name_ptr: i64, func_name_len: i64,
                   param_name_ptr: i64, param_name_len: i64, body_expr: i64) -> i64 {
    # Clear variables for this function
    cg_clear_vars(cg)
    cg_set_param(cg, param_name_ptr, param_name_len)

    cg_emit(cg, "define i64 @")
    cg_emit_str(cg, func_name_ptr, func_name_len)
    # Check if function has parameter
    I param_name_len > 0 {
        cg_emit(cg, "(i64 %")
        cg_emit_str(cg, param_name_ptr, param_name_len)
        cg_emit(cg, ") {")
    } E {
        cg_emit(cg, "() {")
    }
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)

    # Generate body
    result_reg := cg_gen_expr(cg, body_expr, param_name_ptr, param_name_len)

    # Return
    cg_emit(cg, "  ret i64 ")
    I result_reg == 0 - 1 {
        cg_emit(cg, "%")
        cg_emit_str(cg, param_name_ptr, param_name_len)
        0
    } E {
        cg_emit(cg, "%")
        cg_emit_i64(cg, result_reg)
        0
    }
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    cg_emit_newline(cg)
    1
}

F cg_gen_main_that_calls(cg: i64, func_name_ptr: i64, func_name_len: i64) -> i64 {
    cg_emit(cg, "declare i32 @printf(i8*, ...)")
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    # Format string: "Result: %ld\n\0" = 13 bytes
    cg_emit(cg, "@.str.fmt = private constant [13 x i8] c")
    cg_emit_quote(cg)
    cg_emit(cg, "Result: %ld")
    sb := cg_get_sb(cg)
    sb_append_byte(sb, 92)  # backslash
    sb_append_byte(sb, 48)  # 0
    sb_append_byte(sb, 65)  # A
    sb_append_byte(sb, 92)  # backslash
    sb_append_byte(sb, 48)  # 0
    sb_append_byte(sb, 48)  # 0
    cg_emit_quote(cg)
    cg_emit_newline(cg)
    cg_emit_newline(cg)

    cg_emit(cg, "define i64 @main() {")
    cg_emit_newline(cg)
    cg_emit(cg, "entry:")
    cg_emit_newline(cg)
    cg_emit(cg, "  %result = call i64 @")
    cg_emit_str(cg, func_name_ptr, func_name_len)
    cg_emit(cg, "(i64 10)")
    cg_emit_newline(cg)
    cg_emit(cg, "  %fmt = getelementptr [13 x i8], [13 x i8]* @.str.fmt, i64 0, i64 0")
    cg_emit_newline(cg)
    cg_emit(cg, "  call i32 (i8*, ...) @printf(i8* %fmt, i64 %result)")
    cg_emit_newline(cg)
    cg_emit(cg, "  ret i64 0")
    cg_emit_newline(cg)
    cg_emit(cg, "}")
    cg_emit_newline(cg)
    1
}

# Finalize code generation: merge strings into main buffer after header
F cg_finalize(cg: i64) -> i64 {
    strings_sb := cg_get_strings_sb(cg)
    strings_len := sb_get_len(strings_sb)

    I strings_len > 0 {
        # We need to insert strings after header and before functions
        # For now, append strings at current position
        # This works because strings are declared before they're referenced
        main_sb := cg_get_sb(cg)

        # Get header position (find first "define")
        main_data := sb_get_data(main_sb)
        main_len := sb_get_len(main_sb)

        # Find where "define" starts (after header)
        define_pos: mut i64 = 0
        i: mut i64 = 0
        L {
            I i >= main_len - 6 { B } E { 0 }
            I load_byte(main_data + i) == 100 {  # 'd'
                I load_byte(main_data + i + 1) == 101 {  # 'e'
                    I load_byte(main_data + i + 2) == 102 {  # 'f'
                        define_pos = i
                        B
                    } E { 0 }
                } E { 0 }
            } E { 0 }
            i = i + 1
        }

        I define_pos > 0 {
            # Create new buffer: header + strings + functions
            strings_data := sb_get_data(strings_sb)
            new_sb := sb_new(main_len + strings_len + 256)

            # Copy header (up to define_pos)
            j: mut i64 = 0
            L {
                I j >= define_pos { B } E { 0 }
                sb_append_byte(new_sb, load_byte(main_data + j))
                j = j + 1
            }

            # Add string constants
            sb_append_byte(new_sb, 10)  # extra newline
            j = 0
            L {
                I j >= strings_len { B } E { 0 }
                sb_append_byte(new_sb, load_byte(strings_data + j))
                j = j + 1
            }
            sb_append_byte(new_sb, 10)  # extra newline

            # Copy rest of code (functions)
            j = define_pos
            L {
                I j >= main_len { B } E { 0 }
                sb_append_byte(new_sb, load_byte(main_data + j))
                j = j + 1
            }

            # Replace main sb with new sb
            sb_free(main_sb)
            store_i64(cg + 0, new_sb)
            0
        } E { 0 }
    } E { 0 }
    1
}

F cg_get_output(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_get_data(sb)
}

F cg_get_output_len(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_get_len(sb)
}

F cg_free(cg: i64) -> i64 {
    sb := cg_get_sb(cg)
    sb_free(sb)
    strings_sb := cg_get_strings_sb(cg)
    sb_free(strings_sb)
    vars := cg_get_vars(cg)
    free(vars)
    strings := cg_get_strings(cg)
    free(strings)
    free(cg)
    1
}

# ============================================================================
# Print helpers
# ============================================================================

F print_i64(val: i64) -> i64 {
    I val == 0 {
        putchar(48)
        0
    } E I val < 0 {
        putchar(45)
        print_i64(0 - val)
    } E {
        I val >= 10 {
            print_i64(val / 10)
            0
        } E { 0 }
        putchar(48 + (val % 10))
        0
    }
}

F print_str(ptr: i64, len: i64) -> i64 {
    i: mut i64 = 0
    L {
        I i >= len { B } E { 0 }
        putchar(load_byte(ptr + i))
        i = i + 1
    }
    1
}

# Read file into memory (length stored at ptr-8)
F read_file(path: str) -> i64 {
    fp := fopen(path, "rb")
    I fp == 0 { 0 }
    E {
        fseek(fp, 0, 2)  # SEEK_END
        size := ftell(fp)
        fseek(fp, 0, 0)  # SEEK_SET

        buf := malloc(size + 9)
        I buf == 0 {
            fclose(fp)
            0
        } E {
            bytes_read := fread(buf + 8, 1, size, fp)
            store_byte(buf + 8 + bytes_read, 0)
            store_i64(buf, bytes_read)
            fclose(fp)
            buf + 8
        }
    }
}

# ============================================================================
# Debug helpers
# ============================================================================

F debug_print_expr(expr: i64, depth: i64) -> i64 {
    I expr == 0 {
        puts("    NULL")
        putchar(10)
        R 0
    }
    kind := expr_get_kind(expr)
    # Indent
    i: mut i64 = 0
    L {
        I i >= depth { B } E { 0 }
        puts("  ")
        i = i + 1
    }
    I kind == EXPR_INT() {
        puts("INT: ")
        print_i64(expr_get_field0(expr))
        putchar(10)
        0
    } E I kind == EXPR_IDENT() {
        puts("IDENT: ")
        print_str(expr_get_field0(expr), expr_get_field1(expr))
        putchar(10)
        0
    } E I kind == EXPR_CALL() {
        puts("CALL: ")
        print_str(expr_get_field0(expr), expr_get_field1(expr))
        puts(" (")
        print_i64(expr_get_field3(expr))
        puts(" args)")
        putchar(10)
        # Print arguments
        args := expr_get_field2(expr)
        arg_count := expr_get_field3(expr)
        j: mut i64 = 0
        L {
            I j >= arg_count { B } E { 0 }
            arg := load_i64(args + j * 8)
            debug_print_expr(arg, depth + 1)
            j = j + 1
        }
        0
    } E I kind == EXPR_BINARY() {
        puts("BINARY op=")
        print_i64(expr_get_field0(expr))
        putchar(10)
        debug_print_expr(expr_get_field1(expr), depth + 1)
        debug_print_expr(expr_get_field2(expr), depth + 1)
        0
    } E {
        puts("EXPR kind=")
        print_i64(kind)
        putchar(10)
        0
    }
}

# ============================================================================
# Multi-Function Code Generation Helper
# ============================================================================

# Check if a function name is "main" (4 bytes: m=109, a=97, i=105, n=110)
F is_main_function(name_ptr: i64, name_len: i64) -> i64 {
    I name_len != 4 { R 0 }
    I load_byte(name_ptr) != 109 { R 0 }      # m
    I load_byte(name_ptr + 1) != 97 { R 0 }   # a
    I load_byte(name_ptr + 2) != 105 { R 0 }  # i
    I load_byte(name_ptr + 3) != 110 { R 0 }  # n
    1
}

# Generate code for a single function item
F cg_gen_function_item(cg: i64, item: i64) -> i64 {
    I item_get_kind(item) != ITEM_FUNCTION() { R 0 }

    # Reset register counter for each function
    cg_reset_regs(cg)

    name_ptr := item_get_name_ptr(item)
    name_len := item_get_name_len(item)
    params := item_get_data0(item)
    param_count := item_get_data1(item)
    body := item_get_data3(item)

    I body == 0 { R 0 }

    # Check if this is the main function (no params, returns i64)
    I is_main_function(name_ptr, name_len) == 1 && param_count == 0 {
        # Generate main with special handling (no params)
        cg_emit(cg, "define i64 @main() {\n")
        cg_emit(cg, "entry:\n")
        result_reg := cg_gen_expr(cg, body, 0, 0)
        cg_emit(cg, "  ret i64 ")
        I result_reg == 0 - 1 {
            cg_emit(cg, "0")
            0
        } E {
            cg_emit(cg, "%")
            cg_emit_i64(cg, result_reg)
            0
        }
        cg_emit_newline(cg)
        cg_emit(cg, "}\n\n")
        R 1
    }

    # Generate regular function with all parameters
    cg_gen_function_multi(cg, name_ptr, name_len, params, param_count, body)
}

# Generate code for all function items in the parser
# Generate all functions from items array (items_ptr, count)
F cg_gen_all_functions_from_items(cg: i64, items: i64, count: i64) -> i64 {
    has_main: mut i64 = 0
    first_func_name_ptr: mut i64 = 0
    first_func_name_len: mut i64 = 0

    # First pass: generate all functions and check for main
    i: mut i64 = 0
    L {
        I i >= count { B } E { 0 }
        item := load_i64(items + i * 8)
        kind := item_get_kind(item)

        I kind == ITEM_FUNCTION() {
            name_ptr := item_get_name_ptr(item)
            name_len := item_get_name_len(item)
            params := item_get_data0(item)
            param_count := item_get_data1(item)

            # Remember first function for fallback main generation
            I first_func_name_ptr == 0 && param_count > 0 {
                first_func_name_ptr = name_ptr
                first_func_name_len = name_len
                0
            } E { 0 }

            # Check if this is main (with any number of params)
            I is_main_function(name_ptr, name_len) == 1 {
                has_main = 1
                0
            } E { 0 }

            cg_gen_function_item(cg, item)
            0
        } E { 0 }

        i = i + 1
    }

    # If no main function, generate one that calls the first function
    I has_main == 0 && first_func_name_ptr != 0 {
        cg_gen_main_that_calls(cg, first_func_name_ptr, first_func_name_len)
        0
    } E { 0 }

    count
}

# Wrapper for backward compatibility
F cg_gen_all_functions(cg: i64, parser: i64) -> i64 {
    items := parser_get_items(parser)
    count := parser_get_item_count(parser)
    cg_gen_all_functions_from_items(cg, items, count)
}

# ============================================================================
# Import System
# ============================================================================

# Loaded modules tracker (simple array, max 64 modules)
# Layout: count(8) + paths[64 * 16] (ptr+len each)
F loaded_modules_new() -> i64 {
    lm := malloc(8 + 64 * 16)
    store_i64(lm, 0)  # count = 0
    lm
}

F loaded_modules_count(lm: i64) -> i64 = load_i64(lm)

F loaded_modules_contains(lm: i64, path_ptr: i64, path_len: i64) -> i64 {
    count := loaded_modules_count(lm)
    i: mut i64 = 0
    L {
        I i >= count { B } E { 0 }
        idx := 8 + i * 16
        ptr := load_i64(lm + idx)
        len := load_i64(lm + idx + 8)
        I len == path_len {
            I str_cmp(ptr, path_ptr, len) == 0 {
                R 1
            } E { 0 }
        } E { 0 }
        i = i + 1
    }
    0
}

F loaded_modules_add(lm: i64, path_ptr: i64, path_len: i64) -> i64 {
    count := loaded_modules_count(lm)
    I count >= 64 { R 0 }  # Max modules reached
    idx := 8 + count * 16
    store_i64(lm + idx, path_ptr)
    store_i64(lm + idx + 8, path_len)
    store_i64(lm, count + 1)
    1
}

# String comparison (byte-by-byte compare for i64 pointers)
F str_cmp(a: i64, b: i64, len: i64) -> i64 {
    i: mut i64 = 0
    L {
        I i >= len { B } E { 0 }
        ca := load_byte(a + i)
        cb := load_byte(b + i)
        I ca != cb {
            R ca - cb
        } E { 0 }
        i = i + 1
    }
    0
}

# Resolve import path to file path
# Input: "std/io" or "utils" (relative to base_dir)
# Output: allocated string with full path
F resolve_import_path(base_dir: i64, base_len: i64, mod_path: i64, mod_len: i64) -> i64 {
    # Build: base_dir + "/" + mod_path + ".vais"
    sb := sb_new(512)

    # Add base directory
    I base_len > 0 {
        sb_append_bytes(sb, base_dir, base_len)
        sb_append_byte(sb, 47)  # /
        0
    } E { 0 }

    # Add module path
    sb_append_bytes(sb, mod_path, mod_len)

    # Add .vais extension
    sb_append_cstr(sb, ".vais")

    # Null terminate
    sb_append_byte(sb, 0)

    ptr := sb_get_data(sb)
    free(sb)
    ptr
}

# Get directory from file path
F get_directory(path: i64, path_len: i64) -> i64 {
    # Find last /
    last_slash: mut i64 = 0 - 1
    i: mut i64 = 0
    L {
        I i >= path_len { B } E { 0 }
        I load_byte(path + i) == 47 {  # /
            last_slash = i
            0
        } E { 0 }
        i = i + 1
    }

    I last_slash < 0 {
        # No directory, return empty
        result := malloc(2)
        store_byte(result, 46)  # .
        store_byte(result + 1, 0)
        result
    } E {
        # Copy directory part
        result := malloc(last_slash + 2)
        memcpy(result, path, last_slash)
        store_byte(result + last_slash, 0)
        result
    }
}

# Merged items container
# Layout: items[](8 each) + count(8) + capacity(8)
F merged_items_new(cap: i64) -> i64 {
    mi := malloc(cap * 8 + 16)
    store_i64(mi + cap * 8, 0)      # count = 0
    store_i64(mi + cap * 8 + 8, cap)  # capacity
    mi
}

F merged_items_count(mi: i64) -> i64 {
    cap := load_i64(mi + 8)  # Wrong offset, need to find capacity first
    # Actually we need a different layout
    0
}

# Simpler approach: use items array directly
# All items array: ptr(8) + count(8) + cap(8)
F all_items_new(cap: i64) -> i64 {
    ai := malloc(24)
    store_i64(ai, malloc(cap * 8))  # items array
    store_i64(ai + 8, 0)             # count
    store_i64(ai + 16, cap)          # capacity
    ai
}

F all_items_get_ptr(ai: i64) -> i64 = load_i64(ai)
F all_items_get_count(ai: i64) -> i64 = load_i64(ai + 8)
F all_items_get_cap(ai: i64) -> i64 = load_i64(ai + 16)

F all_items_add(ai: i64, item: i64) -> i64 {
    count := all_items_get_count(ai)
    cap := all_items_get_cap(ai)

    I count >= cap {
        # Grow
        new_cap := cap * 2
        old_ptr := all_items_get_ptr(ai)
        new_ptr := malloc(new_cap * 8)
        memcpy(new_ptr, old_ptr, count * 8)
        free(old_ptr)
        store_i64(ai, new_ptr)
        store_i64(ai + 16, new_cap)
        0
    } E { 0 }

    ptr := all_items_get_ptr(ai)
    store_i64(ptr + count * 8, item)
    store_i64(ai + 8, count + 1)
    1
}

# Load a module with import resolution
# Returns number of items added to all_items
F load_module_with_imports(
    file_path: i64,
    all_items: i64,
    loaded: i64
) -> i64 {
    # Get path length
    path_len := strlen_ptr(file_path)

    # Check if already loaded
    I loaded_modules_contains(loaded, file_path, path_len) == 1 {
        R 0  # Already loaded, skip
    }

    # Mark as loaded
    loaded_modules_add(loaded, file_path, path_len)

    # Read file
    source_data := read_file_ptr(file_path)
    I source_data == 0 {
        puts("[Import] Cannot read: ")
        print_str(file_path, path_len)
        putchar(10)
        R 0
    }

    source_len := load_i64(source_data - 8)

    # Get base directory for relative imports
    base_dir := get_directory(file_path, path_len)
    base_len := strlen_ptr(base_dir)

    # Tokenize
    lex := lexer_new(source_data, source_len)
    tokens := malloc(32768 * 48)
    token_count := lexer_tokenize(lex, tokens)

    # Parse
    parser := parser_new(tokens, token_count)
    parser_parse_module(parser)

    item_count := parser_get_item_count(parser)
    items := parser_get_items(parser)

    # Process items
    added: mut i64 = 0
    i: mut i64 = 0
    L {
        I i >= item_count { B } E { 0 }
        item := load_i64(items + i * 8)
        kind := item_get_kind(item)

        I kind == ITEM_USE() {
            # Recursively load imported module
            mod_path := item_get_name_ptr(item)
            mod_len := item_get_name_len(item)

            resolved := resolve_import_path(base_dir, base_len, mod_path, mod_len)
            load_module_with_imports(resolved, all_items, loaded)
            # Note: resolved is leaked, but ok for now
            0
        } E {
            # Add non-use items
            all_items_add(all_items, item)
            added = added + 1
            0
        }

        i = i + 1
    }

    # Cleanup (but keep items as they're referenced by all_items)
    free(tokens)
    lexer_free(lex)
    # Don't free parser as items are still referenced

    added
}

# strlen for i64 pointer (null-terminated)
F strlen_ptr(s: i64) -> i64 {
    len: mut i64 = 0
    L {
        I load_byte(s + len) == 0 { B } E { 0 }
        len = len + 1
    }
    len
}

# read_file variant that takes i64 pointer instead of str
F read_file_ptr(path: i64) -> i64 {
    # fopen_ptr accepts i64 pointer as path
    fp := fopen_ptr(path, "rb")
    I fp == 0 { 0 }
    E {
        fseek(fp, 0, 2)  # SEEK_END
        size := ftell(fp)
        fseek(fp, 0, 0)  # SEEK_SET

        buf := malloc(size + 9)
        I buf == 0 {
            fclose(fp)
            0
        } E {
            data_ptr := buf + 8
            bytes_read := fread(data_ptr, 1, size, fp)
            store_byte(data_ptr + bytes_read, 0)
            store_i64(buf, bytes_read)
            fclose(fp)
            data_ptr
        }
    }
}

# ============================================================================
# Main Entry Point
# ============================================================================

F main(argc: i64, argv: i64) -> i64 {
    puts("=======================================\n")
    puts("  Vais Self-Hosting Compiler (Stage 1)\n")
    puts("  Version: 0.5.0 (CLI + Import Support)\n")
    puts("=======================================\n\n")

    # Check for input file argument
    I argc < 2 {
        puts("Usage: vaisc-stage1 <input.vais>\n")
        R 1
    }

    # Get path from argv[1]
    path_ptr := load_i64(argv + 8)

    puts("[INFO] Compiling: ")
    i: mut i64 = 0
    L {
        c := load_byte(path_ptr + i)
        I c == 0 { B } E { 0 }
        putchar(c)
        i = i + 1
    }
    putchar(10)

    # Initialize import system
    loaded := loaded_modules_new()
    all_items := all_items_new(1024)

    # Load main module with imports
    puts("[1] Loading modules with imports...\n")
    load_module_with_imports(path_ptr, all_items, loaded)

    item_count := all_items_get_count(all_items)
    puts("    Total items loaded: ")
    print_i64(item_count)
    putchar(10)

    I item_count == 0 {
        puts("    Parse: FAILED (no items found)\n")
        R 1
    }

    # Print loaded items
    items := all_items_get_ptr(all_items)
    func_count: mut i64 = 0
    struct_count: mut i64 = 0
    i: mut i64 = 0
    L {
        I i >= item_count { B } E { 0 }
        item := load_i64(items + i * 8)
        kind := item_get_kind(item)
        I kind == ITEM_FUNCTION() {
            puts("    Function: ")
            print_str(item_get_name_ptr(item), item_get_name_len(item))
            putchar(10)
            func_count = func_count + 1
            0
        } E I kind == ITEM_STRUCT() {
            puts("    Struct: ")
            print_str(item_get_name_ptr(item), item_get_name_len(item))
            putchar(10)
            struct_count = struct_count + 1
            0
        } E I kind == ITEM_IMPL() {
            puts("    Impl: ")
            print_str(item_get_name_ptr(item), item_get_name_len(item))
            putchar(10)
            0
        } E { 0 }
        i = i + 1
    }
    puts("    Functions: ")
    print_i64(func_count)
    puts(", Structs: ")
    print_i64(struct_count)
    putchar(10)

    # Step 2: Codegen
    puts("[2] Codegen...\n")
    cg := cg_new()
    cg_emit_header(cg)
    cg_gen_all_functions_from_items(cg, items, item_count)
    cg_finalize(cg)

    # Print generated IR
    puts("\n--- Generated LLVM IR ---\n")
    ir_ptr := cg_get_output(cg)
    ir_len := cg_get_output_len(cg)
    print_str(ir_ptr, ir_len)
    puts("--- End of LLVM IR ---\n")

    # Write to file
    fp := fopen("selfhost/main_output.ll", "wb")
    I fp != 0 {
        fwrite(ir_ptr, 1, ir_len, fp)
        fclose(fp)
        puts("\n[OK] Written to selfhost/main_output.ll\n")
        0
    } E {
        puts("\n[ERROR] Could not write output file\n")
        0
    }

    # Cleanup
    cg_free(cg)
    # Note: path_ptr is from argv, don't free it

    puts("[OK] Compilation successful!\n")
    0
}
