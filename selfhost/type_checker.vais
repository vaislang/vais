# Vais Self-Hosting Compiler - Type Checker Module
# Static type checking with basic inference for the Vais language
# Note: This is a simplified type checker for bootstrapping purposes

# ============================================================================
# Type Kind Constants
# ============================================================================

F TY_I8() -> i64 = 1
F TY_I16() -> i64 = 2
F TY_I32() -> i64 = 3
F TY_I64() -> i64 = 4
F TY_I128() -> i64 = 5
F TY_U8() -> i64 = 6
F TY_U16() -> i64 = 7
F TY_U32() -> i64 = 8
F TY_U64() -> i64 = 9
F TY_U128() -> i64 = 10
F TY_F32() -> i64 = 11
F TY_F64() -> i64 = 12
F TY_BOOL() -> i64 = 13
F TY_STR() -> i64 = 14
F TY_UNIT() -> i64 = 15
F TY_ARRAY() -> i64 = 16
F TY_MAP() -> i64 = 17
F TY_TUPLE() -> i64 = 18
F TY_OPTIONAL() -> i64 = 19
F TY_RESULT() -> i64 = 20
F TY_POINTER() -> i64 = 21
F TY_REF() -> i64 = 22
F TY_REF_MUT() -> i64 = 23
F TY_FN() -> i64 = 24
F TY_NAMED() -> i64 = 25
F TY_GENERIC() -> i64 = 26
F TY_VAR() -> i64 = 27
F TY_UNKNOWN() -> i64 = 28
F TY_NEVER() -> i64 = 29
F TY_DYN_TRAIT() -> i64 = 30   # dyn Trait - trait object type
F TY_ASSOC() -> i64 = 31       # Associated type projection: Trait::AssocType

# ============================================================================
# CheckMode Constants for Bidirectional Type Checking
# ============================================================================

F MODE_INFER() -> i64 = 0
F MODE_CHECK() -> i64 = 1

# ============================================================================
# Error Kind Constants
# ============================================================================

F ERR_MISMATCH() -> i64 = 1
F ERR_UNDEFINED_VAR() -> i64 = 2
F ERR_UNDEFINED_TYPE() -> i64 = 3
F ERR_UNDEFINED_FUNC() -> i64 = 4
F ERR_NOT_CALLABLE() -> i64 = 5
F ERR_ARG_COUNT() -> i64 = 6
F ERR_CANNOT_INFER() -> i64 = 7
F ERR_DUPLICATE() -> i64 = 8
F ERR_IMMUTABLE_ASSIGN() -> i64 = 9

# ============================================================================
# Resolved Type Representation
# Uses flattened structure with raw memory
# ============================================================================

S ResolvedType {
    kind: i64,
    # For compound types:
    # ARRAY/OPTIONAL/RESULT/POINTER/REF/REF_MUT: field0 = inner_type_ptr
    # MAP: field0 = key_type_ptr, field1 = value_type_ptr
    # TUPLE: field0 = types_ptr, field1 = types_len
    # FN: field0 = params_ptr, field1 = params_len, field2 = ret_type_ptr
    # NAMED: field0 = name_idx, field1 = generics_ptr, field2 = generics_len
    # GENERIC: field0 = name_idx
    # VAR: field0 = var_id
    field0: i64,
    field1: i64,
    field2: i64
}

X ResolvedType {
    F size() -> i64 = 32

    F i8_type() -> ResolvedType = ResolvedType { kind: TY_I8(), field0: 0, field1: 0, field2: 0 }
    F i16_type() -> ResolvedType = ResolvedType { kind: TY_I16(), field0: 0, field1: 0, field2: 0 }
    F i32_type() -> ResolvedType = ResolvedType { kind: TY_I32(), field0: 0, field1: 0, field2: 0 }
    F i64_type() -> ResolvedType = ResolvedType { kind: TY_I64(), field0: 0, field1: 0, field2: 0 }
    F i128_type() -> ResolvedType = ResolvedType { kind: TY_I128(), field0: 0, field1: 0, field2: 0 }
    F u8_type() -> ResolvedType = ResolvedType { kind: TY_U8(), field0: 0, field1: 0, field2: 0 }
    F u16_type() -> ResolvedType = ResolvedType { kind: TY_U16(), field0: 0, field1: 0, field2: 0 }
    F u32_type() -> ResolvedType = ResolvedType { kind: TY_U32(), field0: 0, field1: 0, field2: 0 }
    F u64_type() -> ResolvedType = ResolvedType { kind: TY_U64(), field0: 0, field1: 0, field2: 0 }
    F u128_type() -> ResolvedType = ResolvedType { kind: TY_U128(), field0: 0, field1: 0, field2: 0 }
    F f32_type() -> ResolvedType = ResolvedType { kind: TY_F32(), field0: 0, field1: 0, field2: 0 }
    F f64_type() -> ResolvedType = ResolvedType { kind: TY_F64(), field0: 0, field1: 0, field2: 0 }
    F bool_type() -> ResolvedType = ResolvedType { kind: TY_BOOL(), field0: 0, field1: 0, field2: 0 }
    F str_type() -> ResolvedType = ResolvedType { kind: TY_STR(), field0: 0, field1: 0, field2: 0 }
    F unit_type() -> ResolvedType = ResolvedType { kind: TY_UNIT(), field0: 0, field1: 0, field2: 0 }
    F unknown_type() -> ResolvedType = ResolvedType { kind: TY_UNKNOWN(), field0: 0, field1: 0, field2: 0 }
    F never_type() -> ResolvedType = ResolvedType { kind: TY_NEVER(), field0: 0, field1: 0, field2: 0 }

    F array_type(inner_ptr: i64) -> ResolvedType = ResolvedType {
        kind: TY_ARRAY(), field0: inner_ptr, field1: 0, field2: 0
    }

    F optional_type(inner_ptr: i64) -> ResolvedType = ResolvedType {
        kind: TY_OPTIONAL(), field0: inner_ptr, field1: 0, field2: 0
    }

    F result_type(inner_ptr: i64) -> ResolvedType = ResolvedType {
        kind: TY_RESULT(), field0: inner_ptr, field1: 0, field2: 0
    }

    F pointer_type(inner_ptr: i64) -> ResolvedType = ResolvedType {
        kind: TY_POINTER(), field0: inner_ptr, field1: 0, field2: 0
    }

    F ref_type(inner_ptr: i64) -> ResolvedType = ResolvedType {
        kind: TY_REF(), field0: inner_ptr, field1: 0, field2: 0
    }

    F ref_mut_type(inner_ptr: i64) -> ResolvedType = ResolvedType {
        kind: TY_REF_MUT(), field0: inner_ptr, field1: 0, field2: 0
    }

    F map_type(key_ptr: i64, value_ptr: i64) -> ResolvedType = ResolvedType {
        kind: TY_MAP(), field0: key_ptr, field1: value_ptr, field2: 0
    }

    F tuple_type(types_ptr: i64, types_len: i64) -> ResolvedType = ResolvedType {
        kind: TY_TUPLE(), field0: types_ptr, field1: types_len, field2: 0
    }

    F fn_type(params_ptr: i64, params_len: i64, ret_ptr: i64) -> ResolvedType = ResolvedType {
        kind: TY_FN(), field0: params_ptr, field1: params_len, field2: ret_ptr
    }

    F named_type(name_idx: i64, generics_ptr: i64, generics_len: i64) -> ResolvedType = ResolvedType {
        kind: TY_NAMED(), field0: name_idx, field1: generics_ptr, field2: generics_len
    }

    F generic_type(name_idx: i64) -> ResolvedType = ResolvedType {
        kind: TY_GENERIC(), field0: name_idx, field1: 0, field2: 0
    }

    F var_type(var_id: i64) -> ResolvedType = ResolvedType {
        kind: TY_VAR(), field0: var_id, field1: 0, field2: 0
    }

    F is_numeric(&self) -> i64 {
        I self.kind == TY_I8() || self.kind == TY_I16() || self.kind == TY_I32() ||
           self.kind == TY_I64() || self.kind == TY_I128() ||
           self.kind == TY_U8() || self.kind == TY_U16() || self.kind == TY_U32() ||
           self.kind == TY_U64() || self.kind == TY_U128() ||
           self.kind == TY_F32() || self.kind == TY_F64() ||
           self.kind == TY_GENERIC() || self.kind == TY_VAR() || self.kind == TY_UNKNOWN() {
            1
        } E { 0 }
    }

    F is_integer(&self) -> i64 {
        I self.kind == TY_I8() || self.kind == TY_I16() || self.kind == TY_I32() ||
           self.kind == TY_I64() || self.kind == TY_I128() ||
           self.kind == TY_U8() || self.kind == TY_U16() || self.kind == TY_U32() ||
           self.kind == TY_U64() || self.kind == TY_U128() {
            1
        } E { 0 }
    }

    F is_float(&self) -> i64 {
        I self.kind == TY_F32() || self.kind == TY_F64() { 1 } E { 0 }
    }

    F equals(&self, other: i64) -> i64 {
        other_ptr := other
        other_kind := load_i64(other_ptr)
        I self.kind != other_kind { 0 }
        E I self.kind == TY_ARRAY() || self.kind == TY_OPTIONAL() ||
              self.kind == TY_RESULT() || self.kind == TY_POINTER() ||
              self.kind == TY_REF() || self.kind == TY_REF_MUT() {
            # Compare inner types
            other_field0 := load_i64(other_ptr + 8)
            inner_self := self.field0
            I inner_self == 0 && other_field0 == 0 { 1 }
            E I inner_self == 0 || other_field0 == 0 { 0 }
            E {
                # Recursive comparison
                inner_ty_ptr := inner_self
                inner_kind := load_i64(inner_ty_ptr)
                other_inner_kind := load_i64(other_field0)
                I inner_kind == other_inner_kind { 1 } E { 0 }
            }
        }
        E I self.kind == TY_NAMED() {
            other_name := load_i64(other_ptr + 8)
            I self.field0 == other_name { 1 } E { 0 }
        }
        E I self.kind == TY_VAR() {
            other_var := load_i64(other_ptr + 8)
            I self.field0 == other_var { 1 } E { 0 }
        }
        E { 1 }  # Primitives match by kind
    }
}

# ============================================================================
# Type Error
# ============================================================================

S TypeError {
    kind: i64,
    span_start: i64,
    span_end: i64,
    expected_idx: i64,  # String index for expected type
    found_idx: i64,     # String index for found type
    name_idx: i64       # Name index for undefined errors
}

X TypeError {
    F size() -> i64 = 48

    F mismatch(expected: i64, found: i64, start: i64, end: i64) -> TypeError = TypeError {
        kind: ERR_MISMATCH(), span_start: start, span_end: end,
        expected_idx: expected, found_idx: found, name_idx: 0
    }

    F undefined_var(name: i64, start: i64, end: i64) -> TypeError = TypeError {
        kind: ERR_UNDEFINED_VAR(), span_start: start, span_end: end,
        expected_idx: 0, found_idx: 0, name_idx: name
    }

    F undefined_type(name: i64, start: i64, end: i64) -> TypeError = TypeError {
        kind: ERR_UNDEFINED_TYPE(), span_start: start, span_end: end,
        expected_idx: 0, found_idx: 0, name_idx: name
    }

    F undefined_func(name: i64, start: i64, end: i64) -> TypeError = TypeError {
        kind: ERR_UNDEFINED_FUNC(), span_start: start, span_end: end,
        expected_idx: 0, found_idx: 0, name_idx: name
    }

    F not_callable(type_idx: i64, start: i64, end: i64) -> TypeError = TypeError {
        kind: ERR_NOT_CALLABLE(), span_start: start, span_end: end,
        expected_idx: 0, found_idx: type_idx, name_idx: 0
    }

    F arg_count(expected: i64, got: i64, start: i64, end: i64) -> TypeError = TypeError {
        kind: ERR_ARG_COUNT(), span_start: start, span_end: end,
        expected_idx: expected, found_idx: got, name_idx: 0
    }

    F immutable_assign(name: i64, start: i64, end: i64) -> TypeError = TypeError {
        kind: ERR_IMMUTABLE_ASSIGN(), span_start: start, span_end: end,
        expected_idx: 0, found_idx: 0, name_idx: name
    }
}

# ============================================================================
# Variable Info (for scope tracking)
# ============================================================================

S VarInfo {
    type_ptr: i64,  # Pointer to ResolvedType
    is_mut: i64,
    name_idx: i64
}

X VarInfo {
    F size() -> i64 = 24

    F new(type_ptr: i64, is_mut: i64, name_idx: i64) -> VarInfo = VarInfo {
        type_ptr: type_ptr, is_mut: is_mut, name_idx: name_idx
    }
}

# ============================================================================
# Function Signature
# ============================================================================

S FunctionSig {
    name_idx: i64,
    generics_ptr: i64,
    generics_len: i64,
    params_ptr: i64,      # Array of (name_idx, type_ptr, is_mut) triples
    params_len: i64,
    ret_type_ptr: i64,
    is_async: i64
}

X FunctionSig {
    F size() -> i64 = 56

    F new(name_idx: i64) -> FunctionSig = FunctionSig {
        name_idx: name_idx,
        generics_ptr: 0, generics_len: 0,
        params_ptr: 0, params_len: 0,
        ret_type_ptr: 0,
        is_async: 0
    }
}

# ============================================================================
# Struct Definition (for type environment)
# ============================================================================

S StructDefInfo {
    name_idx: i64,
    generics_ptr: i64,
    generics_len: i64,
    fields_ptr: i64,      # Array of (name_idx, type_ptr) pairs
    fields_len: i64,
    methods_ptr: i64,     # Array of FunctionSig pointers
    methods_len: i64
}

X StructDefInfo {
    F size() -> i64 = 56

    F new(name_idx: i64) -> StructDefInfo = StructDefInfo {
        name_idx: name_idx,
        generics_ptr: 0, generics_len: 0,
        fields_ptr: 0, fields_len: 0,
        methods_ptr: 0, methods_len: 0
    }
}

# ============================================================================
# Enum Definition
# ============================================================================

S EnumDefInfo {
    name_idx: i64,
    generics_ptr: i64,
    generics_len: i64,
    variants_ptr: i64,    # Array of variant info
    variants_len: i64
}

X EnumDefInfo {
    F size() -> i64 = 40

    F new(name_idx: i64) -> EnumDefInfo = EnumDefInfo {
        name_idx: name_idx,
        generics_ptr: 0, generics_len: 0,
        variants_ptr: 0, variants_len: 0
    }
}

# ============================================================================
# Trait Definition (for type environment)
# ============================================================================

S TraitDefInfo {
    name_idx: i64,
    generics_ptr: i64,       # Array of GenericParam pointers
    generics_len: i64,
    super_traits_ptr: i64,   # Array of name_idx for super traits
    super_traits_len: i64,
    methods_ptr: i64,        # Array of FunctionSig pointers
    methods_len: i64
}

X TraitDefInfo {
    F size() -> i64 = 56

    F new(name_idx: i64) -> TraitDefInfo = TraitDefInfo {
        name_idx: name_idx,
        generics_ptr: 0, generics_len: 0,
        super_traits_ptr: 0, super_traits_len: 0,
        methods_ptr: 0, methods_len: 0
    }
}

# ============================================================================
# Trait Implementation Info (for tracking impl Trait for Type)
# ============================================================================

S TraitImplInfo {
    target_type_idx: i64,    # name_idx of the implementing type
    trait_name_idx: i64,     # name_idx of the implemented trait
    methods_ptr: i64,        # Array of FunctionSig pointers
    methods_len: i64
}

X TraitImplInfo {
    F size() -> i64 = 32

    F new(target_type_idx: i64, trait_name_idx: i64) -> TraitImplInfo = TraitImplInfo {
        target_type_idx: target_type_idx,
        trait_name_idx: trait_name_idx,
        methods_ptr: 0, methods_len: 0
    }
}

# ============================================================================
# Scope - Variable environment
# ============================================================================

S Scope {
    vars_ptr: i64,      # HashMap-like: array of VarInfo
    vars_len: i64,
    vars_cap: i64
}

X Scope {
    F size() -> i64 = 24

    F new(cap: i64) -> Scope {
        ptr := malloc(cap * VarInfo.size())
        Scope { vars_ptr: ptr, vars_len: 0, vars_cap: cap }
    }

    F add_var(&self, name_idx: i64, type_ptr: i64, is_mut: i64) -> i64 {
        I self.vars_len >= self.vars_cap {
            new_cap := self.vars_cap * 2
            new_ptr := malloc(new_cap * VarInfo.size())
            memcpy(new_ptr, self.vars_ptr, self.vars_len * VarInfo.size())
            free(self.vars_ptr)
            self.vars_ptr = new_ptr
            self.vars_cap = new_cap
            0
        } E { 0 }

        ptr := self.vars_ptr + self.vars_len * VarInfo.size()
        store_i64(ptr, type_ptr)
        store_i64(ptr + 8, is_mut)
        store_i64(ptr + 16, name_idx)
        self.vars_len = self.vars_len + 1
        self.vars_len - 1
    }

    F find_var(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.vars_len { B }
            ptr := self.vars_ptr + i * VarInfo.size()
            var_name := load_i64(ptr + 16)
            I var_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0  # Not found
    }

    F drop(&self) -> i64 {
        free(self.vars_ptr)
        1
    }
}

# ============================================================================
# StringBuffer helpers for type formatting (standalone to avoid str move issues)
# Layout: data(8) + len(8) + cap(8) = 24 bytes
# ============================================================================

F tc_sb_new() -> i64 {
    sb := malloc(24)
    data := malloc(256)
    store_i64(sb, data)
    store_i64(sb + 8, 0)
    store_i64(sb + 16, 256)
    sb
}

F tc_sb_byte(sb: i64, byte: i64) -> i64 {
    len := load_i64(sb + 8)
    cap := load_i64(sb + 16)
    I len >= cap {
        new_cap := cap * 2
        old_data := load_i64(sb)
        new_data := malloc(new_cap)
        memcpy(new_data, old_data, len)
        free(old_data)
        store_i64(sb, new_data)
        store_i64(sb + 16, new_cap)
        0
    } E { 0 }
    data := load_i64(sb)
    store_byte(data + len, byte)
    store_i64(sb + 8, len + 1)
    1
}

F tc_sb_cstr(sb: i64, s: str) -> i64 {
    ptr := str_to_ptr(s)
    # Count length by scanning for null terminator
    slen: mut i64 = 0
    L { I load_byte(ptr + slen) == 0 { B } E { slen = slen + 1 } }
    tc_sb_bytes(sb, ptr, slen)
}

F tc_sb_bytes(sb: i64, src: i64, slen: i64) -> i64 {
    len := load_i64(sb + 8)
    cap := load_i64(sb + 16)
    I len + slen > cap {
        new_cap := len + slen + 256
        old_data := load_i64(sb)
        new_data := malloc(new_cap)
        memcpy(new_data, old_data, len)
        free(old_data)
        store_i64(sb, new_data)
        store_i64(sb + 16, new_cap)
        0
    } E { 0 }
    data := load_i64(sb)
    memcpy(data + len, src, slen)
    store_i64(sb + 8, len + slen)
    1
}

F tc_sb_i64(sb: i64, value: i64) -> i64 {
    I value == 0 {
        tc_sb_byte(sb, 48)
    } E I value < 0 {
        tc_sb_byte(sb, 45)
        tc_sb_i64(sb, 0 - value)
    } E {
        I value >= 10 {
            tc_sb_i64(sb, value / 10)
            0
        } E { 0 }
        tc_sb_byte(sb, (value % 10) + 48)
    }
}

# ============================================================================
# Type Checker
# ============================================================================

S TypeChecker {
    # Type environment
    structs_ptr: i64,       # Array of StructDefInfo
    structs_len: i64,
    structs_cap: i64,

    enums_ptr: i64,         # Array of EnumDefInfo
    enums_len: i64,
    enums_cap: i64,

    functions_ptr: i64,     # Array of FunctionSig
    functions_len: i64,
    functions_cap: i64,

    # Trait definitions
    traits_ptr: i64,        # Array of TraitDefInfo
    traits_len: i64,
    traits_cap: i64,

    # Trait implementations (impl Trait for Type)
    trait_impls_ptr: i64,   # Array of TraitImplInfo
    trait_impls_len: i64,
    trait_impls_cap: i64,

    # Scope stack
    scopes_ptr: i64,        # Array of Scope pointers
    scopes_len: i64,
    scopes_cap: i64,

    # Current function context
    current_fn_ret_ptr: i64,
    current_fn_name_idx: i64,

    # Current generic parameters
    current_generics_ptr: i64,
    current_generics_len: i64,

    # Type variable counter
    next_type_var: i64,

    # Substitution map for type variables (var_id -> type_ptr pairs)
    subst_keys_ptr: i64,     # Array of var_id
    subst_values_ptr: i64,   # Array of type_ptr
    subst_len: i64,
    subst_cap: i64,

    # Generic binding map for instantiation (name_idx -> type_ptr pairs)
    generic_bind_keys_ptr: i64,    # Array of name_idx
    generic_bind_values_ptr: i64,  # Array of type_ptr
    generic_bind_len: i64,
    generic_bind_cap: i64,

    # Trait bounds for current generic context
    # Each entry: (generic_name_idx, trait_name_idx) pairs
    bounds_keys_ptr: i64,          # Array of generic_name_idx
    bounds_values_ptr: i64,        # Array of trait_name_idx
    bounds_len: i64,
    bounds_cap: i64,

    # Monomorphization tracking: records (fn_name_idx, type_args_ptr, type_args_len) triples
    mono_entries_ptr: i64,
    mono_len: i64,
    mono_cap: i64,

    # Struct monomorphization tracking: (struct_name_idx, type_args_ptr, type_args_len) triples
    struct_mono_ptr: i64,
    struct_mono_len: i64,
    struct_mono_cap: i64,

    # Associated types: (trait_name_idx, type_name_idx, assoc_name_idx, resolved_type_ptr) quads
    assoc_types_ptr: i64,
    assoc_types_len: i64,
    assoc_types_cap: i64,

    # Errors
    errors_ptr: i64,
    errors_len: i64,
    errors_cap: i64,

    # String pool reference (from Module)
    sp_data: i64,
    sp_offsets: i64,
    sp_count: i64
}

X TypeChecker {
    F new() -> TypeChecker {
        # Allocate storage
        structs := malloc(64 * StructDefInfo.size())
        enums := malloc(32 * EnumDefInfo.size())
        functions := malloc(256 * FunctionSig.size())
        traits := malloc(32 * TraitDefInfo.size())
        trait_impls := malloc(64 * TraitImplInfo.size())
        scopes := malloc(32 * 8)  # Pointers to Scope
        errors := malloc(64 * TypeError.size())

        # Allocate substitution map storage
        subst_keys := malloc(64 * 8)
        subst_values := malloc(64 * 8)

        # Allocate generic binding map storage
        generic_bind_keys := malloc(32 * 8)
        generic_bind_values := malloc(32 * 8)

        # Allocate trait bounds storage
        bounds_keys := malloc(32 * 8)
        bounds_values := malloc(32 * 8)

        # Allocate monomorphization tracking (each entry = 3 * i64 = 24 bytes)
        mono_entries := malloc(64 * 24)

        # Allocate struct monomorphization tracking (each entry = 3 * i64 = 24 bytes)
        struct_mono := malloc(32 * 24)

        # Allocate associated types storage (each entry = 4 * i64 = 32 bytes)
        assoc_types := malloc(32 * 32)

        # Create initial global scope
        global_scope_ptr := malloc(Scope.size())
        global_scope := Scope.new(64)
        store_i64(global_scope_ptr, global_scope.vars_ptr)
        store_i64(global_scope_ptr + 8, global_scope.vars_len)
        store_i64(global_scope_ptr + 16, global_scope.vars_cap)
        store_i64(scopes, global_scope_ptr)

        tc := TypeChecker {
            structs_ptr: structs, structs_len: 0, structs_cap: 64,
            enums_ptr: enums, enums_len: 0, enums_cap: 32,
            functions_ptr: functions, functions_len: 0, functions_cap: 256,
            traits_ptr: traits, traits_len: 0, traits_cap: 32,
            trait_impls_ptr: trait_impls, trait_impls_len: 0, trait_impls_cap: 64,
            scopes_ptr: scopes, scopes_len: 1, scopes_cap: 32,
            current_fn_ret_ptr: 0, current_fn_name_idx: 0,
            current_generics_ptr: 0, current_generics_len: 0,
            next_type_var: 0,
            subst_keys_ptr: subst_keys, subst_values_ptr: subst_values,
            subst_len: 0, subst_cap: 64,
            generic_bind_keys_ptr: generic_bind_keys, generic_bind_values_ptr: generic_bind_values,
            generic_bind_len: 0, generic_bind_cap: 32,
            bounds_keys_ptr: bounds_keys, bounds_values_ptr: bounds_values,
            bounds_len: 0, bounds_cap: 32,
            mono_entries_ptr: mono_entries, mono_len: 0, mono_cap: 64,
            struct_mono_ptr: struct_mono, struct_mono_len: 0, struct_mono_cap: 32,
            assoc_types_ptr: assoc_types, assoc_types_len: 0, assoc_types_cap: 32,
            errors_ptr: errors, errors_len: 0, errors_cap: 64,
            sp_data: 0, sp_offsets: 0, sp_count: 0
        }

        # Register built-in functions
        tc.register_builtins()
        tc
    }

    F register_builtins(&self) -> i64 {
        # We'll add built-in function signatures here
        # For now, they'll be registered by the caller using add_function
        0
    }

    F set_string_pool(&self, sp_data: i64, sp_offsets: i64, sp_count: i64) -> i64 {
        self.sp_data = sp_data
        self.sp_offsets = sp_offsets
        self.sp_count = sp_count
        1
    }

    F get_string_ptr(&self, idx: i64) -> i64 {
        entry_ptr := self.sp_offsets + idx * 16
        offset := load_i64(entry_ptr)
        self.sp_data + offset
    }

    F get_string_len(&self, idx: i64) -> i64 {
        entry_ptr := self.sp_offsets + idx * 16
        load_i64(entry_ptr + 8)
    }

    # ========== Scope Management ==========

    F push_scope(&self) -> i64 {
        I self.scopes_len >= self.scopes_cap {
            new_cap := self.scopes_cap * 2
            new_ptr := malloc(new_cap * 8)
            memcpy(new_ptr, self.scopes_ptr, self.scopes_len * 8)
            free(self.scopes_ptr)
            self.scopes_ptr = new_ptr
            self.scopes_cap = new_cap
            0
        } E { 0 }

        new_scope_ptr := malloc(Scope.size())
        new_scope := Scope.new(32)
        store_i64(new_scope_ptr, new_scope.vars_ptr)
        store_i64(new_scope_ptr + 8, new_scope.vars_len)
        store_i64(new_scope_ptr + 16, new_scope.vars_cap)

        store_i64(self.scopes_ptr + self.scopes_len * 8, new_scope_ptr)
        self.scopes_len = self.scopes_len + 1
        1
    }

    F pop_scope(&self) -> i64 {
        I self.scopes_len <= 1 { 0 }
        E {
            self.scopes_len = self.scopes_len - 1
            scope_ptr := load_i64(self.scopes_ptr + self.scopes_len * 8)
            vars_ptr := load_i64(scope_ptr)
            free(vars_ptr)
            free(scope_ptr)
            1
        }
    }

    F add_var(&self, name_idx: i64, type_ptr: i64, is_mut: i64) -> i64 {
        I self.scopes_len == 0 { R 0 }
        scope_ptr := load_i64(self.scopes_ptr + (self.scopes_len - 1) * 8)
        vars_ptr: mut i64 = load_i64(scope_ptr)
        vars_len := load_i64(scope_ptr + 8)
        vars_cap := load_i64(scope_ptr + 16)

        I vars_len >= vars_cap {
            new_cap := vars_cap * 2
            new_ptr := malloc(new_cap * VarInfo.size())
            memcpy(new_ptr, vars_ptr, vars_len * VarInfo.size())
            free(vars_ptr)
            store_i64(scope_ptr, new_ptr)
            store_i64(scope_ptr + 16, new_cap)
            vars_ptr = new_ptr
            0
        } E { 0 }

        ptr := vars_ptr + vars_len * VarInfo.size()
        store_i64(ptr, type_ptr)
        store_i64(ptr + 8, is_mut)
        store_i64(ptr + 16, name_idx)
        store_i64(scope_ptr + 8, vars_len + 1)
        1
    }

    F lookup_var(&self, name_idx: i64) -> i64 {
        # Search from innermost to outermost scope
        idx: mut i64 = self.scopes_len
        L { I idx == 0 { B }
            idx = idx - 1
            scope_ptr := load_i64(self.scopes_ptr + idx * 8)
            vars_ptr := load_i64(scope_ptr)
            vars_len := load_i64(scope_ptr + 8)

            j: mut i64 = 0
            L { I j >= vars_len { B }
                ptr := vars_ptr + j * VarInfo.size()
                var_name := load_i64(ptr + 16)
                I var_name == name_idx {
                    R ptr
                } E {
                    j = j + 1
                }
            }
        }
        0  # Not found
    }

    # ========== Function Registry ==========

    F add_function(&self, sig_ptr: i64) -> i64 {
        I self.functions_len >= self.functions_cap {
            new_cap := self.functions_cap * 2
            new_ptr := malloc(new_cap * FunctionSig.size())
            memcpy(new_ptr, self.functions_ptr, self.functions_len * FunctionSig.size())
            free(self.functions_ptr)
            self.functions_ptr = new_ptr
            self.functions_cap = new_cap
            0
        } E { 0 }

        memcpy(self.functions_ptr + self.functions_len * FunctionSig.size(), sig_ptr, FunctionSig.size())
        self.functions_len = self.functions_len + 1
        self.functions_len - 1
    }

    F find_function(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.functions_len { B }
            ptr := self.functions_ptr + i * FunctionSig.size()
            fn_name := load_i64(ptr)
            I fn_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0  # Not found
    }

    # ========== Struct Registry ==========

    F add_struct(&self, def_ptr: i64) -> i64 {
        I self.structs_len >= self.structs_cap {
            new_cap := self.structs_cap * 2
            new_ptr := malloc(new_cap * StructDefInfo.size())
            memcpy(new_ptr, self.structs_ptr, self.structs_len * StructDefInfo.size())
            free(self.structs_ptr)
            self.structs_ptr = new_ptr
            self.structs_cap = new_cap
            0
        } E { 0 }

        memcpy(self.structs_ptr + self.structs_len * StructDefInfo.size(), def_ptr, StructDefInfo.size())
        self.structs_len = self.structs_len + 1
        self.structs_len - 1
    }

    F find_struct(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.structs_len { B }
            ptr := self.structs_ptr + i * StructDefInfo.size()
            struct_name := load_i64(ptr)
            I struct_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0  # Not found
    }

    # ========== Enum Registry ==========

    F add_enum(&self, def_ptr: i64) -> i64 {
        I self.enums_len >= self.enums_cap {
            new_cap := self.enums_cap * 2
            new_ptr := malloc(new_cap * EnumDefInfo.size())
            memcpy(new_ptr, self.enums_ptr, self.enums_len * EnumDefInfo.size())
            free(self.enums_ptr)
            self.enums_ptr = new_ptr
            self.enums_cap = new_cap
            0
        } E { 0 }

        memcpy(self.enums_ptr + self.enums_len * EnumDefInfo.size(), def_ptr, EnumDefInfo.size())
        self.enums_len = self.enums_len + 1
        self.enums_len - 1
    }

    F find_enum(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.enums_len { B }
            ptr := self.enums_ptr + i * EnumDefInfo.size()
            enum_name := load_i64(ptr)
            I enum_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0  # Not found
    }

    # ========== Trait Registry ==========

    F add_trait(&self, trait_info_ptr: i64) -> i64 {
        I self.traits_len >= self.traits_cap {
            new_cap := self.traits_cap * 2
            new_ptr := malloc(new_cap * TraitDefInfo.size())
            memcpy(new_ptr, self.traits_ptr, self.traits_len * TraitDefInfo.size())
            free(self.traits_ptr)
            self.traits_ptr = new_ptr
            self.traits_cap = new_cap
            0
        } E { 0 }

        memcpy(self.traits_ptr + self.traits_len * TraitDefInfo.size(), trait_info_ptr, TraitDefInfo.size())
        self.traits_len = self.traits_len + 1
        self.traits_len - 1
    }

    F find_trait(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.traits_len { B }
            ptr := self.traits_ptr + i * TraitDefInfo.size()
            trait_name := load_i64(ptr)
            I trait_name == name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0  # Not found
    }

    # ========== Trait Implementation Registry ==========

    F add_trait_impl(&self, impl_info_ptr: i64) -> i64 {
        I self.trait_impls_len >= self.trait_impls_cap {
            new_cap := self.trait_impls_cap * 2
            new_ptr := malloc(new_cap * TraitImplInfo.size())
            memcpy(new_ptr, self.trait_impls_ptr, self.trait_impls_len * TraitImplInfo.size())
            free(self.trait_impls_ptr)
            self.trait_impls_ptr = new_ptr
            self.trait_impls_cap = new_cap
            0
        } E { 0 }

        memcpy(self.trait_impls_ptr + self.trait_impls_len * TraitImplInfo.size(), impl_info_ptr, TraitImplInfo.size())
        self.trait_impls_len = self.trait_impls_len + 1
        self.trait_impls_len - 1
    }

    F find_trait_impl(&self, target_type_idx: i64, trait_name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.trait_impls_len { B }
            ptr := self.trait_impls_ptr + i * TraitImplInfo.size()
            impl_target := load_i64(ptr)
            impl_trait := load_i64(ptr + 8)
            I impl_target == target_type_idx && impl_trait == trait_name_idx {
                R ptr
            } E {
                i = i + 1
            }
        }
        0  # Not found
    }

    F type_implements_trait(&self, type_idx: i64, trait_name_idx: i64) -> i64 {
        impl_ptr := @.find_trait_impl(type_idx, trait_name_idx)
        I impl_ptr != 0 { 1 } E { 0 }
    }

    F register_trait(&self, trait_def_ptr: i64) -> i64 {
        # TraitDef layout:
        # 0: name_idx
        # 8: generics_ptr
        # 16: generics_len
        # 24: super_traits_ptr
        # 32: super_traits_len
        # 40: methods_ptr
        # 48: methods_len
        # 56: is_pub
        # 64: span_start
        # 72: span_end

        name_idx := load_i64(trait_def_ptr)
        generics_ptr := load_i64(trait_def_ptr + 8)
        generics_len := load_i64(trait_def_ptr + 16)
        super_traits_ptr := load_i64(trait_def_ptr + 24)
        super_traits_len := load_i64(trait_def_ptr + 32)
        methods_ptr := load_i64(trait_def_ptr + 40)
        methods_len := load_i64(trait_def_ptr + 48)

        # Create TraitDefInfo
        trait_info_ptr := malloc(TraitDefInfo.size())
        store_i64(trait_info_ptr, name_idx)
        store_i64(trait_info_ptr + 8, generics_ptr)
        store_i64(trait_info_ptr + 16, generics_len)
        store_i64(trait_info_ptr + 24, super_traits_ptr)
        store_i64(trait_info_ptr + 32, super_traits_len)
        store_i64(trait_info_ptr + 40, methods_ptr)
        store_i64(trait_info_ptr + 48, methods_len)

        @.add_trait(trait_info_ptr)
    }

    # ========== Method Resolution ==========

    # Find a method in a struct's impl methods
    # Returns a FunctionSig pointer or 0 if not found
    F find_method_in_struct(&self, struct_name_idx: i64, method_name_idx: i64) -> i64 {
        struct_ptr := @.find_struct(struct_name_idx)
        I struct_ptr == 0 { R 0 }

        methods_ptr := load_i64(struct_ptr + 40)   # methods_ptr
        methods_len := load_i64(struct_ptr + 48)    # methods_len

        i: mut i64 = 0
        L { I i >= methods_len { B }
            method_sig := load_i64(methods_ptr + i * 8)
            method_name := load_i64(method_sig)
            I method_name == method_name_idx {
                R method_sig
            } E { i = i + 1 }
        }
        0
    }

    # Find a method through trait implementations
    # Search all trait impls for the given type and method name
    F find_method_in_trait_impls(&self, type_name_idx: i64, method_name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.trait_impls_len { B }
            impl_ptr := self.trait_impls_ptr + i * TraitImplInfo.size()
            impl_target := load_i64(impl_ptr)
            I impl_target == type_name_idx {
                impl_methods_ptr := load_i64(impl_ptr + 16)
                impl_methods_len := load_i64(impl_ptr + 24)

                j: mut i64 = 0
                L { I j >= impl_methods_len { B }
                    method_ptr := load_i64(impl_methods_ptr + j * 8)
                    method_name := load_i64(method_ptr)
                    I method_name == method_name_idx {
                        R method_ptr
                    } E { j = j + 1 }
                }
                0
            } E { 0 }
            i = i + 1
        }
        0
    }

    # Resolve a method call on a receiver type
    # Returns the return type of the method, or unknown if not found
    F resolve_method_call(&self, recv_type_ptr: i64, method_name_idx: i64,
                          args_ptr: i64, args_len: i64,
                          span_start: i64, span_end: i64) -> i64 {
        recv_kind := load_i64(recv_type_ptr)

        I recv_kind == TY_NAMED() {
            type_name_idx := load_i64(recv_type_ptr + 8)
            recv_generics_ptr := load_i64(recv_type_ptr + 16)
            recv_generics_len := load_i64(recv_type_ptr + 24)

            # 1. Look for inherent method on the struct
            method_sig := @.find_method_in_struct(type_name_idx, method_name_idx)

            # 2. If not found, look in trait implementations
            I method_sig == 0 {
                method_sig = @.find_method_in_trait_impls(type_name_idx, method_name_idx)
                0
            } E { 0 }

            I method_sig != 0 {
                # Found method - set up generic bindings from receiver type args
                fn_generics_ptr := load_i64(method_sig + 8)
                fn_generics_len := load_i64(method_sig + 16)
                fn_params_ptr := load_i64(method_sig + 24)
                fn_params_len := load_i64(method_sig + 32)
                fn_ret_ptr := load_i64(method_sig + 40)

                # Bind struct's generic params to receiver's type args
                struct_ptr := @.find_struct(type_name_idx)
                I struct_ptr != 0 && recv_generics_len > 0 {
                    struct_gen_ptr := load_i64(struct_ptr + 8)
                    struct_gen_len := load_i64(struct_ptr + 16)
                    @.bind_generics(struct_gen_ptr, struct_gen_len,
                                   recv_generics_ptr, recv_generics_len)
                    0
                } E {
                    @.clear_generic_bindings()
                    0
                }

                # Type check arguments (skip first param if &self)
                param_offset: mut i64 = 0
                I fn_params_len > 0 {
                    # Check if first param is &self (name matches "self")
                    first_param_name := load_i64(fn_params_ptr)
                    I first_param_name >= 0 {
                        first_name_ptr := @.get_string_ptr(first_param_name)
                        first_name_len := @.get_string_len(first_param_name)
                        # Check for "self" (s=115, e=101, l=108, f=102)
                        I first_name_len == 4 && load_byte(first_name_ptr) == 115 &&
                           load_byte(first_name_ptr + 1) == 101 &&
                           load_byte(first_name_ptr + 2) == 108 &&
                           load_byte(first_name_ptr + 3) == 102 {
                            param_offset = 1
                            0
                        } E { 0 }
                    } E { 0 }
                    0
                } E { 0 }

                # Infer generics from arguments
                expected_arg_count := fn_params_len - param_offset
                i: mut i64 = 0
                L { I i >= args_len { B }
                    arg_ptr := load_i64(args_ptr + i * 8)
                    arg_ty := @.check_expr(arg_ptr)

                    I fn_generics_len > 0 && (i + param_offset) < fn_params_len {
                        param_type_ptr := load_i64(fn_params_ptr + (i + param_offset) * 24 + 8)
                        @.infer_generic_from_types(param_type_ptr, arg_ty)
                        0
                    } E { 0 }
                    i = i + 1
                }

                # Instantiate return type with resolved generics
                I fn_generics_len > 0 || recv_generics_len > 0 {
                    R @.instantiate_type(fn_ret_ptr)
                } E {
                    R fn_ret_ptr
                }
            } E {
                # Method not found - try to suggest similar names
                @.report_undefined_method(type_name_idx, method_name_idx, span_start, span_end)

                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.unknown_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
        }
        # Array methods (len, push, pop, etc.)
        E I recv_kind == TY_ARRAY() {
            @.resolve_array_method(recv_type_ptr, method_name_idx)
        }
        # String methods (len, etc.)
        E I recv_kind == TY_STR() {
            @.resolve_str_method(method_name_idx)
        }
        E {
            # Cannot resolve method on this type
            type_ptr := malloc(ResolvedType.size())
            ty := ResolvedType.unknown_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        }
    }

    # Resolve self-call (@.method) using current function context
    F resolve_self_call(&self, method_name_idx: i64,
                        args_ptr: i64, args_len: i64,
                        span_start: i64, span_end: i64) -> i64 {
        # Look up "self" variable in scope to determine the current type
        # In Vais, @ refers to self-recursion or self in impl methods

        # Check all trait impls and struct impls for method
        # Try each struct that has this method registered
        i: mut i64 = 0
        L { I i >= self.structs_len { B }
            struct_ptr := self.structs_ptr + i * StructDefInfo.size()
            struct_name := load_i64(struct_ptr)
            methods_ptr := load_i64(struct_ptr + 40)
            methods_len := load_i64(struct_ptr + 48)

            j: mut i64 = 0
            L { I j >= methods_len { B }
                method_sig := load_i64(methods_ptr + j * 8)
                method_name := load_i64(method_sig)
                I method_name == method_name_idx {
                    ret_ptr := load_i64(method_sig + 40)
                    R ret_ptr
                } E { j = j + 1 }
            }
            i = i + 1
        }

        # Also check trait impl methods
        i = 0
        L { I i >= self.trait_impls_len { B }
            impl_ptr := self.trait_impls_ptr + i * TraitImplInfo.size()
            impl_methods_ptr := load_i64(impl_ptr + 16)
            impl_methods_len := load_i64(impl_ptr + 24)

            j: mut i64 = 0
            L { I j >= impl_methods_len { B }
                method_sig := load_i64(impl_methods_ptr + j * 8)
                method_name := load_i64(method_sig)
                I method_name == method_name_idx {
                    ret_ptr := load_i64(method_sig + 40)
                    R ret_ptr
                } E { j = j + 1 }
            }
            i = i + 1
        }

        # Check if it's a known function (@ for self-recursion)
        fn_sig := @.find_function(method_name_idx)
        I fn_sig != 0 {
            R load_i64(fn_sig + 40)
        }

        # Not found
        type_ptr := malloc(ResolvedType.size())
        ty := ResolvedType.unknown_type()
        store_i64(type_ptr, ty.kind)
        store_i64(type_ptr + 8, ty.field0)
        store_i64(type_ptr + 16, ty.field1)
        store_i64(type_ptr + 24, ty.field2)
        type_ptr
    }

    # Built-in array methods
    F resolve_array_method(&self, array_type_ptr: i64, method_name_idx: i64) -> i64 {
        inner_type_ptr := load_i64(array_type_ptr + 8)
        method_name_ptr := @.get_string_ptr(method_name_idx)
        method_name_len := @.get_string_len(method_name_idx)

        # "len" -> i64
        I method_name_len == 3 && load_byte(method_name_ptr) == 108 &&
           load_byte(method_name_ptr + 1) == 101 && load_byte(method_name_ptr + 2) == 110 {
            type_ptr := malloc(ResolvedType.size())
            ty := ResolvedType.i64_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            R type_ptr
        }

        # "push" -> unit
        I method_name_len == 4 && load_byte(method_name_ptr) == 112 &&
           load_byte(method_name_ptr + 1) == 117 && load_byte(method_name_ptr + 2) == 115 &&
           load_byte(method_name_ptr + 3) == 104 {
            type_ptr := malloc(ResolvedType.size())
            ty := ResolvedType.unit_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            R type_ptr
        }

        # "pop" -> element type (or optional)
        I method_name_len == 3 && load_byte(method_name_ptr) == 112 &&
           load_byte(method_name_ptr + 1) == 111 && load_byte(method_name_ptr + 2) == 112 {
            R inner_type_ptr
        }

        # Default: unknown
        type_ptr := malloc(ResolvedType.size())
        ty := ResolvedType.unknown_type()
        store_i64(type_ptr, ty.kind)
        store_i64(type_ptr + 8, ty.field0)
        store_i64(type_ptr + 16, ty.field1)
        store_i64(type_ptr + 24, ty.field2)
        type_ptr
    }

    # Built-in string methods
    F resolve_str_method(&self, method_name_idx: i64) -> i64 {
        method_name_ptr := @.get_string_ptr(method_name_idx)
        method_name_len := @.get_string_len(method_name_idx)

        # "len" -> i64
        I method_name_len == 3 && load_byte(method_name_ptr) == 108 &&
           load_byte(method_name_ptr + 1) == 101 && load_byte(method_name_ptr + 2) == 110 {
            type_ptr := malloc(ResolvedType.size())
            ty := ResolvedType.i64_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            R type_ptr
        }

        # Default: unknown
        type_ptr := malloc(ResolvedType.size())
        ty := ResolvedType.unknown_type()
        store_i64(type_ptr, ty.kind)
        store_i64(type_ptr + 8, ty.field0)
        store_i64(type_ptr + 16, ty.field1)
        store_i64(type_ptr + 24, ty.field2)
        type_ptr
    }

    # Report undefined method error (with "did you mean?" suggestion)
    F report_undefined_method(&self, type_name_idx: i64, method_name_idx: i64,
                              span_start: i64, span_end: i64) -> i64 {
        err := TypeError.undefined_func(method_name_idx, span_start, span_end)
        err_ptr := malloc(TypeError.size())
        store_i64(err_ptr, err.kind)
        store_i64(err_ptr + 8, err.span_start)
        store_i64(err_ptr + 16, err.span_end)
        store_i64(err_ptr + 24, err.expected_idx)
        store_i64(err_ptr + 32, err.found_idx)
        store_i64(err_ptr + 40, err.name_idx)
        @.add_error(err_ptr)
    }

    # ========== Error Recovery & Suggestions ==========

    # Compute Levenshtein distance between two strings
    F levenshtein_distance(&self, a_idx: i64, b_idx: i64) -> i64 {
        a_ptr := @.get_string_ptr(a_idx)
        a_len := @.get_string_len(a_idx)
        b_ptr := @.get_string_ptr(b_idx)
        b_len := @.get_string_len(b_idx)

        # Quick checks
        I a_len == 0 { R b_len }
        I b_len == 0 { R a_len }

        # Use 1-row DP approach: prev_row[j] for j in 0..b_len+1
        row_size := b_len + 1
        prev_row := malloc(row_size * 8)
        curr_row := malloc(row_size * 8)

        # Initialize prev_row = [0, 1, 2, ..., b_len]
        j: mut i64 = 0
        L { I j > b_len { B }
            store_i64(prev_row + j * 8, j)
            j = j + 1
        }

        # Fill matrix
        i: mut i64 = 0
        L { I i >= a_len { B }
            store_i64(curr_row, i + 1)  # curr_row[0] = i + 1

            j2: mut i64 = 0
            L { I j2 >= b_len { B }
                a_char := load_byte(a_ptr + i)
                b_char := load_byte(b_ptr + j2)

                cost := I a_char == b_char { 0 } E { 1 }

                # min(delete, insert, replace)
                delete_cost := load_i64(prev_row + (j2 + 1) * 8) + 1
                insert_cost := load_i64(curr_row + j2 * 8) + 1
                replace_cost := load_i64(prev_row + j2 * 8) + cost

                min_val := delete_cost
                I insert_cost < min_val { min_val = insert_cost } E { 0 }
                I replace_cost < min_val { min_val = replace_cost } E { 0 }

                store_i64(curr_row + (j2 + 1) * 8, min_val)
                j2 = j2 + 1
            }

            # Swap rows
            tmp := prev_row
            prev_row = curr_row
            curr_row = tmp

            i = i + 1
        }

        result := load_i64(prev_row + b_len * 8)
        free(prev_row)
        free(curr_row)
        result
    }

    # Find the most similar name in the function registry
    # Returns name_idx of best match, or -1 if none close enough
    F find_similar_function(&self, name_idx: i64) -> i64 {
        best_idx: mut i64 = -1
        best_dist: mut i64 = 999

        name_len := @.get_string_len(name_idx)
        # Max distance threshold: max(2, name_len / 3)
        threshold := I name_len > 6 { name_len / 3 } E { 2 }

        i: mut i64 = 0
        L { I i >= self.functions_len { B }
            fn_ptr := self.functions_ptr + i * FunctionSig.size()
            fn_name_idx := load_i64(fn_ptr)

            dist := @.levenshtein_distance(name_idx, fn_name_idx)
            I dist < best_dist && dist <= threshold && dist > 0 {
                best_dist = dist
                best_idx = fn_name_idx
                0
            } E { 0 }
            i = i + 1
        }
        best_idx
    }

    # Find the most similar variable name in current scopes
    F find_similar_variable(&self, name_idx: i64) -> i64 {
        best_idx: mut i64 = -1
        best_dist: mut i64 = 999

        name_len := @.get_string_len(name_idx)
        threshold := I name_len > 6 { name_len / 3 } E { 2 }

        # Search all scopes from inner to outer
        s: mut i64 = self.scopes_len
        L { I s == 0 { B }
            s = s - 1
            scope_ptr := load_i64(self.scopes_ptr + s * 8)
            vars_ptr := load_i64(scope_ptr)
            vars_len := load_i64(scope_ptr + 8)

            j: mut i64 = 0
            L { I j >= vars_len { B }
                var_ptr := vars_ptr + j * VarInfo.size()
                var_name_idx := load_i64(var_ptr + 16)

                dist := @.levenshtein_distance(name_idx, var_name_idx)
                I dist < best_dist && dist <= threshold && dist > 0 {
                    best_dist = dist
                    best_idx = var_name_idx
                    0
                } E { 0 }
                j = j + 1
            }
        }
        best_idx
    }

    # Find the most similar struct name
    F find_similar_struct(&self, name_idx: i64) -> i64 {
        best_idx: mut i64 = -1
        best_dist: mut i64 = 999

        name_len := @.get_string_len(name_idx)
        threshold := I name_len > 6 { name_len / 3 } E { 2 }

        i: mut i64 = 0
        L { I i >= self.structs_len { B }
            struct_ptr := self.structs_ptr + i * StructDefInfo.size()
            struct_name := load_i64(struct_ptr)

            dist := @.levenshtein_distance(name_idx, struct_name)
            I dist < best_dist && dist <= threshold && dist > 0 {
                best_dist = dist
                best_idx = struct_name
                0
            } E { 0 }
            i = i + 1
        }
        best_idx
    }

    # ========== Trait Bounds Management ==========

    # Add a trait bound for a generic parameter: T: TraitName
    F add_trait_bound(&self, generic_name_idx: i64, trait_name_idx: i64) -> i64 {
        I self.bounds_len >= self.bounds_cap {
            new_cap := self.bounds_cap * 2
            new_keys := malloc(new_cap * 8)
            new_values := malloc(new_cap * 8)
            memcpy(new_keys, self.bounds_keys_ptr, self.bounds_len * 8)
            memcpy(new_values, self.bounds_values_ptr, self.bounds_len * 8)
            free(self.bounds_keys_ptr)
            free(self.bounds_values_ptr)
            self.bounds_keys_ptr = new_keys
            self.bounds_values_ptr = new_values
            self.bounds_cap = new_cap
            0
        } E { 0 }

        store_i64(self.bounds_keys_ptr + self.bounds_len * 8, generic_name_idx)
        store_i64(self.bounds_values_ptr + self.bounds_len * 8, trait_name_idx)
        self.bounds_len = self.bounds_len + 1
        1
    }

    # Clear all trait bounds (e.g., when leaving a generic context)
    F clear_trait_bounds(&self) -> i64 {
        self.bounds_len = 0
        1
    }

    # Get trait bounds for a generic parameter
    # Returns count of bounds found, stores trait_name_idx values in out_buf
    F get_trait_bounds(&self, generic_name_idx: i64, out_buf: i64, max_count: i64) -> i64 {
        count: mut i64 = 0
        i: mut i64 = 0
        L { I i >= self.bounds_len { B }
            key := load_i64(self.bounds_keys_ptr + i * 8)
            I key == generic_name_idx && count < max_count {
                trait_idx := load_i64(self.bounds_values_ptr + i * 8)
                store_i64(out_buf + count * 8, trait_idx)
                count = count + 1
                0
            } E { 0 }
            i = i + 1
        }
        count
    }

    # Verify that a concrete type satisfies all trait bounds for a generic parameter
    # Returns 1 if all bounds satisfied, 0 otherwise
    F verify_trait_bounds(&self, generic_name_idx: i64, concrete_type_ptr: i64,
                          span_start: i64, span_end: i64) -> i64 {
        concrete_kind := load_i64(concrete_type_ptr)

        # Unknown/Generic/Var types satisfy all bounds (defer checking)
        I concrete_kind == TY_UNKNOWN() || concrete_kind == TY_GENERIC() || concrete_kind == TY_VAR() {
            R 1
        }

        # Get concrete type name for trait impl lookup
        type_name_idx: mut i64 = -1
        I concrete_kind == TY_NAMED() {
            type_name_idx = load_i64(concrete_type_ptr + 8)
            0
        } E { 0 }

        # Check each bound
        all_ok: mut i64 = 1
        i: mut i64 = 0
        L { I i >= self.bounds_len { B }
            key := load_i64(self.bounds_keys_ptr + i * 8)
            I key == generic_name_idx {
                trait_name_idx := load_i64(self.bounds_values_ptr + i * 8)

                # Check if concrete type implements this trait
                I type_name_idx >= 0 {
                    I @.type_implements_trait(type_name_idx, trait_name_idx) == 0 {
                        # Bound not satisfied - report error with type names
                        exp_sb := tc_sb_new()
                        tc_sb_cstr(exp_sb, "impl ")
                        I self.sp_data != 0 && trait_name_idx >= 0 && trait_name_idx < self.sp_count {
                            tn_ptr := @.get_string_ptr(trait_name_idx)
                            tn_len := @.get_string_len(trait_name_idx)
                            tc_sb_bytes(exp_sb, tn_ptr, tn_len)
                        } E { tc_sb_cstr(exp_sb, "Trait") }
                        found_sb := tc_sb_new()
                        I self.sp_data != 0 && type_name_idx >= 0 && type_name_idx < self.sp_count {
                            typ_ptr := @.get_string_ptr(type_name_idx)
                            typ_len := @.get_string_len(type_name_idx)
                            tc_sb_bytes(found_sb, typ_ptr, typ_len)
                        } E { tc_sb_cstr(found_sb, "?") }
                        err := TypeError.mismatch(exp_sb, found_sb, span_start, span_end)
                        err_ptr := malloc(TypeError.size())
                        store_i64(err_ptr, err.kind)
                        store_i64(err_ptr + 8, err.span_start)
                        store_i64(err_ptr + 16, err.span_end)
                        store_i64(err_ptr + 24, err.expected_idx)
                        store_i64(err_ptr + 32, err.found_idx)
                        store_i64(err_ptr + 40, err.name_idx)
                        @.add_error(err_ptr)
                        all_ok = 0
                        0
                    } E { 0 }
                } E { 0 }
                0
            } E { 0 }
            i = i + 1
        }
        all_ok
    }

    # Parse and register trait bounds from generic parameter nodes
    # GenericParam layout (from parser):
    # 0: name_idx, 8: bounds_ptr, 16: bounds_len
    F register_generic_bounds(&self, generics_ptr: i64, generics_len: i64) -> i64 {
        @.clear_trait_bounds()

        i: mut i64 = 0
        L { I i >= generics_len { B }
            param_ptr := generics_ptr + i * 24  # GenericParam.size() = 24
            param_name := load_i64(param_ptr)
            bounds_ptr := load_i64(param_ptr + 8)
            bounds_len := load_i64(param_ptr + 16)

            # Register each bound
            j: mut i64 = 0
            L { I j >= bounds_len { B }
                bound_name_idx := load_i64(bounds_ptr + j * 8)
                @.add_trait_bound(param_name, bound_name_idx)
                j = j + 1
            }
            i = i + 1
        }
        1
    }

    # Verify bounds for all generic bindings after inference
    F verify_all_generic_bounds(&self, span_start: i64, span_end: i64) -> i64 {
        all_ok: mut i64 = 1
        i: mut i64 = 0
        L { I i >= self.generic_bind_len { B }
            generic_name := load_i64(self.generic_bind_keys_ptr + i * 8)
            concrete_type := load_i64(self.generic_bind_values_ptr + i * 8)

            I @.verify_trait_bounds(generic_name, concrete_type, span_start, span_end) == 0 {
                all_ok = 0
                0
            } E { 0 }
            i = i + 1
        }
        all_ok
    }

    # ========== Associated Types ==========

    # Register an associated type resolution:
    # For impl Trait for Type { type Assoc = ConcreteType; }
    F register_assoc_type(&self, trait_name_idx: i64, type_name_idx: i64,
                          assoc_name_idx: i64, resolved_type_ptr: i64) -> i64 {
        I self.assoc_types_len >= self.assoc_types_cap {
            new_cap := self.assoc_types_cap * 2
            new_ptr := malloc(new_cap * 32)
            memcpy(new_ptr, self.assoc_types_ptr, self.assoc_types_len * 32)
            free(self.assoc_types_ptr)
            self.assoc_types_ptr = new_ptr
            self.assoc_types_cap = new_cap
            0
        } E { 0 }

        entry_ptr := self.assoc_types_ptr + self.assoc_types_len * 32
        store_i64(entry_ptr, trait_name_idx)
        store_i64(entry_ptr + 8, type_name_idx)
        store_i64(entry_ptr + 16, assoc_name_idx)
        store_i64(entry_ptr + 24, resolved_type_ptr)
        self.assoc_types_len = self.assoc_types_len + 1
        1
    }

    # Resolve an associated type: look up what Trait::AssocType resolves to
    # for a given implementing type
    F resolve_assoc_type(&self, trait_name_idx: i64, type_name_idx: i64,
                         assoc_name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.assoc_types_len { B }
            entry_ptr := self.assoc_types_ptr + i * 32
            entry_trait := load_i64(entry_ptr)
            entry_type := load_i64(entry_ptr + 8)
            entry_assoc := load_i64(entry_ptr + 16)

            I entry_trait == trait_name_idx && entry_type == type_name_idx &&
               entry_assoc == assoc_name_idx {
                R load_i64(entry_ptr + 24)
            }
            i = i + 1
        }
        0  # Not found
    }

    # Create a dyn Trait type
    F dyn_trait_type(trait_name_idx: i64) -> i64 {
        type_ptr := malloc(ResolvedType.size())
        store_i64(type_ptr, TY_DYN_TRAIT())
        store_i64(type_ptr + 8, trait_name_idx)
        store_i64(type_ptr + 16, 0)
        store_i64(type_ptr + 24, 0)
        type_ptr
    }

    # Create an associated type projection: Trait::AssocType
    F assoc_type(trait_name_idx: i64, assoc_name_idx: i64) -> i64 {
        type_ptr := malloc(ResolvedType.size())
        store_i64(type_ptr, TY_ASSOC())
        store_i64(type_ptr + 8, trait_name_idx)
        store_i64(type_ptr + 16, assoc_name_idx)
        store_i64(type_ptr + 24, 0)
        type_ptr
    }

    # ========== Object Safety Checking ==========

    # Check if a trait is object-safe (can be used as dyn Trait)
    # A trait is NOT object-safe if:
    # - Any method has generic type parameters
    # - Any method returns Self
    # - Any method lacks a &self receiver
    F check_object_safety(&self, trait_name_idx: i64) -> i64 {
        trait_ptr := @.find_trait(trait_name_idx)
        I trait_ptr == 0 { R 0 }

        methods_ptr := load_i64(trait_ptr + 40)
        methods_len := load_i64(trait_ptr + 48)

        i: mut i64 = 0
        L { I i >= methods_len { B }
            method_ptr := load_i64(methods_ptr + i * 8)
            # method_ptr is a FuncDef

            # Check for generic type parameters on the method
            method_generics_len := load_i64(method_ptr + 16)
            I method_generics_len > 0 {
                R 0  # Not object-safe: method has type parameters
            }

            # Check if method has a self receiver (first param named "self")
            params_ptr := load_i64(method_ptr + 24)
            params_len := load_i64(method_ptr + 32)

            I params_len == 0 {
                R 0  # Not object-safe: no self receiver (static method)
            }

            # Check first param is "self"
            first_param_name := load_i64(params_ptr)
            I first_param_name >= 0 && self.sp_data != 0 {
                name_ptr := @.get_string_ptr(first_param_name)
                name_len := @.get_string_len(first_param_name)
                # Check for "self"
                I name_len != 4 || load_byte(name_ptr) != 115 ||
                   load_byte(name_ptr + 1) != 101 ||
                   load_byte(name_ptr + 2) != 108 ||
                   load_byte(name_ptr + 3) != 102 {
                    R 0  # Not object-safe: first param not self
                } E { 0 }
            } E { 0 }

            i = i + 1
        }
        1  # Object-safe
    }

    # ========== Monomorphization Tracking ==========

    # Record a generic function instantiation for codegen
    # Entry: (fn_name_idx, type_args_ptr, type_args_len)
    F add_mono_entry(&self, fn_name_idx: i64, type_args_ptr: i64, type_args_len: i64) -> i64 {
        # Check for duplicate
        i: mut i64 = 0
        L { I i >= self.mono_len { B }
            entry_ptr := self.mono_entries_ptr + i * 24
            entry_fn := load_i64(entry_ptr)
            entry_len := load_i64(entry_ptr + 16)

            I entry_fn == fn_name_idx && entry_len == type_args_len {
                # Compare type args
                entry_args := load_i64(entry_ptr + 8)
                same: mut i64 = 1
                j: mut i64 = 0
                L { I j >= type_args_len { B }
                    ea := load_i64(entry_args + j * 8)
                    na := load_i64(type_args_ptr + j * 8)
                    ea_kind := load_i64(ea)
                    na_kind := load_i64(na)
                    I ea_kind != na_kind {
                        same = 0
                        B
                    } E {
                        I ea_kind == TY_NAMED() {
                            I load_i64(ea + 8) != load_i64(na + 8) {
                                same = 0
                                B
                            } E { 0 }
                        } E { 0 }
                    }
                    j = j + 1
                }
                I same == 1 { R 1 }  # Already exists
                E { 0 }
            } E { 0 }
            i = i + 1
        }

        # Grow if needed
        I self.mono_len >= self.mono_cap {
            new_cap := self.mono_cap * 2
            new_ptr := malloc(new_cap * 24)
            memcpy(new_ptr, self.mono_entries_ptr, self.mono_len * 24)
            free(self.mono_entries_ptr)
            self.mono_entries_ptr = new_ptr
            self.mono_cap = new_cap
            0
        } E { 0 }

        # Copy type args
        args_copy := malloc(type_args_len * 8)
        memcpy(args_copy, type_args_ptr, type_args_len * 8)

        entry_ptr := self.mono_entries_ptr + self.mono_len * 24
        store_i64(entry_ptr, fn_name_idx)
        store_i64(entry_ptr + 8, args_copy)
        store_i64(entry_ptr + 16, type_args_len)
        self.mono_len = self.mono_len + 1
        1
    }

    # Get monomorphization entry count
    F get_mono_count(&self) -> i64 = self.mono_len

    # Get monomorphization entry by index
    # Returns pointer to (fn_name_idx, type_args_ptr, type_args_len) triple
    F get_mono_entry(&self, idx: i64) -> i64 {
        I idx >= self.mono_len { 0 }
        E { self.mono_entries_ptr + idx * 24 }
    }

    # Record monomorphization when a generic function is called
    F record_mono_from_call(&self, fn_sig_ptr: i64) -> i64 {
        fn_name := load_i64(fn_sig_ptr)
        fn_generics_len := load_i64(fn_sig_ptr + 16)

        I fn_generics_len == 0 { R 0 }

        # Build type args from current generic bindings
        fn_generics_ptr := load_i64(fn_sig_ptr + 8)
        type_args := malloc(fn_generics_len * 8)
        all_concrete: mut i64 = 1

        i: mut i64 = 0
        L { I i >= fn_generics_len { B }
            gen_name := load_i64(fn_generics_ptr + i * 8)
            bound_type := @.get_generic_binding(gen_name)
            I bound_type != 0 {
                resolved := @.apply_substitutions(bound_type)
                resolved_kind := load_i64(resolved)
                I resolved_kind == TY_GENERIC() || resolved_kind == TY_VAR() ||
                   resolved_kind == TY_UNKNOWN() {
                    all_concrete = 0
                    0
                } E { 0 }
                store_i64(type_args + i * 8, resolved)
            } E {
                all_concrete = 0
                store_i64(type_args + i * 8, @.fresh_type_var())
            }
            i = i + 1
        }

        I all_concrete == 1 {
            @.add_mono_entry(fn_name, type_args, fn_generics_len)
        } E {
            free(type_args)
            0
        }
    }

    # ========== Struct Monomorphization ==========

    # Add a struct monomorphization entry
    F add_struct_mono_entry(&self, struct_name_idx: i64, type_args_ptr: i64, type_args_len: i64) -> i64 {
        # Check for duplicate
        i: mut i64 = 0
        L { I i >= self.struct_mono_len { B }
            entry_ptr := self.struct_mono_ptr + i * 24
            entry_name := load_i64(entry_ptr)
            entry_len := load_i64(entry_ptr + 16)

            I entry_name == struct_name_idx && entry_len == type_args_len {
                entry_args := load_i64(entry_ptr + 8)
                same: mut i64 = 1
                j: mut i64 = 0
                L { I j >= type_args_len { B }
                    ea := load_i64(entry_args + j * 8)
                    na := load_i64(type_args_ptr + j * 8)
                    ea_kind := load_i64(ea)
                    na_kind := load_i64(na)
                    I ea_kind != na_kind {
                        same = 0
                        B
                    } E { 0 }
                    j = j + 1
                }
                I same == 1 { R 1 }  # Already exists
                E { 0 }
            } E { 0 }
            i = i + 1
        }

        # Grow if needed
        I self.struct_mono_len >= self.struct_mono_cap {
            new_cap := self.struct_mono_cap * 2
            new_ptr := malloc(new_cap * 24)
            memcpy(new_ptr, self.struct_mono_ptr, self.struct_mono_len * 24)
            free(self.struct_mono_ptr)
            self.struct_mono_ptr = new_ptr
            self.struct_mono_cap = new_cap
            0
        } E { 0 }

        # Copy type args
        args_copy := malloc(type_args_len * 8)
        memcpy(args_copy, type_args_ptr, type_args_len * 8)

        entry_ptr := self.struct_mono_ptr + self.struct_mono_len * 24
        store_i64(entry_ptr, struct_name_idx)
        store_i64(entry_ptr + 8, args_copy)
        store_i64(entry_ptr + 16, type_args_len)
        self.struct_mono_len = self.struct_mono_len + 1
        1
    }

    # Get struct mono entry count
    F get_struct_mono_count(&self) -> i64 = self.struct_mono_len

    # Get struct mono entry by index
    F get_struct_mono_entry(&self, idx: i64) -> i64 {
        I idx >= self.struct_mono_len { 0 }
        E { self.struct_mono_ptr + idx * 24 }
    }

    # Record struct monomorphization when a generic struct is instantiated
    F record_struct_mono(&self, struct_name_idx: i64, struct_generics_ptr: i64, struct_generics_len: i64) -> i64 {
        I struct_generics_len == 0 { R 0 }

        # Build type args from current generic bindings
        type_args := malloc(struct_generics_len * 8)
        all_concrete: mut i64 = 1

        i: mut i64 = 0
        L { I i >= struct_generics_len { B }
            gen_name := load_i64(struct_generics_ptr + i * 8)
            bound_type := @.get_generic_binding(gen_name)
            I bound_type != 0 {
                resolved := @.apply_substitutions(bound_type)
                resolved_kind := load_i64(resolved)
                I resolved_kind == TY_GENERIC() || resolved_kind == TY_VAR() ||
                   resolved_kind == TY_UNKNOWN() {
                    all_concrete = 0
                    0
                } E { 0 }
                store_i64(type_args + i * 8, resolved)
            } E {
                all_concrete = 0
                store_i64(type_args + i * 8, @.fresh_type_var())
            }
            i = i + 1
        }

        I all_concrete == 1 {
            @.add_struct_mono_entry(struct_name_idx, type_args, struct_generics_len)
        } E {
            free(type_args)
            0
        }
    }

    # ========== Exhaustiveness Checking ==========

    # Check if a match expression covers all enum variants
    # Returns 1 if exhaustive, 0 if not (and adds error)
    F check_match_exhaustiveness(&self, match_expr_ptr: i64, arms_ptr: i64, arms_len: i64,
                                 span_start: i64, span_end: i64) -> i64 {
        # Get the type of the match expression
        match_ty := @.check_expr(match_expr_ptr)
        match_kind := load_i64(match_ty)

        # Only check exhaustiveness for enum types
        I match_kind == TY_NAMED() {
            type_name_idx := load_i64(match_ty + 8)
            enum_ptr := @.find_enum(type_name_idx)

            I enum_ptr != 0 {
                # Get enum variants
                variants_ptr := load_i64(enum_ptr + 24)
                variants_len := load_i64(enum_ptr + 32)

                # Check if wildcard pattern exists
                has_wildcard: mut i64 = 0

                # Track which variants are covered
                covered := malloc(variants_len * 8)
                k: mut i64 = 0
                L { I k >= variants_len { B }
                    store_i64(covered + k * 8, 0)
                    k = k + 1
                }

                # Check each arm's pattern
                i: mut i64 = 0
                L { I i >= arms_len { B }
                    arm_ptr := arms_ptr + i * 32  # MatchArm size estimate
                    pattern_ptr := load_i64(arm_ptr)

                    I pattern_ptr != 0 {
                        pat_kind := load_i64(pattern_ptr)

                        # PATTERN_WILDCARD = 80 (assume)
                        I pat_kind == 80 {
                            has_wildcard = 1
                            0
                        }
                        # PATTERN_IDENT = 81 (assume) - binding pattern also acts as wildcard
                        E I pat_kind == 81 {
                            has_wildcard = 1
                            0
                        }
                        # PATTERN_ENUM = 85 (assume)
                        E I pat_kind == 85 {
                            variant_name := load_i64(pattern_ptr + 24)  # variant name_idx
                            # Find which variant this is
                            v: mut i64 = 0
                            L { I v >= variants_len { B }
                                # Variant layout: name_idx at start
                                var_name := load_i64(variants_ptr + v * 24)  # Variant.size() estimate
                                I var_name == variant_name {
                                    store_i64(covered + v * 8, 1)
                                    B
                                } E { v = v + 1 }
                            }
                            0
                        } E { 0 }
                    } E { 0 }
                    i = i + 1
                }

                # If wildcard exists, it's exhaustive
                I has_wildcard == 1 {
                    free(covered)
                    R 1
                }

                # Check if all variants are covered
                all_covered: mut i64 = 1
                m: mut i64 = 0
                L { I m >= variants_len { B }
                    I load_i64(covered + m * 8) == 0 {
                        all_covered = 0
                        B
                    } E { m = m + 1 }
                }

                free(covered)

                I all_covered == 0 {
                    # Non-exhaustive match - add error with enum type info
                    exp_sb := tc_sb_new()
                    tc_sb_cstr(exp_sb, "exhaustive match on ")
                    I self.sp_data != 0 && type_name_idx >= 0 && type_name_idx < self.sp_count {
                        en_ptr := @.get_string_ptr(type_name_idx)
                        en_len := @.get_string_len(type_name_idx)
                        tc_sb_bytes(exp_sb, en_ptr, en_len)
                    } E { tc_sb_cstr(exp_sb, "enum") }
                    found_sb := tc_sb_new()
                    tc_sb_cstr(found_sb, "non-exhaustive")
                    err := TypeError.mismatch(exp_sb, found_sb, span_start, span_end)
                    err_ptr := malloc(TypeError.size())
                    store_i64(err_ptr, err.kind)
                    store_i64(err_ptr + 8, err.span_start)
                    store_i64(err_ptr + 16, err.span_end)
                    store_i64(err_ptr + 24, err.expected_idx)
                    store_i64(err_ptr + 32, err.found_idx)
                    store_i64(err_ptr + 40, err.name_idx)
                    @.add_error(err_ptr)
                    0
                } E { 1 }
            } E {
                # Not an enum - check for wildcard/default arm
                @.check_has_wildcard_arm(arms_ptr, arms_len)
            }
        }
        # For non-named types (int, bool, etc.) - check for wildcard
        E I match_kind == TY_BOOL() {
            @.check_bool_exhaustiveness(arms_ptr, arms_len, span_start, span_end)
        }
        E {
            @.check_has_wildcard_arm(arms_ptr, arms_len)
        }
    }

    # Check if arms include a wildcard/default arm
    F check_has_wildcard_arm(&self, arms_ptr: i64, arms_len: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= arms_len { B }
            arm_ptr := arms_ptr + i * 32
            pattern_ptr := load_i64(arm_ptr)
            I pattern_ptr != 0 {
                pat_kind := load_i64(pattern_ptr)
                # Wildcard or binding pattern
                I pat_kind == 80 || pat_kind == 81 {
                    R 1
                } E { 0 }
            } E { 0 }
            i = i + 1
        }
        0
    }

    # Check bool exhaustiveness (both true and false covered)
    F check_bool_exhaustiveness(&self, arms_ptr: i64, arms_len: i64,
                                span_start: i64, span_end: i64) -> i64 {
        has_true: mut i64 = 0
        has_false: mut i64 = 0
        has_wildcard: mut i64 = 0

        i: mut i64 = 0
        L { I i >= arms_len { B }
            arm_ptr := arms_ptr + i * 32
            pattern_ptr := load_i64(arm_ptr)
            I pattern_ptr != 0 {
                pat_kind := load_i64(pattern_ptr)
                I pat_kind == 80 || pat_kind == 81 {
                    has_wildcard = 1
                    0
                }
                # PATTERN_BOOL = 82 (assume)
                E I pat_kind == 82 {
                    val := load_i64(pattern_ptr + 24)
                    I val == 1 { has_true = 1 } E { has_false = 1 }
                    0
                } E { 0 }
            } E { 0 }
            i = i + 1
        }

        I has_wildcard == 1 || (has_true == 1 && has_false == 1) { 1 }
        E { 0 }
    }

    # ========== Error Reporting ==========

    F add_error(&self, err_ptr: i64) -> i64 {
        I self.errors_len >= self.errors_cap {
            new_cap := self.errors_cap * 2
            new_ptr := malloc(new_cap * TypeError.size())
            memcpy(new_ptr, self.errors_ptr, self.errors_len * TypeError.size())
            free(self.errors_ptr)
            self.errors_ptr = new_ptr
            self.errors_cap = new_cap
            0
        } E { 0 }

        memcpy(self.errors_ptr + self.errors_len * TypeError.size(), err_ptr, TypeError.size())
        self.errors_len = self.errors_len + 1
        self.errors_len - 1
    }

    F has_errors(&self) -> i64 {
        I self.errors_len > 0 { 1 } E { 0 }
    }

    F get_error_count(&self) -> i64 = self.errors_len

    F get_error(&self, idx: i64) -> i64 {
        I idx >= self.errors_len { 0 }
        E { self.errors_ptr + idx * TypeError.size() }
    }

    # ========== Type Formatting ==========

    # Format a ResolvedType pointer into a StringBuffer
    # Returns the sb pointer (caller must free)
    F format_type(&self, type_ptr: i64) -> i64 {
        sb := tc_sb_new()
        @.format_type_to_sb(type_ptr, sb)
        sb
    }

    # Append type string representation to an existing StringBuffer
    F format_type_to_sb(&self, type_ptr: i64, sb: i64) -> i64 {
        I type_ptr == 0 {
            tc_sb_cstr(sb, "?")
            R 1
        } E { 0 }

        kind := load_i64(type_ptr)

        I kind == TY_I8() { tc_sb_cstr(sb, "i8") }
        E I kind == TY_I16() { tc_sb_cstr(sb, "i16") }
        E I kind == TY_I32() { tc_sb_cstr(sb, "i32") }
        E I kind == TY_I64() { tc_sb_cstr(sb, "i64") }
        E I kind == TY_I128() { tc_sb_cstr(sb, "i128") }
        E I kind == TY_U8() { tc_sb_cstr(sb, "u8") }
        E I kind == TY_U16() { tc_sb_cstr(sb, "u16") }
        E I kind == TY_U32() { tc_sb_cstr(sb, "u32") }
        E I kind == TY_U64() { tc_sb_cstr(sb, "u64") }
        E I kind == TY_U128() { tc_sb_cstr(sb, "u128") }
        E I kind == TY_F32() { tc_sb_cstr(sb, "f32") }
        E I kind == TY_F64() { tc_sb_cstr(sb, "f64") }
        E I kind == TY_BOOL() { tc_sb_cstr(sb, "bool") }
        E I kind == TY_STR() { tc_sb_cstr(sb, "str") }
        E I kind == TY_UNIT() { tc_sb_cstr(sb, "()") }
        E I kind == TY_UNKNOWN() { tc_sb_cstr(sb, "?") }
        E I kind == TY_NEVER() { tc_sb_cstr(sb, "!") }
        E I kind == TY_ARRAY() {
            inner_ptr := load_i64(type_ptr + 8)
            tc_sb_byte(sb, 91)  # '['
            @.format_type_to_sb(inner_ptr, sb)
            tc_sb_byte(sb, 93)  # ']'
        }
        E I kind == TY_OPTIONAL() {
            inner_ptr := load_i64(type_ptr + 8)
            @.format_type_to_sb(inner_ptr, sb)
            tc_sb_byte(sb, 63)  # '?'
        }
        E I kind == TY_RESULT() {
            inner_ptr := load_i64(type_ptr + 8)
            @.format_type_to_sb(inner_ptr, sb)
            tc_sb_byte(sb, 33)  # '!'
        }
        E I kind == TY_POINTER() {
            inner_ptr := load_i64(type_ptr + 8)
            tc_sb_byte(sb, 42)  # '*'
            @.format_type_to_sb(inner_ptr, sb)
        }
        E I kind == TY_REF() {
            inner_ptr := load_i64(type_ptr + 8)
            tc_sb_byte(sb, 38)  # '&'
            @.format_type_to_sb(inner_ptr, sb)
        }
        E I kind == TY_REF_MUT() {
            inner_ptr := load_i64(type_ptr + 8)
            tc_sb_cstr(sb, "&mut ")
            @.format_type_to_sb(inner_ptr, sb)
        }
        E I kind == TY_NAMED() {
            name_idx := load_i64(type_ptr + 8)
            I self.sp_data != 0 && name_idx >= 0 && name_idx < self.sp_count {
                name_ptr := @.get_string_ptr(name_idx)
                name_len := @.get_string_len(name_idx)
                tc_sb_bytes(sb, name_ptr, name_len)
            } E {
                tc_sb_cstr(sb, "<named>")
            }
            # Append generics if present
            generics_ptr := load_i64(type_ptr + 16)
            generics_len := load_i64(type_ptr + 24)
            I generics_len > 0 {
                tc_sb_byte(sb, 60)  # '<'
                gi: mut i64 = 0
                L { I gi >= generics_len { B }
                    I gi > 0 { tc_sb_cstr(sb, ", ") 0 } E { 0 }
                    g_type_ptr := load_i64(generics_ptr + gi * 8)
                    @.format_type_to_sb(g_type_ptr, sb)
                    gi = gi + 1
                }
                tc_sb_byte(sb, 62)  # '>'
            } E { 0 }
        }
        E I kind == TY_GENERIC() {
            name_idx := load_i64(type_ptr + 8)
            I self.sp_data != 0 && name_idx >= 0 && name_idx < self.sp_count {
                name_ptr := @.get_string_ptr(name_idx)
                name_len := @.get_string_len(name_idx)
                tc_sb_bytes(sb, name_ptr, name_len)
            } E {
                tc_sb_cstr(sb, "T")
            }
        }
        E I kind == TY_VAR() {
            var_id := load_i64(type_ptr + 8)
            tc_sb_byte(sb, 63)  # '?'
            tc_sb_i64(sb, var_id)
        }
        E I kind == TY_FN() {
            params_ptr := load_i64(type_ptr + 8)
            params_len := load_i64(type_ptr + 16)
            ret_ptr := load_i64(type_ptr + 24)
            tc_sb_byte(sb, 40)  # '('
            pi: mut i64 = 0
            L { I pi >= params_len { B }
                I pi > 0 { tc_sb_cstr(sb, ", ") 0 } E { 0 }
                p_type_ptr := load_i64(params_ptr + pi * 8)
                @.format_type_to_sb(p_type_ptr, sb)
                pi = pi + 1
            }
            tc_sb_cstr(sb, ") -> ")
            @.format_type_to_sb(ret_ptr, sb)
        }
        E I kind == TY_TUPLE() {
            types_ptr := load_i64(type_ptr + 8)
            types_len := load_i64(type_ptr + 16)
            tc_sb_byte(sb, 40)  # '('
            ti: mut i64 = 0
            L { I ti >= types_len { B }
                I ti > 0 { tc_sb_cstr(sb, ", ") 0 } E { 0 }
                t_type_ptr := load_i64(types_ptr + ti * 8)
                @.format_type_to_sb(t_type_ptr, sb)
                ti = ti + 1
            }
            tc_sb_byte(sb, 41)  # ')'
        }
        E I kind == TY_DYN_TRAIT() {
            trait_name_idx := load_i64(type_ptr + 8)
            tc_sb_cstr(sb, "dyn ")
            I self.sp_data != 0 && trait_name_idx >= 0 && trait_name_idx < self.sp_count {
                name_ptr := @.get_string_ptr(trait_name_idx)
                name_len := @.get_string_len(trait_name_idx)
                tc_sb_bytes(sb, name_ptr, name_len)
            } E {
                tc_sb_cstr(sb, "Trait")
            }
        }
        E I kind == TY_MAP() {
            key_ptr := load_i64(type_ptr + 8)
            val_ptr := load_i64(type_ptr + 16)
            tc_sb_byte(sb, 91)  # '['
            @.format_type_to_sb(key_ptr, sb)
            tc_sb_byte(sb, 58)  # ':'
            @.format_type_to_sb(val_ptr, sb)
            tc_sb_byte(sb, 93)  # ']'
        }
        E I kind == TY_ASSOC() {
            trait_idx := load_i64(type_ptr + 8)
            assoc_idx := load_i64(type_ptr + 16)
            I self.sp_data != 0 && trait_idx >= 0 && trait_idx < self.sp_count {
                name_ptr := @.get_string_ptr(trait_idx)
                name_len := @.get_string_len(trait_idx)
                tc_sb_bytes(sb, name_ptr, name_len)
            } E {
                tc_sb_cstr(sb, "Trait")
            }
            tc_sb_cstr(sb, "::")
            I self.sp_data != 0 && assoc_idx >= 0 && assoc_idx < self.sp_count {
                name_ptr := @.get_string_ptr(assoc_idx)
                name_len := @.get_string_len(assoc_idx)
                tc_sb_bytes(sb, name_ptr, name_len)
            } E {
                tc_sb_cstr(sb, "Type")
            }
        }
        E {
            tc_sb_cstr(sb, "<unknown-kind-")
            tc_sb_i64(sb, kind)
            tc_sb_cstr(sb, ">")
        }

        1
    }

    # Get the data pointer and length from a format_type sb result
    F type_sb_data(&self, sb: i64) -> i64 = load_i64(sb)
    F type_sb_len(&self, sb: i64) -> i64 = load_i64(sb + 8)

    # Free a sb allocated by format_type
    F type_sb_free(&self, sb: i64) -> i64 {
        free(load_i64(sb))
        free(sb)
        1
    }

    # ========== Error Printing ==========

    # Print all type errors to stdout
    F print_errors(&self) -> i64 {
        i: mut i64 = 0
        L { I i >= self.errors_len { B }
            err_ptr := self.errors_ptr + i * TypeError.size()
            err_kind := load_i64(err_ptr)
            err_span_start := load_i64(err_ptr + 8)
            err_span_end := load_i64(err_ptr + 16)
            err_expected := load_i64(err_ptr + 24)
            err_found := load_i64(err_ptr + 32)
            err_name := load_i64(err_ptr + 40)

            sb := tc_sb_new()

            I err_kind == ERR_MISMATCH() {
                tc_sb_cstr(sb, "error: Type mismatch: expected ")
                I err_expected != 0 {
                    # err_expected is an sb pointer from format_type
                    exp_data := load_i64(err_expected)
                    exp_len := load_i64(err_expected + 8)
                    tc_sb_bytes(sb, exp_data, exp_len)
                } E {
                    tc_sb_cstr(sb, "?")
                }
                tc_sb_cstr(sb, ", found ")
                I err_found != 0 {
                    found_data := load_i64(err_found)
                    found_len := load_i64(err_found + 8)
                    tc_sb_bytes(sb, found_data, found_len)
                } E {
                    tc_sb_cstr(sb, "?")
                }
                0
            }
            E I err_kind == ERR_UNDEFINED_VAR() {
                tc_sb_cstr(sb, "error: Undefined variable")
                I self.sp_data != 0 && err_name >= 0 && err_name < self.sp_count {
                    tc_sb_cstr(sb, ": ")
                    name_ptr := @.get_string_ptr(err_name)
                    name_len := @.get_string_len(err_name)
                    tc_sb_bytes(sb, name_ptr, name_len)
                } E { 0 }
                0
            }
            E I err_kind == ERR_UNDEFINED_TYPE() {
                tc_sb_cstr(sb, "error: Undefined type")
                I self.sp_data != 0 && err_name >= 0 && err_name < self.sp_count {
                    tc_sb_cstr(sb, ": ")
                    name_ptr := @.get_string_ptr(err_name)
                    name_len := @.get_string_len(err_name)
                    tc_sb_bytes(sb, name_ptr, name_len)
                } E { 0 }
                0
            }
            E I err_kind == ERR_UNDEFINED_FUNC() {
                tc_sb_cstr(sb, "error: Undefined function")
                I self.sp_data != 0 && err_name >= 0 && err_name < self.sp_count {
                    tc_sb_cstr(sb, ": ")
                    name_ptr := @.get_string_ptr(err_name)
                    name_len := @.get_string_len(err_name)
                    tc_sb_bytes(sb, name_ptr, name_len)
                } E { 0 }
                0
            }
            E I err_kind == ERR_NOT_CALLABLE() {
                tc_sb_cstr(sb, "error: Cannot call non-function type")
                0
            }
            E I err_kind == ERR_ARG_COUNT() {
                tc_sb_cstr(sb, "error: Wrong argument count: expected ")
                tc_sb_i64(sb, err_expected)
                tc_sb_cstr(sb, ", got ")
                tc_sb_i64(sb, err_found)
                0
            }
            E I err_kind == ERR_IMMUTABLE_ASSIGN() {
                tc_sb_cstr(sb, "error: Cannot assign to immutable variable")
                I self.sp_data != 0 && err_name >= 0 && err_name < self.sp_count {
                    tc_sb_cstr(sb, ": ")
                    name_ptr := @.get_string_ptr(err_name)
                    name_len := @.get_string_len(err_name)
                    tc_sb_bytes(sb, name_ptr, name_len)
                } E { 0 }
                0
            }
            E I err_kind == ERR_CANNOT_INFER() {
                tc_sb_cstr(sb, "error: Cannot infer type")
                0
            }
            E I err_kind == ERR_DUPLICATE() {
                tc_sb_cstr(sb, "error: Duplicate definition")
                I self.sp_data != 0 && err_name >= 0 && err_name < self.sp_count {
                    tc_sb_cstr(sb, ": ")
                    name_ptr := @.get_string_ptr(err_name)
                    name_len := @.get_string_len(err_name)
                    tc_sb_bytes(sb, name_ptr, name_len)
                } E { 0 }
                0
            }
            E {
                tc_sb_cstr(sb, "error: Unknown error kind ")
                tc_sb_i64(sb, err_kind)
                0
            }

            # Append span information
            tc_sb_cstr(sb, " at ")
            tc_sb_i64(sb, err_span_start)
            tc_sb_byte(sb, 45)  # '-'
            tc_sb_i64(sb, err_span_end)

            # Null-terminate and print
            tc_sb_byte(sb, 0)
            data := load_i64(sb)
            puts_ptr(data)

            # Free the sb
            free(data)
            free(sb)

            i = i + 1
        }
        self.errors_len
    }

    # ========== Type Resolution ==========

    F resolve_type_node(&self, type_node_ptr: i64) -> i64 {
        I type_node_ptr == 0 {
            # Return unit type for missing type annotation
            type_ptr := malloc(ResolvedType.size())
            ty := ResolvedType.unit_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        } E {
            kind := load_i64(type_node_ptr)

            # TYPE_NAMED = 60
            I kind == 60 {
                name_idx := load_i64(type_node_ptr + 24)  # field0
                generics_ptr := load_i64(type_node_ptr + 32)  # field1
                generics_len := load_i64(type_node_ptr + 40)  # field2
                @.resolve_named_type_with_generics(name_idx, generics_ptr, generics_len)
            }
            # TYPE_ARRAY = 61
            E I kind == 61 {
                inner_ptr := load_i64(type_node_ptr + 24)
                inner_resolved := @.resolve_type_node(inner_ptr)
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.array_type(inner_resolved)
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # TYPE_OPTIONAL = 64
            E I kind == 64 {
                inner_ptr := load_i64(type_node_ptr + 24)
                inner_resolved := @.resolve_type_node(inner_ptr)
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.optional_type(inner_resolved)
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # TYPE_POINTER = 66
            E I kind == 66 {
                inner_ptr := load_i64(type_node_ptr + 24)
                inner_resolved := @.resolve_type_node(inner_ptr)
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.pointer_type(inner_resolved)
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # TYPE_UNIT = 70
            E I kind == 70 {
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.unit_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # TYPE_INFER = 71
            E I kind == 71 {
                @.fresh_type_var()
            }
            E {
                # Unknown type node kind - return unknown
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.unknown_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
        }
    }

    F resolve_named_type(&self, name_idx: i64) -> i64 {
        type_ptr := malloc(ResolvedType.size())

        # Check for built-in types by comparing strings
        # We need to compare the actual string content
        name_ptr := @.get_string_ptr(name_idx)
        name_len := @.get_string_len(name_idx)

        # Check for "i64"
        I name_len == 3 && load_byte(name_ptr) == 105 &&
           load_byte(name_ptr + 1) == 54 && load_byte(name_ptr + 2) == 52 {
            ty := ResolvedType.i64_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        }
        # Check for "i32"
        E I name_len == 3 && load_byte(name_ptr) == 105 &&
             load_byte(name_ptr + 1) == 51 && load_byte(name_ptr + 2) == 50 {
            ty := ResolvedType.i32_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        }
        # Check for "bool"
        E I name_len == 4 && load_byte(name_ptr) == 98 &&
             load_byte(name_ptr + 1) == 111 && load_byte(name_ptr + 2) == 111 &&
             load_byte(name_ptr + 3) == 108 {
            ty := ResolvedType.bool_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        }
        # Check for "str" or "Str"
        E I name_len == 3 && (load_byte(name_ptr) == 115 || load_byte(name_ptr) == 83) &&
             load_byte(name_ptr + 1) == 116 && load_byte(name_ptr + 2) == 114 {
            ty := ResolvedType.str_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        }
        # Check for "f64"
        E I name_len == 3 && load_byte(name_ptr) == 102 &&
             load_byte(name_ptr + 1) == 54 && load_byte(name_ptr + 2) == 52 {
            ty := ResolvedType.f64_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        }
        # Check for "f32"
        E I name_len == 3 && load_byte(name_ptr) == 102 &&
             load_byte(name_ptr + 1) == 51 && load_byte(name_ptr + 2) == 50 {
            ty := ResolvedType.f32_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        }
        E {
            # Check if it's a known struct or enum
            struct_ptr := @.find_struct(name_idx)
            I struct_ptr != 0 {
                ty := ResolvedType.named_type(name_idx, 0, 0)
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            } E {
                enum_ptr := @.find_enum(name_idx)
                I enum_ptr != 0 {
                    ty := ResolvedType.named_type(name_idx, 0, 0)
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                } E {
                    # Check if it's a generic type parameter
                    I @.is_generic_param(name_idx) == 1 {
                        ty := ResolvedType.generic_type(name_idx)
                        store_i64(type_ptr, ty.kind)
                        store_i64(type_ptr + 8, ty.field0)
                        store_i64(type_ptr + 16, ty.field1)
                        store_i64(type_ptr + 24, ty.field2)
                        type_ptr
                    } E {
                        # Unknown type
                        ty := ResolvedType.unknown_type()
                        store_i64(type_ptr, ty.kind)
                        store_i64(type_ptr + 8, ty.field0)
                        store_i64(type_ptr + 16, ty.field1)
                        store_i64(type_ptr + 24, ty.field2)
                        type_ptr
                    }
                }
            }
        }
    }

    # Resolve a named type with generic type arguments
    # generics_ptr: array of TypeNode pointers (type arguments from parsing)
    # generics_len: count of type arguments
    F resolve_named_type_with_generics(&self, name_idx: i64, generics_ptr: i64, generics_len: i64) -> i64 {
        # First resolve as a base type
        base_type := @.resolve_named_type(name_idx)
        base_kind := load_i64(base_type)

        # If no generics provided or not a named type, return as-is
        I generics_len == 0 || base_kind != TY_NAMED() {
            R base_type
        }

        # Resolve each type argument
        resolved_gens := malloc(generics_len * 8)
        i: mut i64 = 0
        L { I i >= generics_len { B }
            type_node_ptr := load_i64(generics_ptr + i * 8)
            resolved := @.resolve_type_node(type_node_ptr)
            store_i64(resolved_gens + i * 8, resolved)
            i = i + 1
        }

        # Create a new named type with resolved generic arguments
        result := malloc(ResolvedType.size())
        store_i64(result, TY_NAMED())
        store_i64(result + 8, name_idx)
        store_i64(result + 16, resolved_gens)
        store_i64(result + 24, generics_len)
        result
    }

    F is_generic_param(&self, name_idx: i64) -> i64 {
        I self.current_generics_ptr == 0 { R 0 }
        i: mut i64 = 0
        L { I i >= self.current_generics_len { B }
            param_idx := load_i64(self.current_generics_ptr + i * 8)
            I param_idx == name_idx { R 1 }
            E { i = i + 1 }
        }
        0
    }

    F fresh_type_var(&self) -> i64 {
        var_id := self.next_type_var
        self.next_type_var = self.next_type_var + 1

        type_ptr := malloc(ResolvedType.size())
        ty := ResolvedType.var_type(var_id)
        store_i64(type_ptr, ty.kind)
        store_i64(type_ptr + 8, ty.field0)
        store_i64(type_ptr + 16, ty.field1)
        store_i64(type_ptr + 24, ty.field2)
        type_ptr
    }

    # ========== Substitution Map Management ==========

    F add_substitution(&self, var_id: i64, type_ptr: i64) -> i64 {
        # Check if already exists, update if so
        i: mut i64 = 0
        L { I i >= self.subst_len { B }
            key := load_i64(self.subst_keys_ptr + i * 8)
            I key == var_id {
                store_i64(self.subst_values_ptr + i * 8, type_ptr)
                R 1
            }
            i = i + 1
        }

        # Expand capacity if needed
        I self.subst_len >= self.subst_cap {
            new_cap := self.subst_cap * 2
            new_keys := malloc(new_cap * 8)
            new_values := malloc(new_cap * 8)
            memcpy(new_keys, self.subst_keys_ptr, self.subst_len * 8)
            memcpy(new_values, self.subst_values_ptr, self.subst_len * 8)
            free(self.subst_keys_ptr)
            free(self.subst_values_ptr)
            self.subst_keys_ptr = new_keys
            self.subst_values_ptr = new_values
            self.subst_cap = new_cap
            0
        } E { 0 }

        # Add new substitution
        store_i64(self.subst_keys_ptr + self.subst_len * 8, var_id)
        store_i64(self.subst_values_ptr + self.subst_len * 8, type_ptr)
        self.subst_len = self.subst_len + 1
        1
    }

    F get_substitution(&self, var_id: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.subst_len { B }
            key := load_i64(self.subst_keys_ptr + i * 8)
            I key == var_id {
                R load_i64(self.subst_values_ptr + i * 8)
            }
            i = i + 1
        }
        0  # Not found
    }

    F clear_substitutions(&self) -> i64 {
        self.subst_len = 0
        1
    }

    # ========== Generic Binding Management ==========

    # Add a generic parameter binding (T -> i64, etc.)
    F add_generic_binding(&self, name_idx: i64, type_ptr: i64) -> i64 {
        # Check if already exists, update if so
        i: mut i64 = 0
        L { I i >= self.generic_bind_len { B }
            key := load_i64(self.generic_bind_keys_ptr + i * 8)
            I key == name_idx {
                store_i64(self.generic_bind_values_ptr + i * 8, type_ptr)
                R 1
            }
            i = i + 1
        }

        # Expand capacity if needed
        I self.generic_bind_len >= self.generic_bind_cap {
            new_cap := self.generic_bind_cap * 2
            new_keys := malloc(new_cap * 8)
            new_values := malloc(new_cap * 8)
            memcpy(new_keys, self.generic_bind_keys_ptr, self.generic_bind_len * 8)
            memcpy(new_values, self.generic_bind_values_ptr, self.generic_bind_len * 8)
            free(self.generic_bind_keys_ptr)
            free(self.generic_bind_values_ptr)
            self.generic_bind_keys_ptr = new_keys
            self.generic_bind_values_ptr = new_values
            self.generic_bind_cap = new_cap
            0
        } E { 0 }

        # Add new binding
        store_i64(self.generic_bind_keys_ptr + self.generic_bind_len * 8, name_idx)
        store_i64(self.generic_bind_values_ptr + self.generic_bind_len * 8, type_ptr)
        self.generic_bind_len = self.generic_bind_len + 1
        1
    }

    # Get a generic parameter binding
    F get_generic_binding(&self, name_idx: i64) -> i64 {
        i: mut i64 = 0
        L { I i >= self.generic_bind_len { B }
            key := load_i64(self.generic_bind_keys_ptr + i * 8)
            I key == name_idx {
                R load_i64(self.generic_bind_values_ptr + i * 8)
            }
            i = i + 1
        }
        0  # Not found
    }

    # Clear all generic bindings
    F clear_generic_bindings(&self) -> i64 {
        self.generic_bind_len = 0
        1
    }

    # Bind generic parameters from a function signature to type arguments
    # generics_ptr: array of name_idx (generic param names)
    # generics_len: count of generic params
    # type_args_ptr: array of type_ptr (resolved type arguments)
    # type_args_len: count of type arguments
    F bind_generics(&self, generics_ptr: i64, generics_len: i64, type_args_ptr: i64, type_args_len: i64) -> i64 {
        @.clear_generic_bindings()

        # Only bind up to the minimum of both
        count := I generics_len < type_args_len { generics_len } E { type_args_len }

        i: mut i64 = 0
        L { I i >= count { B }
            name_idx := load_i64(generics_ptr + i * 8)
            type_ptr := load_i64(type_args_ptr + i * 8)
            @.add_generic_binding(name_idx, type_ptr)
            i = i + 1
        }
        1
    }

    # Infer generic bindings by comparing a parameter type with an argument type
    # If param_type is TY_GENERIC, bind it to arg_type
    # If param_type is a compound type, recursively infer from inner types
    F infer_generic_from_types(&self, param_type: i64, arg_type: i64) -> i64 {
        I param_type == 0 || arg_type == 0 { R 0 }

        param_kind := load_i64(param_type)
        arg_kind := load_i64(arg_type)

        # If parameter is a generic type, bind it to the argument type
        I param_kind == TY_GENERIC() {
            name_idx := load_i64(param_type + 8)
            # Only bind if not already bound
            existing := @.get_generic_binding(name_idx)
            I existing == 0 {
                @.add_generic_binding(name_idx, arg_type)
                0
            } E { 0 }
            R 1
        }

        # If parameter is a type variable, use unification
        I param_kind == TY_VAR() {
            @.unify(param_type, arg_type)
            R 1
        }

        # For compound types, recursively infer from inner types
        # Array/Optional/Result/Pointer/Ref - infer from inner type
        I param_kind == TY_ARRAY() || param_kind == TY_OPTIONAL() ||
           param_kind == TY_RESULT() || param_kind == TY_POINTER() ||
           param_kind == TY_REF() || param_kind == TY_REF_MUT() {
            I arg_kind == param_kind {
                param_inner := load_i64(param_type + 8)
                arg_inner := load_i64(arg_type + 8)
                @.infer_generic_from_types(param_inner, arg_inner)
            } E { 0 }
            R 1
        }

        # Function type - infer from params and return
        I param_kind == TY_FN() && arg_kind == TY_FN() {
            param_params := load_i64(param_type + 8)
            param_len := load_i64(param_type + 16)
            param_ret := load_i64(param_type + 24)
            arg_params := load_i64(arg_type + 8)
            arg_len := load_i64(arg_type + 16)
            arg_ret := load_i64(arg_type + 24)

            I param_len == arg_len {
                j: mut i64 = 0
                L { I j >= param_len { B }
                    pp := load_i64(param_params + j * 8)
                    ap := load_i64(arg_params + j * 8)
                    @.infer_generic_from_types(pp, ap)
                    j = j + 1
                }
                @.infer_generic_from_types(param_ret, arg_ret)
                0
            } E { 0 }
            R 1
        }

        # Named type with generics - infer from type arguments
        I param_kind == TY_NAMED() && arg_kind == TY_NAMED() {
            param_name := load_i64(param_type + 8)
            arg_name := load_i64(arg_type + 8)

            I param_name == arg_name {
                param_gens := load_i64(param_type + 16)
                param_gen_len := load_i64(param_type + 24)
                arg_gens := load_i64(arg_type + 16)
                arg_gen_len := load_i64(arg_type + 24)

                I param_gen_len == arg_gen_len {
                    k: mut i64 = 0
                    L { I k >= param_gen_len { B }
                        pg := load_i64(param_gens + k * 8)
                        ag := load_i64(arg_gens + k * 8)
                        @.infer_generic_from_types(pg, ag)
                        k = k + 1
                    }
                    0
                } E { 0 }
                0
            } E { 0 }
            R 1
        }

        0
    }

    # Instantiate a type by replacing all TY_GENERIC with bound types
    F instantiate_type(&self, type_ptr: i64) -> i64 {
        I type_ptr == 0 { R 0 }

        kind := load_i64(type_ptr)

        # Generic type parameter - look up binding
        I kind == TY_GENERIC() {
            name_idx := load_i64(type_ptr + 8)
            bound := @.get_generic_binding(name_idx)
            I bound != 0 {
                # Return the bound type (recursively instantiate in case of nested generics)
                R @.instantiate_type(bound)
            } E {
                # No binding found - return as-is
                R type_ptr
            }
        }
        # Array type - instantiate inner
        E I kind == TY_ARRAY() {
            inner_ptr := load_i64(type_ptr + 8)
            new_inner := @.instantiate_type(inner_ptr)
            I new_inner != inner_ptr {
                result := malloc(ResolvedType.size())
                store_i64(result, TY_ARRAY())
                store_i64(result + 8, new_inner)
                store_i64(result + 16, 0)
                store_i64(result + 24, 0)
                result
            } E {
                type_ptr
            }
        }
        # Optional type - instantiate inner
        E I kind == TY_OPTIONAL() {
            inner_ptr := load_i64(type_ptr + 8)
            new_inner := @.instantiate_type(inner_ptr)
            I new_inner != inner_ptr {
                result := malloc(ResolvedType.size())
                store_i64(result, TY_OPTIONAL())
                store_i64(result + 8, new_inner)
                store_i64(result + 16, 0)
                store_i64(result + 24, 0)
                result
            } E {
                type_ptr
            }
        }
        # Result type - instantiate inner
        E I kind == TY_RESULT() {
            inner_ptr := load_i64(type_ptr + 8)
            new_inner := @.instantiate_type(inner_ptr)
            I new_inner != inner_ptr {
                result := malloc(ResolvedType.size())
                store_i64(result, TY_RESULT())
                store_i64(result + 8, new_inner)
                store_i64(result + 16, 0)
                store_i64(result + 24, 0)
                result
            } E {
                type_ptr
            }
        }
        # Ref/RefMut/Pointer - instantiate inner
        E I kind == TY_REF() || kind == TY_REF_MUT() || kind == TY_POINTER() {
            inner_ptr := load_i64(type_ptr + 8)
            new_inner := @.instantiate_type(inner_ptr)
            I new_inner != inner_ptr {
                result := malloc(ResolvedType.size())
                store_i64(result, kind)
                store_i64(result + 8, new_inner)
                store_i64(result + 16, 0)
                store_i64(result + 24, 0)
                result
            } E {
                type_ptr
            }
        }
        # Function type - instantiate params and return
        E I kind == TY_FN() {
            params_ptr := load_i64(type_ptr + 8)
            params_len := load_i64(type_ptr + 16)
            ret_ptr := load_i64(type_ptr + 24)

            new_ret := @.instantiate_type(ret_ptr)

            # Check if any params changed
            changed: mut i64 = 0
            I new_ret != ret_ptr { changed = 1 } E { 0 }

            j: mut i64 = 0
            L { I j >= params_len { B }
                param_ty := load_i64(params_ptr + j * 8)
                new_param := @.instantiate_type(param_ty)
                I new_param != param_ty { changed = 1 } E { 0 }
                j = j + 1
            }

            I changed == 1 {
                new_params := malloc(params_len * 8)
                k: mut i64 = 0
                L { I k >= params_len { B }
                    param_ty := load_i64(params_ptr + k * 8)
                    store_i64(new_params + k * 8, @.instantiate_type(param_ty))
                    k = k + 1
                }
                result := malloc(ResolvedType.size())
                store_i64(result, TY_FN())
                store_i64(result + 8, new_params)
                store_i64(result + 16, params_len)
                store_i64(result + 24, new_ret)
                result
            } E {
                type_ptr
            }
        }
        # Named type with generics - instantiate type arguments
        E I kind == TY_NAMED() {
            name_idx := load_i64(type_ptr + 8)
            generics_ptr := load_i64(type_ptr + 16)
            generics_len := load_i64(type_ptr + 24)

            I generics_len == 0 {
                # No generics to instantiate
                R type_ptr
            }

            # Instantiate each generic argument
            changed: mut i64 = 0
            j: mut i64 = 0
            L { I j >= generics_len { B }
                gen_ty := load_i64(generics_ptr + j * 8)
                new_gen := @.instantiate_type(gen_ty)
                I new_gen != gen_ty { changed = 1 } E { 0 }
                j = j + 1
            }

            I changed == 1 {
                new_gens := malloc(generics_len * 8)
                k: mut i64 = 0
                L { I k >= generics_len { B }
                    gen_ty := load_i64(generics_ptr + k * 8)
                    store_i64(new_gens + k * 8, @.instantiate_type(gen_ty))
                    k = k + 1
                }
                result := malloc(ResolvedType.size())
                store_i64(result, TY_NAMED())
                store_i64(result + 8, name_idx)
                store_i64(result + 16, new_gens)
                store_i64(result + 24, generics_len)
                result
            } E {
                type_ptr
            }
        }
        E {
            # Other types (primitives, etc.) - return as-is
            type_ptr
        }
    }

    # ========== Type Application and Unification ==========

    F apply_substitutions(&self, type_ptr: i64) -> i64 {
        I type_ptr == 0 { R 0 }

        kind := load_i64(type_ptr)

        # Type variable - check for substitution
        I kind == TY_VAR() {
            var_id := load_i64(type_ptr + 8)
            subst := @.get_substitution(var_id)
            I subst != 0 {
                # Recursively apply substitutions
                R @.apply_substitutions(subst)
            } E {
                R type_ptr
            }
        }
        # Array type - apply to inner
        E I kind == TY_ARRAY() {
            inner_ptr := load_i64(type_ptr + 8)
            new_inner := @.apply_substitutions(inner_ptr)
            I new_inner != inner_ptr {
                result := malloc(ResolvedType.size())
                store_i64(result, TY_ARRAY())
                store_i64(result + 8, new_inner)
                store_i64(result + 16, 0)
                store_i64(result + 24, 0)
                result
            } E {
                type_ptr
            }
        }
        # Optional type - apply to inner
        E I kind == TY_OPTIONAL() {
            inner_ptr := load_i64(type_ptr + 8)
            new_inner := @.apply_substitutions(inner_ptr)
            I new_inner != inner_ptr {
                result := malloc(ResolvedType.size())
                store_i64(result, TY_OPTIONAL())
                store_i64(result + 8, new_inner)
                store_i64(result + 16, 0)
                store_i64(result + 24, 0)
                result
            } E {
                type_ptr
            }
        }
        # Result type - apply to inner
        E I kind == TY_RESULT() {
            inner_ptr := load_i64(type_ptr + 8)
            new_inner := @.apply_substitutions(inner_ptr)
            I new_inner != inner_ptr {
                result := malloc(ResolvedType.size())
                store_i64(result, TY_RESULT())
                store_i64(result + 8, new_inner)
                store_i64(result + 16, 0)
                store_i64(result + 24, 0)
                result
            } E {
                type_ptr
            }
        }
        # Ref/RefMut/Pointer - apply to inner
        E I kind == TY_REF() || kind == TY_REF_MUT() || kind == TY_POINTER() {
            inner_ptr := load_i64(type_ptr + 8)
            new_inner := @.apply_substitutions(inner_ptr)
            I new_inner != inner_ptr {
                result := malloc(ResolvedType.size())
                store_i64(result, kind)
                store_i64(result + 8, new_inner)
                store_i64(result + 16, 0)
                store_i64(result + 24, 0)
                result
            } E {
                type_ptr
            }
        }
        # Function type - apply to params and return
        E I kind == TY_FN() {
            params_ptr := load_i64(type_ptr + 8)
            params_len := load_i64(type_ptr + 16)
            ret_ptr := load_i64(type_ptr + 24)

            new_ret := @.apply_substitutions(ret_ptr)

            # Apply to each parameter
            changed: mut i64 = 0
            I new_ret != ret_ptr { changed = 1 } E { 0 }

            # Check if any params changed
            j: mut i64 = 0
            L { I j >= params_len { B }
                param_ty := load_i64(params_ptr + j * 8)
                new_param := @.apply_substitutions(param_ty)
                I new_param != param_ty { changed = 1 } E { 0 }
                j = j + 1
            }

            I changed == 1 {
                new_params := malloc(params_len * 8)
                k: mut i64 = 0
                L { I k >= params_len { B }
                    param_ty := load_i64(params_ptr + k * 8)
                    store_i64(new_params + k * 8, @.apply_substitutions(param_ty))
                    k = k + 1
                }
                result := malloc(ResolvedType.size())
                store_i64(result, TY_FN())
                store_i64(result + 8, new_params)
                store_i64(result + 16, params_len)
                store_i64(result + 24, new_ret)
                result
            } E {
                type_ptr
            }
        }
        # Generic type - also check generic bindings
        E I kind == TY_GENERIC() {
            name_idx := load_i64(type_ptr + 8)
            bound := @.get_generic_binding(name_idx)
            I bound != 0 {
                R @.apply_substitutions(bound)
            } E {
                type_ptr
            }
        }
        # Named type with generics - apply to type arguments
        E I kind == TY_NAMED() {
            name_idx := load_i64(type_ptr + 8)
            generics_ptr := load_i64(type_ptr + 16)
            generics_len := load_i64(type_ptr + 24)

            I generics_len == 0 {
                R type_ptr
            }

            changed: mut i64 = 0
            m: mut i64 = 0
            L { I m >= generics_len { B }
                gen_ty := load_i64(generics_ptr + m * 8)
                new_gen := @.apply_substitutions(gen_ty)
                I new_gen != gen_ty { changed = 1 } E { 0 }
                m = m + 1
            }

            I changed == 1 {
                new_gens := malloc(generics_len * 8)
                n: mut i64 = 0
                L { I n >= generics_len { B }
                    gen_ty := load_i64(generics_ptr + n * 8)
                    store_i64(new_gens + n * 8, @.apply_substitutions(gen_ty))
                    n = n + 1
                }
                result := malloc(ResolvedType.size())
                store_i64(result, TY_NAMED())
                store_i64(result + 8, name_idx)
                store_i64(result + 16, new_gens)
                store_i64(result + 24, generics_len)
                result
            } E {
                type_ptr
            }
        }
        E {
            type_ptr
        }
    }

    # Unify two types - returns 1 on success, 0 on failure
    F unify(&self, expected_ptr: i64, found_ptr: i64) -> i64 {
        # Apply existing substitutions first
        expected := @.apply_substitutions(expected_ptr)
        found := @.apply_substitutions(found_ptr)

        exp_kind := load_i64(expected)
        found_kind := load_i64(found)

        # Same pointer means same type
        I expected == found { R 1 }

        # Unknown type unifies with anything
        I exp_kind == TY_UNKNOWN() || found_kind == TY_UNKNOWN() { R 1 }

        # Never type unifies with anything (non-returning expressions)
        I exp_kind == TY_NEVER() || found_kind == TY_NEVER() { R 1 }

        # Generic type parameters match with any type (type erasure)
        I exp_kind == TY_GENERIC() || found_kind == TY_GENERIC() { R 1 }

        # dyn Trait unifies with any type that implements the trait
        I exp_kind == TY_DYN_TRAIT() {
            trait_idx := load_i64(expected + 8)
            I found_kind == TY_NAMED() {
                type_idx := load_i64(found + 8)
                I @.type_implements_trait(type_idx, trait_idx) == 1 { R 1 }
                E { R 0 }
            } E I found_kind == TY_DYN_TRAIT() {
                # Same trait object type
                found_trait := load_i64(found + 8)
                I trait_idx == found_trait { R 1 } E { R 0 }
            }
            R 0
        }
        I found_kind == TY_DYN_TRAIT() {
            trait_idx := load_i64(found + 8)
            I exp_kind == TY_NAMED() {
                type_idx := load_i64(expected + 8)
                I @.type_implements_trait(type_idx, trait_idx) == 1 { R 1 }
                E { R 0 }
            }
            R 0
        }

        # Associated type - try to resolve
        I exp_kind == TY_ASSOC() || found_kind == TY_ASSOC() { R 1 }

        # Type variable - bind to the other type
        I exp_kind == TY_VAR() {
            var_id := load_i64(expected + 8)
            @.add_substitution(var_id, found)
            R 1
        }
        I found_kind == TY_VAR() {
            var_id := load_i64(found + 8)
            @.add_substitution(var_id, expected)
            R 1
        }

        # Different kinds
        I exp_kind != found_kind { R 0 }

        # Primitive types - kinds already match
        I exp_kind <= TY_UNIT() { R 1 }

        # Array/Optional/Result/Pointer/Ref - unify inner types
        I exp_kind == TY_ARRAY() || exp_kind == TY_OPTIONAL() ||
           exp_kind == TY_RESULT() || exp_kind == TY_POINTER() ||
           exp_kind == TY_REF() || exp_kind == TY_REF_MUT() {
            exp_inner := load_i64(expected + 8)
            found_inner := load_i64(found + 8)
            R @.unify(exp_inner, found_inner)
        }

        # Map type
        I exp_kind == TY_MAP() {
            exp_key := load_i64(expected + 8)
            exp_val := load_i64(expected + 16)
            found_key := load_i64(found + 8)
            found_val := load_i64(found + 16)
            I @.unify(exp_key, found_key) == 0 { R 0 }
            R @.unify(exp_val, found_val)
        }

        # Tuple type
        I exp_kind == TY_TUPLE() {
            exp_types := load_i64(expected + 8)
            exp_len := load_i64(expected + 16)
            found_types := load_i64(found + 8)
            found_len := load_i64(found + 16)

            I exp_len != found_len { R 0 }

            i: mut i64 = 0
            L { I i >= exp_len { B }
                et := load_i64(exp_types + i * 8)
                ft := load_i64(found_types + i * 8)
                I @.unify(et, ft) == 0 { R 0 }
                i = i + 1
            }
            1
        }

        # Function type
        I exp_kind == TY_FN() {
            exp_params := load_i64(expected + 8)
            exp_params_len := load_i64(expected + 16)
            exp_ret := load_i64(expected + 24)
            found_params := load_i64(found + 8)
            found_params_len := load_i64(found + 16)
            found_ret := load_i64(found + 24)

            I exp_params_len != found_params_len { R 0 }

            i: mut i64 = 0
            L { I i >= exp_params_len { B }
                ep := load_i64(exp_params + i * 8)
                fp := load_i64(found_params + i * 8)
                I @.unify(ep, fp) == 0 { R 0 }
                i = i + 1
            }
            R @.unify(exp_ret, found_ret)
        }

        # Named type
        I exp_kind == TY_NAMED() {
            exp_name := load_i64(expected + 8)
            found_name := load_i64(found + 8)
            I exp_name != found_name { R 0 }

            exp_generics := load_i64(expected + 16)
            exp_gen_len := load_i64(expected + 24)
            found_generics := load_i64(found + 16)
            found_gen_len := load_i64(found + 24)

            I exp_gen_len != found_gen_len { R 0 }

            i: mut i64 = 0
            L { I i >= exp_gen_len { B }
                eg := load_i64(exp_generics + i * 8)
                fg := load_i64(found_generics + i * 8)
                I @.unify(eg, fg) == 0 { R 0 }
                i = i + 1
            }
            1
        }

        # Default: fail
        0
    }

    # ========== Bidirectional Type Checking ==========

    # Check an expression with bidirectional type checking
    # mode = 0 (MODE_INFER): bottom-up inference
    # mode = 1 (MODE_CHECK): top-down checking with expected_type_ptr
    F check_expr_bidirectional(&self, expr_ptr: i64, mode: i64, expected_type_ptr: i64) -> i64 {
        I mode == MODE_INFER() {
            R @.check_expr(expr_ptr)
        }

        # MODE_CHECK - we have an expected type
        I expr_ptr == 0 {
            R expected_type_ptr
        }

        kind := load_i64(expr_ptr)

        # Lambda expression - use expected type to infer parameter types
        # EXPR_LAMBDA = 29
        I kind == 29 {
            R @.check_lambda_with_expected(expr_ptr, expected_type_ptr)
        }
        # Array literal - propagate element type
        # EXPR_ARRAY = 39
        E I kind == 39 {
            R @.check_array_with_expected(expr_ptr, expected_type_ptr)
        }
        # For other expressions: infer then unify
        E {
            inferred := @.check_expr(expr_ptr)
            I @.unify(expected_type_ptr, inferred) == 1 {
                inferred
            } E {
                # Type mismatch - report error with actual type info
                span_start := load_i64(expr_ptr + 8)
                span_end := load_i64(expr_ptr + 16)
                exp_sb := @.format_type(expected_type_ptr)
                found_sb := @.format_type(inferred)
                err := TypeError.mismatch(exp_sb, found_sb, span_start, span_end)
                err_ptr := malloc(TypeError.size())
                store_i64(err_ptr, err.kind)
                store_i64(err_ptr + 8, err.span_start)
                store_i64(err_ptr + 16, err.span_end)
                store_i64(err_ptr + 24, err.expected_idx)
                store_i64(err_ptr + 32, err.found_idx)
                store_i64(err_ptr + 40, err.name_idx)
                @.add_error(err_ptr)
                inferred
            }
        }
    }

    # Check lambda with expected function type
    F check_lambda_with_expected(&self, expr_ptr: i64, expected_ptr: i64) -> i64 {
        params_ptr := load_i64(expr_ptr + 24)   # field0: params array
        params_len := load_i64(expr_ptr + 32)   # field1: params length
        body_ptr := load_i64(expr_ptr + 40)     # field2: body expression

        # Extract expected parameter types if available
        exp_kind := load_i64(expected_ptr)
        exp_params_ptr: mut i64 = 0
        exp_params_len: mut i64 = 0
        exp_ret_ptr: mut i64 = 0

        I exp_kind == TY_FN() {
            exp_params_ptr = load_i64(expected_ptr + 8)
            exp_params_len = load_i64(expected_ptr + 16)
            exp_ret_ptr = load_i64(expected_ptr + 24)
            0
        } E { 0 }

        # Push scope for lambda parameters
        @.push_scope()

        # Allocate space for parameter types
        param_types := malloc(params_len * 8)

        # Process each parameter
        i: mut i64 = 0
        L { I i >= params_len { B }
            param_ptr := params_ptr + i * 40  # Param.size() = 40
            param_name := load_i64(param_ptr)
            param_type_ptr := load_i64(param_ptr + 8)
            param_is_mut := load_i64(param_ptr + 16)

            # Determine parameter type: use expected if available, else infer
            param_ty := I exp_params_ptr != 0 && i < exp_params_len {
                load_i64(exp_params_ptr + i * 8)
            } E I param_type_ptr != 0 {
                @.resolve_type_node(param_type_ptr)
            } E {
                @.fresh_type_var()
            }

            store_i64(param_types + i * 8, param_ty)
            @.add_var(param_name, param_ty, param_is_mut)
            i = i + 1
        }

        # Check body with expected return type if available
        body_ty := I exp_ret_ptr != 0 {
            @.check_expr_bidirectional(body_ptr, MODE_CHECK(), exp_ret_ptr)
        } E {
            @.check_expr(body_ptr)
        }

        @.pop_scope()

        # Apply substitutions to finalize types
        j: mut i64 = 0
        L { I j >= params_len { B }
            old_ty := load_i64(param_types + j * 8)
            new_ty := @.apply_substitutions(old_ty)
            store_i64(param_types + j * 8, new_ty)
            j = j + 1
        }
        final_ret := @.apply_substitutions(body_ty)

        # Build function type
        result := malloc(ResolvedType.size())
        store_i64(result, TY_FN())
        store_i64(result + 8, param_types)
        store_i64(result + 16, params_len)
        store_i64(result + 24, final_ret)
        result
    }

    # Check array literal with expected element type
    F check_array_with_expected(&self, expr_ptr: i64, expected_ptr: i64) -> i64 {
        elements_ptr := load_i64(expr_ptr + 24)  # field0
        elements_len := load_i64(expr_ptr + 32)  # field1

        # Extract expected element type if available
        exp_kind := load_i64(expected_ptr)
        exp_elem_ptr: mut i64 = 0
        I exp_kind == TY_ARRAY() {
            exp_elem_ptr = load_i64(expected_ptr + 8)
            0
        } E { 0 }

        # Empty array
        I elements_len == 0 {
            elem_type := I exp_elem_ptr != 0 {
                exp_elem_ptr
            } E {
                @.fresh_type_var()
            }
            result := malloc(ResolvedType.size())
            store_i64(result, TY_ARRAY())
            store_i64(result + 8, elem_type)
            store_i64(result + 16, 0)
            store_i64(result + 24, 0)
            R result
        }

        # Check each element
        first_type: mut i64 = 0
        i: mut i64 = 0
        L { I i >= elements_len { B }
            elem_ptr := load_i64(elements_ptr + i * 8)
            elem_ty := I exp_elem_ptr != 0 {
                @.check_expr_bidirectional(elem_ptr, MODE_CHECK(), exp_elem_ptr)
            } E {
                @.check_expr(elem_ptr)
            }

            I i == 0 {
                first_type = elem_ty
            } E {
                # Unify with first element type
                @.unify(first_type, elem_ty)
                0
            }
            i = i + 1
        }

        final_elem := @.apply_substitutions(first_type)
        result := malloc(ResolvedType.size())
        store_i64(result, TY_ARRAY())
        store_i64(result + 8, final_elem)
        store_i64(result + 16, 0)
        store_i64(result + 24, 0)
        result
    }

    # ========== Type Checking ==========

    F check_expr(&self, expr_ptr: i64) -> i64 {
        I expr_ptr == 0 {
            type_ptr := malloc(ResolvedType.size())
            ty := ResolvedType.unit_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        } E {
            kind := load_i64(expr_ptr)
            span_start := load_i64(expr_ptr + 8)
            span_end := load_i64(expr_ptr + 16)

            # EXPR_INT = 20
            I kind == 20 {
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.i64_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # EXPR_FLOAT = 21
            E I kind == 21 {
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.f64_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # EXPR_BOOL = 22
            E I kind == 22 {
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.bool_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # EXPR_STRING = 23
            E I kind == 23 {
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.str_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # EXPR_UNIT = 24
            E I kind == 24 {
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.unit_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # EXPR_IDENT = 25
            E I kind == 25 {
                name_idx := load_i64(expr_ptr + 24)  # field0
                var_info := @.lookup_var(name_idx)
                I var_info != 0 {
                    load_i64(var_info)  # Return the type pointer
                } E {
                    # Check if it's a function name
                    fn_ptr := @.find_function(name_idx)
                    I fn_ptr != 0 {
                        # Return function type
                        ret_type_ptr := load_i64(fn_ptr + 40)  # ret_type_ptr field
                        ret_type_ptr
                    } E {
                        # Undefined variable error
                        err := TypeError.undefined_var(name_idx, span_start, span_end)
                        err_ptr := malloc(TypeError.size())
                        store_i64(err_ptr, err.kind)
                        store_i64(err_ptr + 8, err.span_start)
                        store_i64(err_ptr + 16, err.span_end)
                        store_i64(err_ptr + 24, err.expected_idx)
                        store_i64(err_ptr + 32, err.found_idx)
                        store_i64(err_ptr + 40, err.name_idx)
                        @.add_error(err_ptr)

                        type_ptr := malloc(ResolvedType.size())
                        ty := ResolvedType.unknown_type()
                        store_i64(type_ptr, ty.kind)
                        store_i64(type_ptr + 8, ty.field0)
                        store_i64(type_ptr + 16, ty.field1)
                        store_i64(type_ptr + 24, ty.field2)
                        type_ptr
                    }
                }
            }
            # EXPR_BINARY = 27
            E I kind == 27 {
                left_ptr := load_i64(expr_ptr + 24)   # field0
                right_ptr := load_i64(expr_ptr + 32)  # field1
                op := load_i64(expr_ptr + 40)         # field2

                left_ty := @.check_expr(left_ptr)
                right_ty := @.check_expr(right_ptr)

                # Comparison operators return bool
                I op >= 6 && op <= 11 {
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.bool_type()
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                }
                # Logical operators return bool
                E I op == 12 || op == 13 {
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.bool_type()
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                }
                # Arithmetic operators return left operand type
                E {
                    left_ty
                }
            }
            # EXPR_UNARY = 28
            E I kind == 28 {
                inner_ptr := load_i64(expr_ptr + 24)  # field0
                op := load_i64(expr_ptr + 32)         # field1

                inner_ty := @.check_expr(inner_ptr)

                # NOT operator returns bool
                I op == 2 {
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.bool_type()
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                } E {
                    inner_ty
                }
            }
            # EXPR_CALL = 33
            E I kind == 33 {
                func_ptr := load_i64(expr_ptr + 24)   # field0
                args_ptr := load_i64(expr_ptr + 32)   # field1
                args_len := load_i64(expr_ptr + 40)   # field2

                # Get the function being called
                func_kind := load_i64(func_ptr)
                I func_kind == 25 {  # EXPR_IDENT
                    name_idx := load_i64(func_ptr + 24)
                    fn_sig := @.find_function(name_idx)
                    I fn_sig != 0 {
                        # Check argument count
                        expected_params := load_i64(fn_sig + 32)  # params_len
                        I expected_params != args_len {
                            err := TypeError.arg_count(expected_params, args_len, span_start, span_end)
                            err_ptr := malloc(TypeError.size())
                            store_i64(err_ptr, err.kind)
                            store_i64(err_ptr + 8, err.span_start)
                            store_i64(err_ptr + 16, err.span_end)
                            store_i64(err_ptr + 24, err.expected_idx)
                            store_i64(err_ptr + 32, err.found_idx)
                            store_i64(err_ptr + 40, err.name_idx)
                            @.add_error(err_ptr)
                            0
                        } E { 0 }

                        # Get function's generic parameters
                        fn_generics_ptr := load_i64(fn_sig + 8)   # generics_ptr
                        fn_generics_len := load_i64(fn_sig + 16)  # generics_len
                        fn_params_ptr := load_i64(fn_sig + 24)    # params_ptr

                        # Type check arguments and infer generic bindings
                        @.clear_generic_bindings()
                        i: mut i64 = 0
                        L { I i >= args_len { B }
                            arg_expr_ptr := load_i64(args_ptr + i * 8)
                            arg_ty := @.check_expr(arg_expr_ptr)

                            # If function has generics, try to infer from argument types
                            I fn_generics_len > 0 && i < expected_params {
                                # Get parameter type (params are stored as (name_idx, type_ptr, is_mut) triples)
                                param_type_ptr := load_i64(fn_params_ptr + i * 24 + 8)
                                @.infer_generic_from_types(param_type_ptr, arg_ty)
                                0
                            } E { 0 }

                            i = i + 1
                        }

                        # Get return type and instantiate if needed
                        ret_type_ptr := load_i64(fn_sig + 40)
                        I fn_generics_len > 0 {
                            # Record monomorphization for codegen
                            @.record_mono_from_call(fn_sig)
                            @.instantiate_type(ret_type_ptr)
                        } E {
                            ret_type_ptr
                        }
                    } E {
                        # Undefined function
                        err := TypeError.undefined_func(name_idx, span_start, span_end)
                        err_ptr := malloc(TypeError.size())
                        store_i64(err_ptr, err.kind)
                        store_i64(err_ptr + 8, err.span_start)
                        store_i64(err_ptr + 16, err.span_end)
                        store_i64(err_ptr + 24, err.expected_idx)
                        store_i64(err_ptr + 32, err.found_idx)
                        store_i64(err_ptr + 40, err.name_idx)
                        @.add_error(err_ptr)

                        type_ptr := malloc(ResolvedType.size())
                        ty := ResolvedType.unknown_type()
                        store_i64(type_ptr, ty.kind)
                        store_i64(type_ptr + 8, ty.field0)
                        store_i64(type_ptr + 16, ty.field1)
                        store_i64(type_ptr + 24, ty.field2)
                        type_ptr
                    }
                } E {
                    # Calling a non-identifier expression
                    @.check_expr(func_ptr)
                }
            }
            # EXPR_IF = 30
            E I kind == 30 {
                cond_ptr := load_i64(expr_ptr + 24)       # field0
                then_stmts := load_i64(expr_ptr + 32)     # field1
                then_len := load_i64(expr_ptr + 40)       # field2
                else_ptr := load_i64(expr_ptr + 48)       # field3

                # Check condition is bool
                cond_ty := @.check_expr(cond_ptr)

                # Check then block
                @.push_scope()
                then_ty := @.check_stmts(then_stmts, then_len)
                @.pop_scope()

                # Check else block if present
                I else_ptr != 0 {
                    @.push_scope()
                    else_ty := @.check_else(else_ptr)
                    @.pop_scope()
                    then_ty  # Return then type (should match else)
                } E {
                    then_ty
                }
            }
            # EXPR_LOOP = 31
            E I kind == 31 {
                body_stmts := load_i64(expr_ptr + 40)  # field2
                body_len := load_i64(expr_ptr + 48)   # field3

                @.push_scope()
                @.check_stmts(body_stmts, body_len)
                @.pop_scope()

                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.unit_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # EXPR_BLOCK = 42
            E I kind == 42 {
                stmts_ptr := load_i64(expr_ptr + 24)  # field0
                stmts_len := load_i64(expr_ptr + 32)  # field1

                @.push_scope()
                result := @.check_stmts(stmts_ptr, stmts_len)
                @.pop_scope()
                result
            }
            # EXPR_RETURN = handled in check_stmt
            # EXPR_ASSIGN = 48
            E I kind == 48 {
                target_ptr := load_i64(expr_ptr + 24)  # field0
                value_ptr := load_i64(expr_ptr + 32)   # field1

                target_kind := load_i64(target_ptr)
                I target_kind == 25 {  # EXPR_IDENT
                    name_idx := load_i64(target_ptr + 24)
                    var_info := @.lookup_var(name_idx)
                    I var_info != 0 {
                        is_mut := load_i64(var_info + 8)
                        I is_mut == 0 {
                            err := TypeError.immutable_assign(name_idx, span_start, span_end)
                            err_ptr := malloc(TypeError.size())
                            store_i64(err_ptr, err.kind)
                            store_i64(err_ptr + 8, err.span_start)
                            store_i64(err_ptr + 16, err.span_end)
                            store_i64(err_ptr + 24, err.expected_idx)
                            store_i64(err_ptr + 32, err.found_idx)
                            store_i64(err_ptr + 40, err.name_idx)
                            @.add_error(err_ptr)
                            0
                        } E { 0 }
                        0
                    } E { 0 }
                    0
                } E { 0 }

                @.check_expr(value_ptr)
            }
            # EXPR_STRUCT_LIT = 40
            E I kind == 40 {
                name_idx := load_i64(expr_ptr + 24)  # field0

                # Check if struct exists
                struct_ptr := @.find_struct(name_idx)
                I struct_ptr != 0 {
                    # Record struct monomorphization if it has generics
                    struct_generics_ptr := load_i64(struct_ptr + 8)
                    struct_generics_len := load_i64(struct_ptr + 16)
                    I struct_generics_len > 0 {
                        @.record_struct_mono(name_idx, struct_generics_ptr, struct_generics_len)
                        0
                    } E { 0 }

                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.named_type(name_idx, 0, 0)
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                } E {
                    err := TypeError.undefined_type(name_idx, span_start, span_end)
                    err_ptr := malloc(TypeError.size())
                    store_i64(err_ptr, err.kind)
                    store_i64(err_ptr + 8, err.span_start)
                    store_i64(err_ptr + 16, err.span_end)
                    store_i64(err_ptr + 24, err.expected_idx)
                    store_i64(err_ptr + 32, err.found_idx)
                    store_i64(err_ptr + 40, err.name_idx)
                    @.add_error(err_ptr)

                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.unknown_type()
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                }
            }
            # EXPR_FIELD = 36
            E I kind == 36 {
                base_ptr := load_i64(expr_ptr + 24)   # field0
                field_idx := load_i64(expr_ptr + 32)  # field1

                base_ty := @.check_expr(base_ptr)
                base_kind := load_i64(base_ty)

                I base_kind == TY_NAMED() {
                    struct_name := load_i64(base_ty + 8)
                    base_generics_ptr := load_i64(base_ty + 16)  # type arguments
                    base_generics_len := load_i64(base_ty + 24)

                    struct_ptr := @.find_struct(struct_name)
                    I struct_ptr != 0 {
                        # Get struct's generic parameters
                        struct_generics_ptr := load_i64(struct_ptr + 8)   # generics_ptr
                        struct_generics_len := load_i64(struct_ptr + 16)  # generics_len

                        # If struct has generics and we have type arguments, set up bindings
                        I struct_generics_len > 0 && base_generics_len > 0 {
                            @.bind_generics(struct_generics_ptr, struct_generics_len,
                                          base_generics_ptr, base_generics_len)
                            0
                        } E { 0 }

                        # Look up field type
                        fields_ptr := load_i64(struct_ptr + 24)
                        fields_len := load_i64(struct_ptr + 32)

                        i: mut i64 = 0
                        L { I i >= fields_len { B }
                            field_name := load_i64(fields_ptr + i * 16)
                            I field_name == field_idx {
                                field_type := load_i64(fields_ptr + i * 16 + 8)
                                # Instantiate if struct has generics
                                I struct_generics_len > 0 && base_generics_len > 0 {
                                    R @.instantiate_type(field_type)
                                } E {
                                    R field_type
                                }
                            } E {
                                i = i + 1
                            }
                        }

                        # Field not found
                        type_ptr := malloc(ResolvedType.size())
                        ty := ResolvedType.unknown_type()
                        store_i64(type_ptr, ty.kind)
                        store_i64(type_ptr + 8, ty.field0)
                        store_i64(type_ptr + 16, ty.field1)
                        store_i64(type_ptr + 24, ty.field2)
                        type_ptr
                    } E {
                        base_ty
                    }
                } E {
                    base_ty
                }
            }
            # EXPR_METHOD_CALL = 34
            E I kind == 34 {
                recv_ptr := load_i64(expr_ptr + 24)    # field0
                method_idx := load_i64(expr_ptr + 32)  # field1
                args_ptr := load_i64(expr_ptr + 40)    # field2
                args_len := load_i64(expr_ptr + 48)    # field3

                recv_ty := @.check_expr(recv_ptr)

                # Resolve method call using receiver type
                @.resolve_method_call(recv_ty, method_idx, args_ptr, args_len, span_start, span_end)
            }
            # EXPR_SELF_CALL = 26
            E I kind == 26 {
                # @ alone (self reference) - return current fn context type
                # When used as @.method(), the parser wraps it in METHOD_CALL
                # If @ is used standalone, resolve as self-recursion
                I self.current_fn_name_idx != 0 {
                    fn_sig := @.find_function(self.current_fn_name_idx)
                    I fn_sig != 0 {
                        load_i64(fn_sig + 40)  # Return type of current function
                    } E {
                        type_ptr := malloc(ResolvedType.size())
                        ty := ResolvedType.unknown_type()
                        store_i64(type_ptr, ty.kind)
                        store_i64(type_ptr + 8, ty.field0)
                        store_i64(type_ptr + 16, ty.field1)
                        store_i64(type_ptr + 24, ty.field2)
                        type_ptr
                    }
                } E {
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.unknown_type()
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                }
            }
            # EXPR_STATIC_CALL = 35
            E I kind == 35 {
                type_idx := load_i64(expr_ptr + 24)    # field0 = type name_idx
                method_idx := load_i64(expr_ptr + 32)  # field1 = method name_idx
                args_ptr := load_i64(expr_ptr + 40)    # field2
                args_len := load_i64(expr_ptr + 48)    # field3

                # Type check arguments
                i: mut i64 = 0
                L { I i >= args_len { B }
                    arg_ptr := load_i64(args_ptr + i * 8)
                    @.check_expr(arg_ptr)
                    i = i + 1
                }

                # Find static method in struct's impl
                method_sig := @.find_method_in_struct(type_idx, method_idx)
                I method_sig == 0 {
                    method_sig = @.find_method_in_trait_impls(type_idx, method_idx)
                    0
                } E { 0 }

                I method_sig != 0 {
                    load_i64(method_sig + 40)  # Return type
                } E {
                    # Constructor pattern: Type.new() returns the Named type
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.named_type(type_idx, 0, 0)
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                }
            }
            # EXPR_MATCH = 32
            E I kind == 32 {
                match_expr_ptr := load_i64(expr_ptr + 24)  # field0: expression
                arms_ptr := load_i64(expr_ptr + 32)        # field1: match arms array
                arms_len := load_i64(expr_ptr + 40)        # field2: arms count

                # Check the match expression
                match_ty := @.check_expr(match_expr_ptr)

                # Check exhaustiveness
                @.check_match_exhaustiveness(match_expr_ptr, arms_ptr, arms_len, span_start, span_end)

                # Check each arm and compute result type
                result_type: mut i64 = 0
                i: mut i64 = 0
                L { I i >= arms_len { B }
                    arm_ptr := arms_ptr + i * 32  # MatchArm size estimate
                    # arm layout: pattern_ptr, guard_ptr, body_ptr, ...
                    body_ptr := load_i64(arm_ptr + 16)

                    @.push_scope()
                    arm_ty := @.check_expr(body_ptr)
                    @.pop_scope()

                    I i == 0 {
                        result_type = arm_ty
                    } E {
                        @.unify(result_type, arm_ty)
                        0
                    }
                    i = i + 1
                }

                I result_type != 0 {
                    result_type
                } E {
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.unit_type()
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                }
            }
            # EXPR_TERNARY = 29
            E I kind == 29 {
                cond_ptr := load_i64(expr_ptr + 24)   # field0
                then_ptr := load_i64(expr_ptr + 32)   # field1
                else_ptr := load_i64(expr_ptr + 40)   # field2

                @.check_expr(cond_ptr)
                then_ty := @.check_expr(then_ptr)
                else_ty := @.check_expr(else_ptr)
                @.unify(then_ty, else_ty)
                then_ty
            }
            # EXPR_INDEX = 37
            E I kind == 37 {
                base_ptr := load_i64(expr_ptr + 24)    # field0: base expression
                index_ptr := load_i64(expr_ptr + 32)   # field1: index expression

                base_ty := @.check_expr(base_ptr)
                @.check_expr(index_ptr)

                base_kind := load_i64(base_ty)
                I base_kind == TY_ARRAY() {
                    # Return element type
                    load_i64(base_ty + 8)
                } E I base_kind == TY_MAP() {
                    # Return value type
                    load_i64(base_ty + 16)
                } E {
                    base_ty
                }
            }
            # EXPR_LAMBDA = 50
            E I kind == 50 {
                @.check_lambda_with_expected(expr_ptr, @.fresh_type_var())
            }
            # EXPR_TUPLE = 39
            E I kind == 39 {
                # Check as array (Vais arrays use this expr kind)
                elements_ptr := load_i64(expr_ptr + 24)
                elements_len := load_i64(expr_ptr + 32)

                I elements_len == 0 {
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.array_type(0)
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                } E {
                    first := load_i64(elements_ptr)
                    first_ty := @.check_expr(first)
                    idx: mut i64 = 1
                    L { I idx >= elements_len { B }
                        elem := load_i64(elements_ptr + idx * 8)
                        @.check_expr(elem)
                        idx = idx + 1
                    }
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.array_type(first_ty)
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                }
            }
            # EXPR_ARRAY = 38
            E I kind == 38 {
                elements_ptr := load_i64(expr_ptr + 24)
                elements_len := load_i64(expr_ptr + 32)

                I elements_len == 0 {
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.array_type(0)
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                } E {
                    first := load_i64(elements_ptr)
                    first_ty := @.check_expr(first)
                    idx: mut i64 = 1
                    L { I idx >= elements_len { B }
                        elem := load_i64(elements_ptr + idx * 8)
                        @.check_expr(elem)
                        idx = idx + 1
                    }
                    type_ptr := malloc(ResolvedType.size())
                    ty := ResolvedType.array_type(first_ty)
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    type_ptr
                }
            }
            # EXPR_RANGE = 41
            E I kind == 41 {
                start_expr := load_i64(expr_ptr + 24)  # field0
                end_expr := load_i64(expr_ptr + 32)    # field1

                I start_expr != 0 { @.check_expr(start_expr) } E { 0 }
                I end_expr != 0 { @.check_expr(end_expr) } E { 0 }

                # Range type - returns i64 (range bounds are integers)
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.i64_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # EXPR_AWAIT = 43
            E I kind == 43 {
                inner_ptr := load_i64(expr_ptr + 24)  # field0: Future expression
                inner_ty := @.check_expr(inner_ptr)

                # Await unwraps Future<T>  T
                # If inner is Optional (Future representation), return inner type
                inner_kind := load_i64(inner_ty)
                I inner_kind == TY_OPTIONAL() || inner_kind == TY_RESULT() {
                    load_i64(inner_ty + 8)  # inner type
                } E {
                    inner_ty  # Pass through if not a Future wrapper
                }
            }
            # EXPR_TRY = 44
            E I kind == 44 {
                inner_ptr := load_i64(expr_ptr + 24)  # field0
                inner_ty := @.check_expr(inner_ptr)

                # Try (?) unwraps Result<T,E>  T or Option<T>  T
                inner_kind := load_i64(inner_ty)
                I inner_kind == TY_RESULT() || inner_kind == TY_OPTIONAL() {
                    load_i64(inner_ty + 8)  # Ok/Some inner type
                } E {
                    inner_ty
                }
            }
            # EXPR_UNWRAP = 45
            E I kind == 45 {
                inner_ptr := load_i64(expr_ptr + 24)  # field0
                inner_ty := @.check_expr(inner_ptr)

                # Unwrap (!) extracts value from Result/Option
                inner_kind := load_i64(inner_ty)
                I inner_kind == TY_RESULT() || inner_kind == TY_OPTIONAL() {
                    load_i64(inner_ty + 8)  # Ok/Some inner type
                } E {
                    inner_ty
                }
            }
            # EXPR_REF = 46
            E I kind == 46 {
                inner_ptr := load_i64(expr_ptr + 24)  # field0
                is_mut := load_i64(expr_ptr + 32)     # field1

                inner_ty := @.check_expr(inner_ptr)

                type_ptr := malloc(ResolvedType.size())
                I is_mut == 1 {
                    ty := ResolvedType { kind: TY_REF_MUT(), field0: inner_ty, field1: 0, field2: 0 }
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    0
                } E {
                    ty := ResolvedType { kind: TY_REF(), field0: inner_ty, field1: 0, field2: 0 }
                    store_i64(type_ptr, ty.kind)
                    store_i64(type_ptr + 8, ty.field0)
                    store_i64(type_ptr + 16, ty.field1)
                    store_i64(type_ptr + 24, ty.field2)
                    0
                }
                type_ptr
            }
            # EXPR_DEREF = 47
            E I kind == 47 {
                inner_ptr := load_i64(expr_ptr + 24)  # field0
                inner_ty := @.check_expr(inner_ptr)

                # Deref (*) extracts inner type from Ref/RefMut/Pointer
                inner_kind := load_i64(inner_ty)
                I inner_kind == TY_REF() || inner_kind == TY_REF_MUT() || inner_kind == TY_POINTER() {
                    load_i64(inner_ty + 8)  # inner type pointer
                } E {
                    inner_ty
                }
            }
            # EXPR_ASSIGN_OP = 49
            E I kind == 49 {
                target_ptr := load_i64(expr_ptr + 24)  # field0
                value_ptr := load_i64(expr_ptr + 32)   # field1

                @.check_expr(target_ptr)
                @.check_expr(value_ptr)

                # Assignment operations (+=, -=, etc.) return unit
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.unit_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            # EXPR_SPAWN = 51
            E I kind == 51 {
                inner_ptr := load_i64(expr_ptr + 24)  # field0: expression to spawn
                inner_ty := @.check_expr(inner_ptr)

                # Spawn wraps result in a Future/Task type (represented as Optional)
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType { kind: TY_OPTIONAL(), field0: inner_ty, field1: 0, field2: 0 }
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
            E {
                # Unknown expression type - return unknown and continue
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.unknown_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
        }
    }

    F check_else(&self, else_ptr: i64) -> i64 {
        kind := load_i64(else_ptr)
        I kind == 0 {  # else block
            stmts_ptr := load_i64(else_ptr + 16)
            stmts_len := load_i64(else_ptr + 24)
            @.check_stmts(stmts_ptr, stmts_len)
        } E {  # else-if
            cond_ptr := load_i64(else_ptr + 8)
            stmts_ptr := load_i64(else_ptr + 16)
            stmts_len := load_i64(else_ptr + 24)
            next_ptr := load_i64(else_ptr + 32)

            @.check_expr(cond_ptr)
            then_ty := @.check_stmts(stmts_ptr, stmts_len)

            I next_ptr != 0 {
                @.check_else(next_ptr)
            } E {
                then_ty
            }
        }
    }

    F check_stmt(&self, stmt_ptr: i64) -> i64 {
        kind := load_i64(stmt_ptr)
        span_start := load_i64(stmt_ptr + 8)
        span_end := load_i64(stmt_ptr + 16)

        # STMT_LET = 10
        I kind == 10 {
            name_idx := load_i64(stmt_ptr + 24)   # field0
            type_ptr := load_i64(stmt_ptr + 32)   # field1
            value_ptr := load_i64(stmt_ptr + 40)  # field2
            is_mut := load_i64(stmt_ptr + 48)     # field3

            # Resolve type annotation or infer from value
            var_type := I type_ptr != 0 {
                @.resolve_type_node(type_ptr)
            } E I value_ptr != 0 {
                @.check_expr(value_ptr)
            } E {
                @.fresh_type_var()
            }

            # Add variable to scope
            @.add_var(name_idx, var_type, is_mut)

            type_result := malloc(ResolvedType.size())
            ty := ResolvedType.unit_type()
            store_i64(type_result, ty.kind)
            store_i64(type_result + 8, ty.field0)
            store_i64(type_result + 16, ty.field1)
            store_i64(type_result + 24, ty.field2)
            type_result
        }
        # STMT_EXPR = 11
        E I kind == 11 {
            expr_ptr := load_i64(stmt_ptr + 24)  # field0
            @.check_expr(expr_ptr)
        }
        # STMT_RETURN = 12
        E I kind == 12 {
            expr_ptr := load_i64(stmt_ptr + 24)  # field0
            I expr_ptr != 0 {
                @.check_expr(expr_ptr)
            } E {
                type_ptr := malloc(ResolvedType.size())
                ty := ResolvedType.unit_type()
                store_i64(type_ptr, ty.kind)
                store_i64(type_ptr + 8, ty.field0)
                store_i64(type_ptr + 16, ty.field1)
                store_i64(type_ptr + 24, ty.field2)
                type_ptr
            }
        }
        # STMT_BREAK = 13, STMT_CONTINUE = 14
        E {
            type_ptr := malloc(ResolvedType.size())
            ty := ResolvedType.never_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        }
    }

    F check_stmts(&self, stmts_ptr: i64, stmts_len: i64) -> i64 {
        I stmts_len == 0 {
            type_ptr := malloc(ResolvedType.size())
            ty := ResolvedType.unit_type()
            store_i64(type_ptr, ty.kind)
            store_i64(type_ptr + 8, ty.field0)
            store_i64(type_ptr + 16, ty.field1)
            store_i64(type_ptr + 24, ty.field2)
            type_ptr
        } E {
            last_type: mut i64 = 0
            i: mut i64 = 0
            L { I i >= stmts_len { B }
                stmt_ptr := load_i64(stmts_ptr + i * 8)
                last_type = @.check_stmt(stmt_ptr)
                i = i + 1
            }
            last_type
        }
    }

    F check_function(&self, fn_def_ptr: i64) -> i64 {
        name_idx := load_i64(fn_def_ptr)
        generics_ptr := load_i64(fn_def_ptr + 8)
        generics_len := load_i64(fn_def_ptr + 16)
        params_ptr := load_i64(fn_def_ptr + 24)
        params_len := load_i64(fn_def_ptr + 32)
        ret_type_ptr := load_i64(fn_def_ptr + 40)
        body_kind := load_i64(fn_def_ptr + 48)
        body_expr_ptr := load_i64(fn_def_ptr + 56)
        body_stmts_ptr := load_i64(fn_def_ptr + 64)
        body_stmts_len := load_i64(fn_def_ptr + 72)

        # Set current generics and register bounds
        old_generics_ptr := self.current_generics_ptr
        old_generics_len := self.current_generics_len
        old_bounds_len := self.bounds_len
        self.current_generics_ptr = generics_ptr
        self.current_generics_len = generics_len

        # Register trait bounds from generic parameters if present
        I generics_len > 0 {
            @.register_generic_bounds(generics_ptr, generics_len)
            0
        } E { 0 }

        # Resolve return type
        ret_resolved := @.resolve_type_node(ret_type_ptr)
        self.current_fn_ret_ptr = ret_resolved
        self.current_fn_name_idx = name_idx

        # Create new scope for function body
        @.push_scope()

        # Add parameters to scope
        i: mut i64 = 0
        L { I i >= params_len { B }
            param_ptr := params_ptr + i * 40  # Param.size() = 40
            param_name := load_i64(param_ptr)
            param_type_ptr := load_i64(param_ptr + 8)
            param_is_mut := load_i64(param_ptr + 16)

            param_resolved := @.resolve_type_node(param_type_ptr)
            @.add_var(param_name, param_resolved, param_is_mut)
            i = i + 1
        }

        # Check body
        I body_kind == 0 {
            # Expression body
            @.check_expr(body_expr_ptr)
        } E {
            # Block body
            @.check_stmts(body_stmts_ptr, body_stmts_len)
        }

        @.pop_scope()

        # Restore generics and bounds
        self.current_generics_ptr = old_generics_ptr
        self.current_generics_len = old_generics_len
        self.bounds_len = old_bounds_len
        self.current_fn_ret_ptr = 0
        self.current_fn_name_idx = 0

        1
    }

    F check_struct(&self, struct_def_ptr: i64) -> i64 {
        # Struct definitions are collected in first pass
        # Type check field types here
        fields_ptr := load_i64(struct_def_ptr + 24)
        fields_len := load_i64(struct_def_ptr + 32)

        i: mut i64 = 0
        L { I i >= fields_len { B }
            field_type_ptr := load_i64(fields_ptr + i * 40 + 8)
            @.resolve_type_node(field_type_ptr)
            i = i + 1
        }
        1
    }

    F check_enum(&self, enum_def_ptr: i64) -> i64 {
        # EnumDefInfo layout:
        # 0: name_idx, 8: generics_ptr, 16: generics_len
        # 24: variants_ptr, 32: variants_len
        variants_ptr := load_i64(enum_def_ptr + 24)
        variants_len := load_i64(enum_def_ptr + 32)

        # Validate each variant's field types
        i: mut i64 = 0
        L { I i >= variants_len { B }
            # Variant layout: name_idx(0), fields_kind(8), fields_ptr(16), fields_len(24)
            variant_ptr := variants_ptr + i * 48
            fields_kind := load_i64(variant_ptr + 8)
            fields_ptr := load_i64(variant_ptr + 16)
            fields_len := load_i64(variant_ptr + 24)

            # For tuple variants (fields_kind=1), resolve each field type
            I fields_kind == 1 {
                j: mut i64 = 0
                L { I j >= fields_len { B }
                    field_type_ptr := load_i64(fields_ptr + j * 8)
                    @.resolve_type_node(field_type_ptr)
                    j = j + 1
                }
                0
            } E { 0 }

            i = i + 1
        }
        1
    }

    F check_type_alias(&self, alias_def_ptr: i64) -> i64 {
        # TypeAlias is resolved during registration, just validate target type
        # TypeAliasDef layout: name_idx(0), type_ptr(8)
        target_type := load_i64(alias_def_ptr + 8)
        I target_type != 0 {
            @.resolve_type_node(target_type)
            0
        } E { 0 }
        1
    }

    # Register impl methods on the target struct (called during first pass)
    F register_impl_methods(&self, impl_def_ptr: i64) -> i64 {
        # ImplDef layout:
        # 0: target_type_ptr, 8: trait_name_idx, 16: generics_ptr
        # 24: generics_len, 32: methods_ptr, 40: methods_len

        target_type_ptr := load_i64(impl_def_ptr)
        trait_name_idx := load_i64(impl_def_ptr + 8)
        methods_ptr := load_i64(impl_def_ptr + 32)
        methods_len := load_i64(impl_def_ptr + 40)

        I methods_len == 0 { R 1 }

        # Get target type name
        target_kind := load_i64(target_type_ptr)
        I target_kind == 60 {  # TYPE_NAMED (in ast: 60)
            target_type_idx := load_i64(target_type_ptr + 24)  # field0 = name_idx

            # Find the struct and update its methods_ptr/methods_len
            struct_ptr := @.find_struct(target_type_idx)
            I struct_ptr != 0 {
                existing_methods_ptr := load_i64(struct_ptr + 40)
                existing_methods_len := load_i64(struct_ptr + 48)

                # Merge: create new array with existing + new methods
                total_len := existing_methods_len + methods_len
                new_methods := malloc(total_len * 8)

                # Copy existing methods
                I existing_methods_len > 0 {
                    memcpy(new_methods, existing_methods_ptr, existing_methods_len * 8)
                    0
                } E { 0 }

                # Register each new method as a FunctionSig and add to array
                j: mut i64 = 0
                L { I j >= methods_len { B }
                    method_fn_ptr := load_i64(methods_ptr + j * 8)
                    # Create FunctionSig from method FuncDef
                    sig_ptr := malloc(FunctionSig.size())
                    method_name := load_i64(method_fn_ptr)
                    store_i64(sig_ptr, method_name)
                    store_i64(sig_ptr + 8, load_i64(method_fn_ptr + 8))   # generics_ptr
                    store_i64(sig_ptr + 16, load_i64(method_fn_ptr + 16)) # generics_len
                    store_i64(sig_ptr + 24, load_i64(method_fn_ptr + 24)) # params_ptr
                    store_i64(sig_ptr + 32, load_i64(method_fn_ptr + 32)) # params_len

                    # Resolve return type
                    ret_type_node := load_i64(method_fn_ptr + 40)
                    ret_resolved := @.resolve_type_node(ret_type_node)
                    store_i64(sig_ptr + 40, ret_resolved)
                    store_i64(sig_ptr + 48, 0)  # is_async

                    store_i64(new_methods + (existing_methods_len + j) * 8, sig_ptr)

                    # Also register as a global function for find_function lookup
                    @.add_function(sig_ptr)

                    j = j + 1
                }

                # Update struct
                store_i64(struct_ptr + 40, new_methods)
                store_i64(struct_ptr + 48, total_len)
                0
            } E { 0 }

            # If this is a trait impl, also register TraitImplInfo
            I trait_name_idx >= 0 {
                impl_info_ptr := malloc(TraitImplInfo.size())
                store_i64(impl_info_ptr, target_type_idx)
                store_i64(impl_info_ptr + 8, trait_name_idx)
                store_i64(impl_info_ptr + 16, methods_ptr)
                store_i64(impl_info_ptr + 24, methods_len)
                @.add_trait_impl(impl_info_ptr)
                0
            } E { 0 }
        } E { 0 }
        1
    }

    F check_impl(&self, impl_def_ptr: i64) -> i64 {
        # ImplDef layout:
        # 0: target_type_ptr
        # 8: trait_name_idx (-1 if no trait)
        # 16: generics_ptr
        # 24: generics_len
        # 32: methods_ptr
        # 40: methods_len

        target_type_ptr := load_i64(impl_def_ptr)
        trait_name_idx := load_i64(impl_def_ptr + 8)
        methods_ptr := load_i64(impl_def_ptr + 32)
        methods_len := load_i64(impl_def_ptr + 40)

        # If this is a trait impl, verify the trait exists and check required methods
        I trait_name_idx >= 0 {
            trait_ptr := @.find_trait(trait_name_idx)
            I trait_ptr == 0 {
                # Trait not found - error
                err := TypeError.undefined_type(trait_name_idx, 0, 0)
                err_ptr := malloc(TypeError.size())
                store_i64(err_ptr, err.kind)
                store_i64(err_ptr + 8, err.span_start)
                store_i64(err_ptr + 16, err.span_end)
                store_i64(err_ptr + 24, err.expected_idx)
                store_i64(err_ptr + 32, err.found_idx)
                store_i64(err_ptr + 40, err.name_idx)
                @.add_error(err_ptr)
            } E {
                # Get target type name from TypeNode
                # TypeNode: kind (i64) + name_idx (i64) + ...
                target_kind := load_i64(target_type_ptr)
                I target_kind == 1 {  # TYPE_NAMED
                    target_type_idx := load_i64(target_type_ptr + 8)

                    # Register this trait implementation
                    impl_info_ptr := malloc(TraitImplInfo.size())
                    store_i64(impl_info_ptr, target_type_idx)
                    store_i64(impl_info_ptr + 8, trait_name_idx)
                    store_i64(impl_info_ptr + 16, methods_ptr)
                    store_i64(impl_info_ptr + 24, methods_len)
                    @.add_trait_impl(impl_info_ptr)

                    # Verify all required trait methods are implemented
                    trait_methods_ptr := load_i64(trait_ptr + 40)
                    trait_methods_len := load_i64(trait_ptr + 48)

                    j: mut i64 = 0
                    L { I j >= trait_methods_len { B }
                        trait_method_ptr := load_i64(trait_methods_ptr + j * 8)
                        trait_method_name := load_i64(trait_method_ptr)

                        # Check if this method is implemented
                        found: mut i64 = 0
                        k: mut i64 = 0
                        L { I k >= methods_len { B }
                            impl_method_ptr := load_i64(methods_ptr + k * 8)
                            impl_method_name := load_i64(impl_method_ptr)
                            I impl_method_name == trait_method_name {
                                found = 1
                                B
                            } E { 0 }
                            k = k + 1
                        }

                        # Missing method check - for now just log, could add error
                        # (trait methods may have default impls which we don't track yet)

                        j = j + 1
                    }
                } E { 0 }
            }
        } E { 0 }

        # Type check all methods
        i: mut i64 = 0
        L { I i >= methods_len { B }
            method_ptr := load_i64(methods_ptr + i * 8)
            @.check_function(method_ptr)
            i = i + 1
        }
        1
    }

    F check_trait(&self, trait_def_ptr: i64) -> i64 {
        # TraitDef layout:
        # 0: name_idx
        # 8: generics_ptr
        # 16: generics_len
        # 24: super_traits_ptr
        # 32: super_traits_len
        # 40: methods_ptr
        # 48: methods_len
        # 56: is_pub
        # 64: span_start
        # 72: span_end

        name_idx := load_i64(trait_def_ptr)
        generics_ptr := load_i64(trait_def_ptr + 8)
        generics_len := load_i64(trait_def_ptr + 16)
        super_traits_ptr := load_i64(trait_def_ptr + 24)
        super_traits_len := load_i64(trait_def_ptr + 32)
        methods_ptr := load_i64(trait_def_ptr + 40)
        methods_len := load_i64(trait_def_ptr + 48)

        # Verify all super traits exist
        i: mut i64 = 0
        L { I i >= super_traits_len { B }
            super_trait_idx := load_i64(super_traits_ptr + i * 8)
            super_trait_ptr := @.find_trait(super_trait_idx)
            I super_trait_ptr == 0 {
                err := TypeError.undefined_type(super_trait_idx, 0, 0)
                err_ptr := malloc(TypeError.size())
                store_i64(err_ptr, err.kind)
                store_i64(err_ptr + 8, err.span_start)
                store_i64(err_ptr + 16, err.span_end)
                store_i64(err_ptr + 24, err.expected_idx)
                store_i64(err_ptr + 32, err.found_idx)
                store_i64(err_ptr + 40, err.name_idx)
                @.add_error(err_ptr)
            } E { 0 }
            i = i + 1
        }

        # Type check trait methods
        # Set up generic context for trait generics
        old_generics_ptr := self.current_generics_ptr
        old_generics_len := self.current_generics_len
        self.current_generics_ptr = generics_ptr
        self.current_generics_len = generics_len

        i = 0
        L { I i >= methods_len { B }
            method_ptr := load_i64(methods_ptr + i * 8)
            # For trait methods, we only check signatures (may not have body)
            # FuncDef body_ptr is at offset 48
            body_ptr := load_i64(method_ptr + 48)
            I body_ptr != 0 {
                @.check_function(method_ptr)
            } E { 0 }
            i = i + 1
        }

        # Restore generic context
        self.current_generics_ptr = old_generics_ptr
        self.current_generics_len = old_generics_len

        1
    }

    F check_item(&self, item_ptr: i64) -> i64 {
        kind := load_i64(item_ptr)
        data_ptr := load_i64(item_ptr + 8)

        # ITEM_FUNCTION = 1
        I kind == 1 {
            @.check_function(data_ptr)
        }
        # ITEM_STRUCT = 2
        E I kind == 2 {
            @.check_struct(data_ptr)
        }
        # ITEM_ENUM = 3
        E I kind == 3 {
            @.check_enum(data_ptr)
        }
        # ITEM_TYPE_ALIAS = 4
        E I kind == 4 {
            @.check_type_alias(data_ptr)
        }
        # ITEM_USE = 5 (handled at module level, skip)
        # ITEM_TRAIT = 6
        E I kind == 6 {
            @.check_trait(data_ptr)
        }
        # ITEM_IMPL = 7
        E I kind == 7 {
            @.check_impl(data_ptr)
        }
        E { 1 }
    }

    F check_module(&self, module_ptr: i64) -> i64 {
        items_ptr := load_i64(module_ptr)
        items_len := load_i64(module_ptr + 8)

        # Set string pool
        sp_data := load_i64(module_ptr + 24)
        sp_offsets := load_i64(module_ptr + 32)
        sp_count := load_i64(module_ptr + 56)
        @.set_string_pool(sp_data, sp_offsets, sp_count)

        # First pass: collect all type definitions
        i: mut i64 = 0
        L { I i >= items_len { B }
            item_ptr := items_ptr + i * 32
            kind := load_i64(item_ptr)
            data_ptr := load_i64(item_ptr + 8)

            # ITEM_STRUCT = 2
            I kind == 2 {
                @.add_struct(data_ptr)
            }
            # ITEM_ENUM = 3
            E I kind == 3 {
                @.add_enum(data_ptr)
            }
            # ITEM_TRAIT = 6
            E I kind == 6 {
                @.register_trait(data_ptr)
            }
            # ITEM_FUNCTION = 1
            E I kind == 1 {
                # Register function signature
                sig_ptr := malloc(FunctionSig.size())
                name_idx := load_i64(data_ptr)
                store_i64(sig_ptr, name_idx)
                store_i64(sig_ptr + 8, load_i64(data_ptr + 8))   # generics_ptr
                store_i64(sig_ptr + 16, load_i64(data_ptr + 16)) # generics_len
                store_i64(sig_ptr + 24, load_i64(data_ptr + 24)) # params_ptr
                store_i64(sig_ptr + 32, load_i64(data_ptr + 32)) # params_len

                # Resolve return type
                ret_type_node := load_i64(data_ptr + 40)
                ret_resolved := @.resolve_type_node(ret_type_node)
                store_i64(sig_ptr + 40, ret_resolved)
                store_i64(sig_ptr + 48, load_i64(data_ptr + 88)) # is_async

                @.add_function(sig_ptr)
            }
            # ITEM_IMPL = 7
            E I kind == 7 {
                # Register impl methods on the struct for method resolution
                @.register_impl_methods(data_ptr)
            } E { 0 }

            i = i + 1
        }

        # Second pass: type check all items
        i = 0
        L { I i >= items_len { B }
            item_ptr := items_ptr + i * 32
            @.check_item(item_ptr)
            i = i + 1
        }

        I self.errors_len == 0 { 1 } E { 0 }
    }

    F drop(&self) -> i64 {
        # Free all scopes
        i: mut i64 = 0
        L { I i >= self.scopes_len { B }
            scope_ptr := load_i64(self.scopes_ptr + i * 8)
            vars_ptr := load_i64(scope_ptr)
            free(vars_ptr)
            free(scope_ptr)
            i = i + 1
        }

        free(self.scopes_ptr)
        free(self.structs_ptr)
        free(self.enums_ptr)
        free(self.functions_ptr)
        free(self.traits_ptr)
        free(self.trait_impls_ptr)
        free(self.errors_ptr)
        free(self.subst_keys_ptr)
        free(self.subst_values_ptr)
        free(self.bounds_keys_ptr)
        free(self.bounds_values_ptr)
        free(self.mono_entries_ptr)
        free(self.struct_mono_ptr)
        free(self.assoc_types_ptr)
        1
    }
}

# ============================================================================
# Test function (renamed from main to allow module import)
# ============================================================================

F test_type_checker_main() -> i64 {
    puts("Type checker module loaded")

    # Test ResolvedType creation
    ty := ResolvedType.i64_type()
    I ty.kind == TY_I64() {
        puts("ResolvedType i64: OK")
    } E {
        puts("ResolvedType i64: FAIL")
    }

    I ty.is_numeric() == 1 {
        puts("is_numeric: OK")
    } E {
        puts("is_numeric: FAIL")
    }

    I ty.is_integer() == 1 {
        puts("is_integer: OK")
    } E {
        puts("is_integer: FAIL")
    }

    # Test bool type
    bool_ty := ResolvedType.bool_type()
    I bool_ty.kind == TY_BOOL() {
        puts("ResolvedType bool: OK")
    } E {
        puts("ResolvedType bool: FAIL")
    }

    I bool_ty.is_numeric() == 0 {
        puts("bool is_numeric: OK")
    } E {
        puts("bool is_numeric: FAIL")
    }

    # Test TypeChecker creation
    tc := TypeChecker.new()
    I tc.scopes_len == 1 {
        puts("TypeChecker initial scope: OK")
    } E {
        puts("TypeChecker initial scope: FAIL")
    }

    # Test scope operations
    tc.push_scope()
    I tc.scopes_len == 2 {
        puts("push_scope: OK")
    } E {
        puts("push_scope: FAIL")
    }

    tc.pop_scope()
    I tc.scopes_len == 1 {
        puts("pop_scope: OK")
    } E {
        puts("pop_scope: FAIL")
    }

    # Test variable registration
    type_ptr := malloc(ResolvedType.size())
    ty2 := ResolvedType.i64_type()
    store_i64(type_ptr, ty2.kind)
    store_i64(type_ptr + 8, ty2.field0)
    store_i64(type_ptr + 16, ty2.field1)
    store_i64(type_ptr + 24, ty2.field2)

    tc.add_var(0, type_ptr, 1)  # name_idx=0, type=i64, is_mut=1

    found := tc.lookup_var(0)
    I found != 0 {
        puts("Variable lookup: OK")
    } E {
        puts("Variable lookup: FAIL")
    }

    # Test function registration
    sig := FunctionSig.new(1)  # name_idx = 1
    sig_ptr := malloc(FunctionSig.size())
    store_i64(sig_ptr, sig.name_idx)
    store_i64(sig_ptr + 8, sig.generics_ptr)
    store_i64(sig_ptr + 16, sig.generics_len)
    store_i64(sig_ptr + 24, sig.params_ptr)
    store_i64(sig_ptr + 32, sig.params_len)
    store_i64(sig_ptr + 40, type_ptr)  # ret type
    store_i64(sig_ptr + 48, sig.is_async)

    tc.add_function(sig_ptr)

    fn_found := tc.find_function(1)
    I fn_found != 0 {
        puts("Function lookup: OK")
    } E {
        puts("Function lookup: FAIL")
    }

    # Test error tracking
    I tc.has_errors() == 0 {
        puts("No errors initially: OK")
    } E {
        puts("No errors initially: FAIL")
    }

    # Test bidirectional type checking - unification
    puts("\n--- Bidirectional Type Inference Tests ---")

    # Test fresh type variable
    var1 := tc.fresh_type_var()
    var_kind := load_i64(var1)
    I var_kind == TY_VAR() {
        puts("fresh_type_var: OK")
    } E {
        puts("fresh_type_var: FAIL")
    }

    # Test substitution
    i64_type := malloc(ResolvedType.size())
    i64_ty := ResolvedType.i64_type()
    store_i64(i64_type, i64_ty.kind)
    store_i64(i64_type + 8, i64_ty.field0)
    store_i64(i64_type + 16, i64_ty.field1)
    store_i64(i64_type + 24, i64_ty.field2)

    var_id := load_i64(var1 + 8)
    tc.add_substitution(var_id, i64_type)
    subst_result := tc.get_substitution(var_id)
    I subst_result == i64_type {
        puts("add_substitution/get_substitution: OK")
    } E {
        puts("add_substitution/get_substitution: FAIL")
    }

    # Test apply_substitutions
    applied := tc.apply_substitutions(var1)
    applied_kind := load_i64(applied)
    I applied_kind == TY_I64() {
        puts("apply_substitutions: OK")
    } E {
        puts("apply_substitutions: FAIL")
    }

    # Test unification of same types
    bool_type := malloc(ResolvedType.size())
    bt := ResolvedType.bool_type()
    store_i64(bool_type, bt.kind)
    store_i64(bool_type + 8, bt.field0)
    store_i64(bool_type + 16, bt.field1)
    store_i64(bool_type + 24, bt.field2)

    bool_type2 := malloc(ResolvedType.size())
    store_i64(bool_type2, bt.kind)
    store_i64(bool_type2 + 8, bt.field0)
    store_i64(bool_type2 + 16, bt.field1)
    store_i64(bool_type2 + 24, bt.field2)

    I tc.unify(bool_type, bool_type2) == 1 {
        puts("unify same types: OK")
    } E {
        puts("unify same types: FAIL")
    }

    # Test unification of different types (should fail)
    I tc.unify(i64_type, bool_type) == 0 {
        puts("unify different types (should fail): OK")
    } E {
        puts("unify different types (should fail): FAIL")
    }

    # Test unification with type variable
    tc.clear_substitutions()
    var2 := tc.fresh_type_var()
    I tc.unify(var2, i64_type) == 1 {
        puts("unify type var with concrete: OK")
    } E {
        puts("unify type var with concrete: FAIL")
    }

    # Verify substitution was created
    var2_id := load_i64(var2 + 8)
    bound_type := tc.get_substitution(var2_id)
    I bound_type == i64_type {
        puts("type var binding: OK")
    } E {
        puts("type var binding: FAIL")
    }

    # Test array type unification
    tc.clear_substitutions()
    arr_i64 := malloc(ResolvedType.size())
    arr := ResolvedType.array_type(i64_type)
    store_i64(arr_i64, arr.kind)
    store_i64(arr_i64 + 8, arr.field0)
    store_i64(arr_i64 + 16, arr.field1)
    store_i64(arr_i64 + 24, arr.field2)

    arr_i64_2 := malloc(ResolvedType.size())
    store_i64(arr_i64_2, arr.kind)
    store_i64(arr_i64_2 + 8, arr.field0)
    store_i64(arr_i64_2 + 16, arr.field1)
    store_i64(arr_i64_2 + 24, arr.field2)

    I tc.unify(arr_i64, arr_i64_2) == 1 {
        puts("unify array types: OK")
    } E {
        puts("unify array types: FAIL")
    }

    # Test array type with type variable element
    tc.clear_substitutions()
    var3 := tc.fresh_type_var()
    arr_var := malloc(ResolvedType.size())
    arr_var_ty := ResolvedType.array_type(var3)
    store_i64(arr_var, arr_var_ty.kind)
    store_i64(arr_var + 8, arr_var_ty.field0)
    store_i64(arr_var + 16, arr_var_ty.field1)
    store_i64(arr_var + 24, arr_var_ty.field2)

    I tc.unify(arr_var, arr_i64) == 1 {
        puts("unify array with type var element: OK")
    } E {
        puts("unify array with type var element: FAIL")
    }

    # Verify the type variable was bound
    var3_id := load_i64(var3 + 8)
    bound_elem := tc.get_substitution(var3_id)
    I bound_elem != 0 {
        bound_elem_kind := load_i64(bound_elem)
        I bound_elem_kind == TY_I64() {
            puts("array element type var binding: OK")
        } E {
            puts("array element type var binding: FAIL (wrong kind)")
        }
    } E {
        puts("array element type var binding: FAIL (no binding)")
    }

    # Test format_type for primitive types
    puts("\n--- Type Formatting Tests ---")

    # format_type for i64
    sb1 := tc.format_type(i64_type)
    sb1_data := load_i64(sb1)
    sb1_len := load_i64(sb1 + 8)
    # i64 = 3 chars: 'i','6','4'
    I sb1_len == 3 && load_byte(sb1_data) == 105 && load_byte(sb1_data + 1) == 54 && load_byte(sb1_data + 2) == 52 {
        puts("format_type i64: OK")
    } E {
        puts("format_type i64: FAIL")
    }
    free(sb1_data)
    free(sb1)

    # format_type for bool
    sb2 := tc.format_type(bool_type)
    sb2_data := load_i64(sb2)
    sb2_len := load_i64(sb2 + 8)
    # bool = 4 chars: 'b','o','o','l'
    I sb2_len == 4 && load_byte(sb2_data) == 98 {
        puts("format_type bool: OK")
    } E {
        puts("format_type bool: FAIL")
    }
    free(sb2_data)
    free(sb2)

    # format_type for array of i64  "[i64]"
    sb3 := tc.format_type(arr_i64)
    sb3_data := load_i64(sb3)
    sb3_len := load_i64(sb3 + 8)
    # [i64] = 5 chars: '[','i','6','4',']'
    I sb3_len == 5 && load_byte(sb3_data) == 91 && load_byte(sb3_data + 4) == 93 {
        puts("format_type [i64]: OK")
    } E {
        puts("format_type [i64]: FAIL")
    }
    free(sb3_data)
    free(sb3)

    # format_type for unit  "()"
    unit_type_ptr := malloc(ResolvedType.size())
    unit_ty := ResolvedType.unit_type()
    store_i64(unit_type_ptr, unit_ty.kind)
    store_i64(unit_type_ptr + 8, unit_ty.field0)
    store_i64(unit_type_ptr + 16, unit_ty.field1)
    store_i64(unit_type_ptr + 24, unit_ty.field2)
    sb4 := tc.format_type(unit_type_ptr)
    sb4_data := load_i64(sb4)
    sb4_len := load_i64(sb4 + 8)
    I sb4_len == 2 && load_byte(sb4_data) == 40 && load_byte(sb4_data + 1) == 41 {
        puts("format_type (): OK")
    } E {
        puts("format_type (): FAIL")
    }
    free(sb4_data)
    free(sb4)

    # format_type for null pointer  "?"
    sb5 := tc.format_type(0)
    sb5_data := load_i64(sb5)
    sb5_len := load_i64(sb5 + 8)
    I sb5_len == 1 && load_byte(sb5_data) == 63 {
        puts("format_type null: OK")
    } E {
        puts("format_type null: FAIL")
    }
    free(sb5_data)
    free(sb5)

    # Test print_errors (with no errors  should print nothing)
    tc2 := TypeChecker.new()
    count := tc2.print_errors()
    I count == 0 {
        puts("print_errors (empty): OK")
    } E {
        puts("print_errors (empty): FAIL")
    }
    tc2.drop()

    free(unit_type_ptr)

    # Cleanup
    free(type_ptr)
    free(sig_ptr)
    free(i64_type)
    free(bool_type)
    free(bool_type2)
    free(arr_i64)
    free(arr_i64_2)
    free(arr_var)
    tc.drop()

    puts("\nAll type checker tests passed!")
    0
}
