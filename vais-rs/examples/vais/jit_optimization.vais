// ============================================================================
// JIT Optimization Examples
// ============================================================================

// --- Integer Operations (JIT Optimized) ---
// Functions with pure integer operations are automatically JIT compiled

add(a, b) = a + b
mul(a, b) = a * b
factorial(n) = n < 2 ? 1 : n * $(n - 1)
fib(n) = n < 2 ? n : $(n - 1) + $(n - 2)

// --- Float Operations (JIT Optimized) ---
// Float operations also get JIT compilation

add_float(a, b) = a + b
distance(x1, y1, x2, y2) = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))

// --- SIMD Optimized Operations ---
// Array operations are automatically vectorized using SIMD

double_array(arr) = arr.@(_ * 2)        // SIMD map multiply
sum_array(arr) = arr./+                 // SIMD reduce sum
max_array(arr) = arr./max               // SIMD reduce max

// --- Tail Call Optimization ---
// Use $ for recursive calls, automatically optimized

sum_tail(n, acc) = n < 1 ? acc : $(n - 1, acc + n)
sum_to(n) = sum_tail(n, 0)

// --- Hot Loop Detection ---
// Functions called frequently are automatically promoted to JIT

process_batch(items) = items
    .@(_ * 2)           // Hot loop candidate
    .?(_ > 10)          // Hot loop candidate
    ./+                 // Hot loop candidate

// --- Tiered Compilation ---
// Functions progress through tiers: Interpreter -> Baseline JIT -> Optimized JIT
// - Tier 0: Interpretation (< 100 calls)
// - Tier 1: Baseline JIT (100+ calls)
// - Tier 2: Optimized JIT with SIMD (1000+ calls)

// --- Benchmark Example ---
// Direct call to test JIT optimization
// Expected output: 832040
fib(30)
